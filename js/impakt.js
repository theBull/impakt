/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='../models/models.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./interfaces.ts' />
/// <reference path='./ICollection.ts' />
/// <reference path='./ICollectionItem.ts' />
/// <reference path='./ILinkedListNode.ts' />
/// <reference path='./IModifiable.ts' />
/// <reference path='./IModifiableCollection.ts' />
/// <reference path='./IStorable.ts' />
/// <reference path='./IActionable.ts' />
/// <reference path='./IActionableCollection.ts' />
/// <reference path='./IScrollable.ts' />
/// <reference path='./IListener.ts' />
/// <reference path='./IPlaceable.ts' />
/// <reference path='./ISelectable.ts' />
/// <reference path='./IDraggable.ts' />
/// <reference path='./ILayerable.ts' />
/// <reference path='./IDrawable.ts' />
/// <reference path='./IContextual.ts' />
/// <reference path='./IHoverable.ts' />
/// <reference path='./IAssociable.ts' />
/// <reference path='./IPlay.ts' />
/// <reference path='./IScenario.ts' />
/// <reference path='./IPaper.ts' />
/// <reference path='./IGrid.ts' />
/// <reference path='./ICanvas.ts' />
/// <reference path='./IField.ts' />
/// <reference path='./IFieldElement.ts' />
/// <reference path='./IPlayer.ts' />
/// <reference path='./IBall.ts' />
/// <reference path='./IGround.ts' />
/// <reference path='./IEndzone.ts' />
/// <reference path='./ILineOfScrimmage.ts' />
/// <reference path='./IHashmark.ts' />
/// <reference path='./ISideline.ts' />
/// <reference path='./IPlayer.ts' />
/// <reference path='./IPlayerSelectionBox.ts' />
/// <reference path='./IPlayerIcon.ts' />
/// <reference path='./IPlayerRelativeCoordinatesLabel.ts' />
/// <reference path='./IPlayerPersonnelLabel.ts' />
/// <reference path='./IPlayerIndexLabel.ts' />
/// <reference path='./IRoute.ts' />
/// <reference path='./IRouteAction.ts' />
/// <reference path='./IRouteControlPath.ts' />
/// <reference path='./IRouteNode.ts' />
/// <reference path='./IRoutePath.ts' />
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Storable = (function () {
            function Storable() {
                this.guid = Common.Utilities.guid();
            }
            Storable.prototype.toJson = function () {
                return {
                    guid: this.guid
                };
            };
            Storable.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
            };
            return Storable;
        })();
        Models.Storable = Storable;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Modifiable = (function (_super) {
            __extends(Modifiable, _super);
            function Modifiable() {
                _super.call(this);
                this.lastModified = Date.now();
                this.modified = false;
                this.checksum = null;
                this.original = null;
                // always listening. To prevent re-hashing from occurring when initializing
                // an object, insert the .listen(false) method into the method chain prior
                // to calling a method that will trigger a modification.
                this.listening = true;
                this.callbacks = [];
                this.isContextSet = false;
            }
            Modifiable.prototype.checkContextSet = function () {
                if (!this.context || !this.isContextSet)
                    throw new Error('Modifiable: context is not set. Call setContext(context) before using this class');
            };
            Modifiable.prototype.setContext = function (context) {
                this.context = context;
                this.isContextSet = true;
            };
            /**
             * Allows for switching the listening mechanism on or off
             * within a method chain. listen(false) would prevent
             * any mutation from triggering a rehash. Does not
             * trigger a modification event when setting to true,
             * you must invoke the modification event directly and
             * separately if needed.
             *
             * @param {boolean} startListening true or false
             */
            Modifiable.prototype.listen = function (startListening) {
                this.listening = startListening;
                return this;
            };
            Modifiable.prototype.hasListeners = function () {
                return Common.Utilities.isNotNullOrUndefined(this.callbacks) && this.callbacks.length > 0;
            };
            Modifiable.prototype.clearListeners = function () {
                // empty all callbacks
                this.callbacks = [];
            };
            /**
             * Register listeners to be fired when this object is modified.
             * NOTE: the modifier will only keep the listener passed in if
             * listening == true; otherwise, listeners will be ignored.
             *
             * @param {Function} callback function to invoke when a modification
             * occurs to this object.
             */
            Modifiable.prototype.onModified = function (callback) {
                if (this.listening) {
                    this.callbacks.push(callback);
                }
            };
            Modifiable.prototype.isModified = function () {
                if (this.listening) {
                    // current checksum and stored checksum mismatch; modified
                    this.modified = true;
                    // track the modification date/time
                    this.lastModified = Date.now();
                    // invoke each of the modifiable's callbacks
                    for (var i = 0; i < this.callbacks.length; i++) {
                        var callback = this.callbacks[i];
                        callback(this.context);
                    }
                }
            };
            /**
             * Determines whether there are any changes to the object,
             * or allows for explicitly committing a modification to the
             * object to trigger its modification listeners to fire.
             *
             * @param  {boolean} isModified (optional) true forces modification
             * @return {boolean}            returns whether the object is modified
             */
            Modifiable.prototype.setModified = function (forciblyModify) {
                if (!this.listening) {
                    this.modified = false;
                    return false;
                }
                else {
                    var cs = this.generateChecksum();
                    if (forciblyModify || cs !== this.checksum) {
                        // trigger all callbacks listening for changes
                        this.isModified();
                    }
                    else {
                        this.modified = false;
                    }
                    this.checksum = cs;
                }
                return this.modified;
            };
            /**
             * Generates a new checksum from the current object
             * @return {string} the newly generated checksum
             */
            Modifiable.prototype.generateChecksum = function () {
                this.checkContextSet();
                // determine current checksum
                var json = this.context.toJson();
                return Common.Utilities.generateChecksum(json);
            };
            Modifiable.prototype.copy = function (newElement, context) {
                this.checkContextSet();
                var copiedJson = context.toJson();
                newElement.fromJson(copiedJson);
                newElement.setModified(true);
                return newElement;
            };
            Modifiable.prototype.toJson = function () {
                return $.extend({
                    lastModified: this.lastModified,
                    checksum: this.checksum
                }, _super.prototype.toJson.call(this));
            };
            Modifiable.prototype.fromJson = function (json) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                this.lastModified = json.lastModified;
                this.original = json.checksum;
                this.checksum = Common.Utilities.generateChecksum(this.toJson());
                _super.prototype.fromJson.call(this, json);
            };
            return Modifiable;
        })(Common.Models.Storable);
        Models.Modifiable = Modifiable;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Collection = (function (_super) {
            __extends(Collection, _super);
            function Collection(size) {
                if (Common.Utilities.isNotNullOrUndefined(size) && size < 0)
                    throw new Error('Collection constructor(): Cannot create a collection with size < 0');
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this._count = 0;
                this._keys = new Array(size || 0);
            }
            Collection.prototype.copy = function (newCollection) {
                var copyCollection = newCollection || new Common.Models.Collection();
                return _super.prototype.copy.call(this, copyCollection, this);
            };
            Collection.prototype._getKey = function (data) {
                if (data && data.guid) {
                    return data.guid;
                }
                else {
                    //throw new Error('Object does not have a guid');
                    console.error('Object does not have a guid');
                }
            };
            Collection.prototype._ensureKeyType = function (key) {
                if (typeof key == 'string') {
                    // could be valid string 'foo' or number hidden as string '2'
                    // convert '2' to 2
                    var k = key.toString();
                    var ki = parseInt(k);
                    key = isNaN(ki) || k.indexOf('-') > -1 ? k : ki;
                }
                return key;
            };
            Collection.prototype.size = function () {
                return this._count;
            };
            Collection.prototype.isEmpty = function () {
                return this.size() == 0;
            };
            Collection.prototype.hasElements = function () {
                return this.size() > 0;
            };
            Collection.prototype.get = function (key) {
                key = this._ensureKeyType(key);
                return this[key];
            };
            Collection.prototype.exists = function (key) {
                return this.contains(key);
            };
            Collection.prototype.first = function () {
                return this.getOne();
            };
            Collection.prototype.getOne = function () {
                return this[this._keys[0]];
            };
            Collection.prototype.getIndex = function (index) {
                return this.get(this._keys[index]);
            };
            Collection.prototype.getAll = function () {
                var obj = {};
                for (var i = 0; i < this._keys.length; i++) {
                    var key = this._keys[i];
                    // shitty way of hiding private properties
                    obj[key] = this.get(key);
                }
                return obj;
            };
            /**
             * Retrieves the last element in the collection
             * @return {T} [description]
             */
            Collection.prototype.getLast = function () {
                var key = this._keys[this._keys.length - 1];
                return this.get(key);
            };
            Collection.prototype.set = function (key, data, listen) {
                if (!this.hasOwnProperty(key.toString()))
                    throw Error('Object does not have key ' + key + '. Use the add(key) method.');
                this[key] = data;
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                if (listen !== false)
                    this.setModified(true);
            };
            Collection.prototype.replace = function (replaceKey, data) {
                var key = this._getKey(data);
                this._keys[this._keys.indexOf(replaceKey)] = key;
                this[key] = data;
                delete this[replaceKey];
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
            };
            Collection.prototype.setAtIndex = function (index, data) {
                if (index < 0 || index > this._count - 1)
                    throw new Error('Collection setAtIndex(): index is out of bounds; ' + index);
                var key = this._keys[index];
                if (Common.Utilities.isNullOrUndefined(key))
                    return null;
                this.set(key, data);
            };
            Collection.prototype.add = function (data, listen) {
                var key = this._getKey(data);
                if (this[key] && this._keys.indexOf(key) > -1) {
                    this.set(key, data, listen);
                }
                else {
                    this[key] = data;
                    // NOTE:
                    // Here, we must consider that since the collection can
                    // be initialized with a given size, we don't want to just
                    // arbitrarily 'push()' the added data on to the end of the
                    // array; instead, we must use the internal _count variable
                    // which keeps track of the actual number of elements in the
                    // array, regardless of its initialized size, and always
                    // add the new element at the index after the last-inserted
                    // element.
                    this._keys[this._count] = key;
                    this._count++;
                    var self_1 = this;
                    data.onModified(function (item) {
                        self_1.setModified(true);
                    });
                    if (listen !== false)
                        this.setModified(true);
                }
            };
            Collection.prototype.addAll = function (elements) {
                if (!elements || elements.length < 1)
                    return;
                for (var i = 0; i < elements.length; i++) {
                    var item = elements[i];
                    if (item) {
                        // this.add(item, false) <- NOTE: false
                        // defer the set modification until 
                        // after all items have been added
                        this.add(item, false);
                    }
                }
                this.setModified(true);
            };
            Collection.prototype.addAtIndex = function (data, index) {
                var key = this._getKey(data);
                var exists = this._keys.indexOf(key) > -1;
                if (!exists || this._keys.indexOf(key) == index) {
                    // element exists at that index, update	
                    // OR, element does not exist, add at index
                    this[key] = data;
                    this._keys[index] = key;
                    if (!exists) {
                        this._count++;
                        var self_2 = this;
                        data.onModified(function () {
                            self_2.setModified(true);
                        });
                        this.setModified(true);
                    }
                }
                else {
                    // element exists at different index...
                    // ignore for now...
                    var currentIndex = this._keys.indexOf(key);
                    throw new Error([
                        'The element you want to add at this',
                        ' index already exists at index (',
                        currentIndex,
                        '). Ignoring for now...'
                    ].join(''));
                }
            };
            Collection.prototype.only = function (data) {
                this.removeAll();
                this.add(data);
            };
            Collection.prototype.append = function (collection) {
                // adds the given collection onto the end of this collection
                // E.g.
                // this -> [1, 2, 3]
                // collection -> [4, 5, 6]
                // this.append(collection) -> [1, 2, 3, 4, 5, 6]
                var self = this;
                collection.forEach(function (item, index) {
                    if (item && item.guid) {
                        if (this.clearListeners) {
                            item.clearListeners();
                        }
                        self.add(item);
                    }
                    else {
                        throw new Error('item is null or does not have guid');
                    }
                });
            };
            Collection.prototype.forEach = function (iterator) {
                if (!this._keys)
                    return;
                for (var i = 0; i < this._keys.length; i++) {
                    var key = this._keys[i];
                    iterator(this[key], i);
                }
            };
            Collection.prototype.hasElementWhich = function (predicate) {
                return this.filterFirst(predicate) != null;
            };
            Collection.prototype.filter = function (predicate) {
                var results = [];
                this.forEach(function (element, index) {
                    if (predicate(element)) {
                        results.push(element);
                    }
                });
                return results;
            };
            Collection.prototype.filterFirst = function (predicate) {
                var results = this.filter(predicate);
                return results && results.length > 0 ? results[0] : null;
            };
            Collection.prototype.remove = function (key) {
                if (!this[key]) {
                    console.warn('Collection remove(): Tried to remove item, \
					but item with guid does not exist: ', key);
                    return;
                }
                var obj = this[key];
                delete this[key];
                this._keys.splice(this._keys.indexOf(key), 1);
                this._count--;
                this.setModified(true);
                return obj;
            };
            Collection.prototype.pop = function () {
                var key = this._keys[this._count - 1];
                return this.remove(key);
            };
            Collection.prototype.empty = function () {
                this.removeAll();
            };
            Collection.prototype.removeAll = function () {
                while (this._count > 0) {
                    var key = this._keys[0];
                    this.remove(key);
                }
            };
            /**
             * Allows you to run an iterator method over each item
             * in the collection before the collection is completely
             * emptied.
             */
            Collection.prototype.removeEach = function (iterator) {
                // first, run the iterator over each item in the
                // collection
                this.forEach(iterator);
                // now remove all of them
                this.removeAll();
            };
            Collection.prototype.contains = function (key) {
                return this[key] != null && this[key] != undefined;
            };
            Collection.prototype.toArray = function () {
                var arr = [];
                for (var i = 0; i < this._keys.length; i++) {
                    arr.push(this.get(this._keys[i]));
                }
                return arr;
            };
            Collection.prototype.toJson = function () {
                var results = [];
                this.forEach(function (element, index) {
                    results.push(element ? element.toJson() : null);
                });
                return results;
            };
            Collection.prototype.getGuids = function () {
                return this._keys;
            };
            return Collection;
        })(Common.Models.Modifiable);
        Models.Collection = Collection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var LinkedList = (function (_super) {
            __extends(LinkedList, _super);
            function LinkedList() {
                _super.call(this);
                this.root = null;
                this.last = null;
                this._length = 0;
                this._modifiable = new Common.Models.Modifiable();
                this._modifiable.setContext(this);
                this.callbacks = this._modifiable.callbacks;
                this.modified = this._modifiable.modified;
                this.checksum = this._modifiable.checksum;
                this.original = this._modifiable.original;
                this.lastModified = this._modifiable.lastModified;
                this.context = this._modifiable.context;
                this.isContextSet = this._modifiable.isContextSet;
                this.listening = this._modifiable.listening;
            }
            LinkedList.prototype.setModified = function (forciblyModify) {
                var modified = this._modifiable.setModified(forciblyModify === true);
                this.modified = this._modifiable.modified;
                this.checksum = this._modifiable.checksum;
                this.lastModified = this._modifiable.lastModified;
                return modified;
            };
            LinkedList.prototype.onModified = function (callback) {
                var self = this;
                this._modifiable.onModified(callback);
                this.forEach(function (modifiableItem, index) {
                    if (Common.Utilities.isNullOrUndefined(modifiableItem))
                        return;
                    modifiableItem.onModified(function () {
                        // child elements modified, 
                        // propegate changes up to the parent
                        self.setModified(true);
                    });
                });
            };
            LinkedList.prototype.isModified = function () {
                this._modifiable.isModified();
                this.lastModified = this._modifiable.lastModified;
            };
            /**
             * When commanding the collection whether to listen,
             * apply the true/false argument to all of its contents as well
             * @param {boolean} startListening true to start listening, false to stop
             */
            LinkedList.prototype.listen = function (startListening) {
                this._modifiable.listening = startListening;
                this.listening = startListening;
                return this;
            };
            LinkedList.prototype.add = function (node, listen) {
                if (!this.root) {
                    this.root = node;
                    this.root.prev = null;
                }
                else {
                    var temp = this.root;
                    while (temp.next != null) {
                        temp = temp.next;
                    }
                    node.prev = temp;
                    temp.next = node;
                }
                this.last = node;
                this._length++;
                var self = this;
                node.onModified(function () {
                    self.setModified(true);
                });
                if (listen !== false)
                    this.setModified(true);
            };
            LinkedList.prototype.getIndex = function (index) {
                var count = 0;
                var temp = this.root;
                if (!temp)
                    return null;
                while (temp) {
                    if (count == index)
                        return temp;
                    if (temp.next) {
                        temp = temp.next;
                        count++;
                    }
                    else {
                        return null;
                    }
                }
            };
            LinkedList.prototype.first = function () {
                return this.root;
            };
            LinkedList.prototype.forEach = function (iterator) {
                var index = 0;
                var temp = this.root;
                iterator(temp, index);
                if (!temp)
                    return;
                while (temp.next != null) {
                    temp = temp.next;
                    index++;
                    iterator(temp, index);
                }
            };
            LinkedList.prototype.toJson = function () {
                var arr = [];
                this.forEach(function (node, i) {
                    if (node && node.toJson) {
                        arr.push(node.toJson());
                    }
                });
                return arr;
            };
            LinkedList.prototype.toArray = function () {
                var arr = Array();
                this.forEach(function (node, i) {
                    arr.push(node);
                });
                return arr;
            };
            LinkedList.prototype.getLast = function () {
                return this.last;
            };
            LinkedList.prototype.getRoot = function () {
                return this.root;
            };
            LinkedList.prototype.remove = function (guid) {
                return;
            };
            LinkedList.prototype.size = function () {
                return this._length;
            };
            LinkedList.prototype.hasElements = function () {
                return this.size() > 0;
            };
            LinkedList.prototype.isEmpty = function () {
                return !this.hasElements();
            };
            return LinkedList;
        })(Common.Models.Storable);
        Models.LinkedList = LinkedList;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
/**
 *
 *
 *
 *
 *
 *
 *   DEPRECATED!!
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var ModifiableCollection = (function () {
            function ModifiableCollection(size) {
                this._modifiable = new Common.Models.Modifiable();
                this._modifiable.setContext(this);
                this.callbacks = this._modifiable.callbacks;
                this.modified = this._modifiable.modified;
                this.lastModified = this._modifiable.lastModified;
                this.original = this._modifiable.original;
                this.checksum = this._modifiable.checksum;
                this.context = this._modifiable.context;
                this.isContextSet = this._modifiable.isContextSet;
                this.listening = this._modifiable.listening;
                this._collection = new Common.Models.Collection(size);
                this.guid = this._modifiable.guid;
            }
            ModifiableCollection.prototype.setModified = function (forciblyModify) {
                var modified = this._modifiable.setModified(forciblyModify === true);
                this.modified = this._modifiable.modified;
                this.checksum = this._modifiable.checksum;
                this.lastModified = this._modifiable.lastModified;
                return modified;
            };
            ModifiableCollection.prototype.onModified = function (callback) {
                var self = this;
                this._modifiable.onModified(callback);
                this._collection.forEach(function (modifiableItem, index) {
                    if (Common.Utilities.isNullOrUndefined(modifiableItem))
                        return;
                    modifiableItem.onModified(function () {
                        // child elements modified, 
                        // propegate changes up to the parent
                        self.isModified();
                    });
                });
            };
            ModifiableCollection.prototype.isModified = function () {
                this._modifiable.isModified();
                this.lastModified = this._modifiable.lastModified;
            };
            /**
             * When commanding the collection whether to listen,
             * apply the true/false argument to all of its contents as well
             * @param {boolean} startListening true to start listening, false to stop
             */
            ModifiableCollection.prototype.listen = function (startListening) {
                this._modifiable.listening = startListening;
                this.listening = startListening;
                return this;
            };
            ModifiableCollection.prototype.size = function () {
                return this._collection.size();
            };
            ModifiableCollection.prototype.isEmpty = function () {
                return this._collection.isEmpty();
            };
            ModifiableCollection.prototype.hasElements = function () {
                return this._collection.hasElements();
            };
            ModifiableCollection.prototype.exists = function (key) {
                return this._collection.exists(key);
            };
            ModifiableCollection.prototype.get = function (key) {
                return this._collection.get(key);
            };
            ModifiableCollection.prototype.first = function () {
                return this._collection.first();
            };
            ModifiableCollection.prototype.getOne = function () {
                return this._collection.getOne();
            };
            ModifiableCollection.prototype.getIndex = function (index) {
                return this._collection.getIndex(index);
            };
            ModifiableCollection.prototype.set = function (key, data) {
                this._collection.set(key, data);
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.replace = function (replaceKey, data) {
                this._collection.replace(replaceKey, data);
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.setAtIndex = function (index, data) {
                this._collection.setAtIndex(index, data);
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.add = function (data) {
                this._collection.add(data);
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.addAll = function (elements) {
                if (!elements || elements.length == 0)
                    return this;
                this._collection.addAll(elements);
                var self = this;
                for (var i = 0; i < elements.length; i++) {
                    var modifiable = elements[i];
                    modifiable.onModified(function () {
                        self.setModified(true);
                    });
                }
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.addAtIndex = function (data, index) {
                this._collection.addAtIndex(data, index);
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.only = function (data) {
                this._collection.only(data);
                var self = this;
                data.onModified(function () {
                    self.setModified(true);
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.append = function (collection, clearListeners) {
                this._collection.append(collection);
                var self = this;
                collection.forEach(function (modifiable, index) {
                    // clear any existing listeners from the
                    // items in the appended collection and
                    // re-register new listeners
                    if (clearListeners)
                        modifiable.clearListeners();
                    modifiable.onModified(function () {
                        self.setModified(true);
                    });
                });
                this.setModified(true);
                return this;
            };
            ModifiableCollection.prototype.forEach = function (iterator) {
                this._collection.forEach(iterator);
            };
            ModifiableCollection.prototype.hasElementWhich = function (predicate) {
                return this._collection.hasElementWhich(predicate);
            };
            ModifiableCollection.prototype.filter = function (predicate) {
                return this._collection.filter(predicate);
            };
            ModifiableCollection.prototype.filterFirst = function (predicate) {
                return this._collection.filterFirst(predicate);
            };
            ModifiableCollection.prototype.remove = function (key) {
                var results = this._collection.remove(key);
                this.setModified(true);
                return results;
            };
            ModifiableCollection.prototype.removeAll = function () {
                this._collection.removeAll();
                this.setModified(true);
            };
            ModifiableCollection.prototype.empty = function () {
                this.removeAll();
            };
            /**
             * Allows you to run an iterator method over each item
             * in the collection before the collection is completely
             * emptied.
             */
            ModifiableCollection.prototype.removeEach = function (iterator) {
                this._collection.removeEach(iterator);
                this.setModified(true);
            };
            ModifiableCollection.prototype.contains = function (key) {
                return this._collection.contains(key);
            };
            ModifiableCollection.prototype.getAll = function () {
                return this._collection.getAll();
            };
            ModifiableCollection.prototype.getLast = function () {
                return this._collection.getLast();
            };
            ModifiableCollection.prototype.toArray = function () {
                return this._collection.toArray();
            };
            ModifiableCollection.prototype.toJson = function () {
                return this._collection.toJson();
            };
            ModifiableCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this._collection.fromJson(json._collection);
            };
            ModifiableCollection.prototype.copy = function (newElement, context) {
                console.error('ModifiableCollection copy() not implemented');
                return null;
            };
            ModifiableCollection.prototype.getGuids = function () {
                return this._collection.getGuids();
            };
            return ModifiableCollection;
        })();
        Models.ModifiableCollection = ModifiableCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Datetime = (function () {
            function Datetime() {
                this.date = new Date();
                this.time = null;
                // TODO @theBull handle meridian
                // TODO @theBull handle timezone
                this.options = {
                    // maxDate: new Date(2020, 12, 31),
                    // minDate: new Date(),
                    startingDay: 1,
                    showWeeks: true
                };
                this.popup = {
                    opened: false
                };
                this.format = 'MM/DD/YYYY';
            }
            Datetime.prototype.toJson = function () {
                return {
                    date: this.date,
                    time: this.time,
                    meridian: this.meridian,
                    timezone: this.timezone,
                    format: this.format
                };
            };
            Datetime.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.date = new Date(json.date);
                this.time = json.time;
                this.meridian = json.meridian;
                this.timezone = json.timezone;
                this.format = json.format;
            };
            Datetime.prototype.openPopup = function () {
                this.popup.opened = true;
            };
            Datetime.prototype.closePopup = function () {
                this.popup.opened = false;
            };
            Datetime.prototype.togglePopup = function (open) {
                this.popup.opened = !this.popup.opened || open === true ? this.openPopup() : this.closePopup();
            };
            Datetime.prototype.getFormatted = function () {
                return moment(this.date).format(this.format);
            };
            return Datetime;
        })();
        Models.Datetime = Datetime;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Expandable = (function (_super) {
            __extends(Expandable, _super);
            function Expandable($element) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                // don't listen to modification changes
                // to Expandable objects
                this.listen(false);
                if (Common.Utilities.isNullOrUndefined($element))
                    throw new Error('Expandable constructor(): $element is null or undefined');
                this.$element = $element;
                this.direction;
                this.min = 3; // in em's
                this.max = 32; // in em's
                this.em = parseInt($('body').css('font-size'));
                this.collapsed = true;
                this.ready = false;
                this.url = null;
                this.handle = new Common.Models.ExpandableHandle();
                // do a little clean up; the UI glitches due to the flex
                // property rendering if $element does not have an explicitly
                // set width, so we add the class 'width3' to the HTML element
                // by default and remove it once we're in here.
                this.$element.removeClass('width3');
            }
            Expandable.prototype.setHandleClass = function () {
                this.handle.class = this.collapsed ? this.handle.collapsed : this.handle.expanded;
            };
            /**
             * Deprecated
             * @param {[type]} value [description]
             */
            Expandable.prototype.getWidth = function (width) {
                return this.em * width;
            };
            /**
             * Deprecated
             */
            Expandable.prototype.getInitialWidth = function () {
                return this.collapsed ? this.getWidth(this.min) : this.getWidth(this.max);
            };
            Expandable.prototype.getInitialClass = function () {
                return this.collapsed ? this.getMinClass() : this.getMaxClass();
            };
            Expandable.prototype.toggle = function () {
                !this.collapsed ? this.close() : this.open();
            };
            Expandable.prototype.open = function () {
                this.collapsed = false;
                this.$element.removeClass(this.getMinClass()).addClass(this.getMaxClass());
                this.setHandleClass();
            };
            Expandable.prototype.close = function () {
                this.collapsed = true;
                this.$element.removeClass(this.getMaxClass()).addClass(this.getMinClass());
                this.setHandleClass();
            };
            Expandable.prototype.getMinClass = function () {
                return 'width' + this.min;
            };
            Expandable.prototype.getMaxClass = function () {
                return 'width' + this.max;
            };
            Expandable.prototype.setInitialClass = function () {
                this.$element.addClass(this.getInitialClass());
            };
            Expandable.prototype.initializeToggleHandle = function () {
                switch (this.direction) {
                    case 'left':
                        this.handle.position = 'top0 left0';
                        this.handle.expanded = 'glyphicon-chevron-right';
                        this.handle.collapsed = 'glyphicon-chevron-left';
                        break;
                    case 'right':
                        this.handle.position = 'top0 right0';
                        this.handle.expanded = 'glyphicon-chevron-left';
                        this.handle.collapsed = 'glyphicon-chevron-right';
                        break;
                    case 'top':
                        this.handle.position = 'top0 left0';
                        this.handle.expanded = 'glyphicon-chevron-up';
                        this.handle.collapsed = 'glyphicon-chevron-down';
                        break;
                    case 'bottom':
                        this.handle.position = 'bottom0 left0';
                        this.handle.expanded = 'glyphicon-chevron-down';
                        this.handle.collapsed = 'glyphicon-chevron-up';
                        break;
                }
                this.setHandleClass();
            };
            return Expandable;
        })(Common.Models.Modifiable);
        Models.Expandable = Expandable;
        var ExpandableHandle = (function () {
            function ExpandableHandle() {
                this.position = '';
                this.collapsed = '';
                this.expanded = '';
                this.class = '';
            }
            return ExpandableHandle;
        })();
        Models.ExpandableHandle = ExpandableHandle;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var ContextmenuData = (function () {
            function ContextmenuData(data, pageX, pageY, message) {
                this.data = data;
                this.url = data.contextmenuTemplateUrl;
                this.pageX = pageX;
                this.pageY = pageY;
                this.message = message || 'Contextmenu opened';
            }
            return ContextmenuData;
        })();
        Models.ContextmenuData = ContextmenuData;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var ActionRegistry = (function () {
            function ActionRegistry() {
            }
            return ActionRegistry;
        })();
        Models.ActionRegistry = ActionRegistry;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Actionable = (function (_super) {
            __extends(Actionable, _super);
            function Actionable(impaktDataType) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.impaktDataType = impaktDataType;
                this.disabled = false;
                this.selected = false;
                this.clickable = true;
                this.hoverable = true;
                this.hovered = false;
                this.dragging = false;
                this.draggable = true;
                this.selectable = true;
                this.flipped = false;
                this.flippable = false;
            }
            Actionable.prototype.toJson = function () {
                return $.extend({
                    graphics: this.hasGraphics() ? this.graphics.toJson() : null
                }, _super.prototype.toJson.call(this));
            };
            Actionable.prototype.fromJson = function (json) {
                if (!json)
                    return;
                // if(json.graphics)
                //     this.graphics.fromJson(json.graphics);
                _super.prototype.fromJson.call(this, json);
            };
            Actionable.prototype.hasGraphics = function () {
                return Common.Utilities.isNotNullOrUndefined(this.graphics);
            };
            /**
             * Toggles the opacity for show/hide effect
             */
            Actionable.prototype.toggleOpacity = function () {
                if (!this.disabled &&
                    !this.selected &&
                    this.hoverable) {
                    this.graphics.toggleOpacity();
                }
            };
            /**
             * Generic selection toggle
             */
            Actionable.prototype.isSelectable = function () {
                return !this.disabled && this.selectable;
            };
            Actionable.prototype.toggleSelect = function (metaKey) {
                metaKey = metaKey === true;
                if (!this.isSelectable())
                    return;
                if (this.selected)
                    this.deselect();
                else
                    this.select();
            };
            /**
             * Generic selection method
             */
            Actionable.prototype.select = function () {
                if (!this.isSelectable())
                    return;
                this.selected = true;
                if (this.hasGraphics()) {
                    this.graphics.select();
                }
            };
            /**
             * Generic deselection method
             */
            Actionable.prototype.deselect = function () {
                if (!this.isSelectable())
                    return;
                this.selected = false;
                if (this.hasGraphics()) {
                    this.graphics.deselect();
                }
            };
            /**
             * Generic disable method
             */
            Actionable.prototype.disable = function () {
                this.disabled = true;
                if (this.hasGraphics()) {
                    this.graphics.disable();
                }
            };
            /**
             * Generic enable method
             */
            Actionable.prototype.enable = function () {
                this.disabled = false;
                if (this.hasGraphics()) {
                    this.graphics.enable();
                }
            };
            Actionable.prototype.getContextmenuUrl = function () {
                return this.contextmenuTemplateUrl;
            };
            Actionable.prototype.drop = function () {
                this.dragging = false;
                if (this.hasGraphics())
                    this.graphics.drop();
            };
            Actionable.prototype.onhover = function (hoverIn, hoverOut, context) {
                if (this.hasGraphics())
                    this.graphics.onhover(hoverIn, hoverOut, context);
            };
            Actionable.prototype.hoverIn = function (e) {
                this.hovered = true;
                if (this.hasGraphics())
                    this.graphics.hoverIn(e);
            };
            Actionable.prototype.hoverOut = function (e) {
                this.hovered = false;
                if (this.hasGraphics())
                    this.graphics.hoverOut(e);
            };
            Actionable.prototype.onclick = function (fn, context) {
                if (this.hasGraphics())
                    this.graphics.onclick(fn, context);
            };
            Actionable.prototype.click = function (e) {
                if (this.hasGraphics())
                    this.graphics.click(e);
            };
            Actionable.prototype.oncontextmenu = function (fn, context) {
                if (this.hasGraphics())
                    this.graphics.oncontextmenu(fn, context);
            };
            Actionable.prototype.contextmenu = function (e) {
                if (this.hasGraphics())
                    this.graphics.contextmenu(e);
            };
            Actionable.prototype.onmousedown = function (fn, context) {
                if (this.hasGraphics())
                    this.graphics.onmousedown(fn, context);
            };
            Actionable.prototype.onmouseup = function (fn, context) {
                if (this.hasGraphics())
                    this.graphics.onmouseup(fn, context);
            };
            Actionable.prototype.mousedown = function (e) {
                if (this.hasGraphics())
                    this.graphics.mousedown(e);
            };
            Actionable.prototype.onmousemove = function (fn, context) {
                if (this.hasGraphics())
                    this.graphics.onmousemove(fn, context);
            };
            Actionable.prototype.mousemove = function (e) {
                if (this.hasGraphics())
                    this.graphics.mousemove(e);
            };
            Actionable.prototype.ondrag = function (dragMove, dragStart, dragEnd, context) {
                if (this.hasGraphics())
                    this.graphics.ondrag(dragMove, dragStart, dragEnd, context);
            };
            return Actionable;
        })(Common.Models.Modifiable);
        Models.Actionable = Actionable;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var ActionableCollection = (function (_super) {
            __extends(ActionableCollection, _super);
            function ActionableCollection() {
                _super.call(this);
            }
            ActionableCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            ActionableCollection.prototype.fromJson = function (json) {
                _super.prototype.fromJson.call(this, json);
            };
            ActionableCollection.prototype.deselectAll = function () {
                this.forEach(function (element, index) {
                    element.deselect();
                });
            };
            ActionableCollection.prototype.selectAll = function () {
                this.forEach(function (element, index) {
                    element.select();
                });
            };
            ActionableCollection.prototype.select = function (element) {
                if (Common.Utilities.isNullOrUndefined(element))
                    return;
                this.deselectAll();
                var selectedElement = this.get(element.guid);
                if (Common.Utilities.isNotNullOrUndefined(selectedElement))
                    selectedElement.select();
            };
            ActionableCollection.prototype.deselect = function (element) {
                if (Common.Utilities.isNullOrUndefined(element))
                    return;
                var deselectedElement = this.get(element.guid);
                if (Common.Utilities.isNotNullOrUndefined(deselectedElement))
                    deselectedElement.deselect();
            };
            ActionableCollection.prototype.toggleSelect = function (element) {
                if (Common.Utilities.isNullOrUndefined(element))
                    return;
                if (element.selected)
                    this.deselect(element);
                else
                    this.select(element);
            };
            ActionableCollection.prototype.hoverIn = function (element) {
                if (Common.Utilities.isNullOrUndefined(element))
                    return;
                this.hoverOutAll();
                element.hoverIn(null);
            };
            ActionableCollection.prototype.hoverOut = function (element) {
                if (Common.Utilities.isNullOrUndefined(element))
                    return;
                element.hoverOut(null);
            };
            ActionableCollection.prototype.hoverOutAll = function () {
                this.forEach(function (element, index) {
                    element.hoverOut(null);
                });
            };
            return ActionableCollection;
        })(Common.Models.Collection);
        Models.ActionableCollection = ActionableCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var AssociableEntity = (function (_super) {
            __extends(AssociableEntity, _super);
            function AssociableEntity(impaktDataType) {
                _super.call(this, impaktDataType);
                this.key = 0;
                this.impaktDataType = impaktDataType;
                this.associationKey = null;
                this.name = null;
                /**
                 * This array maintains a list of associable data types,
                 * by key name, which can be found in AssociationResults.ts.
                 *
                 * The idea is that Associable Entities only have certain
                 * associations that they can map to, and we want to allow
                 * the Entity to define what those applicable associations are.
                 *
                 * For example, the Associable Entity `League` may only be
                 * two-way-associated to `Conference`, `Division` and `Team`,
                 * and each in turn also define their associability back to `League`.
                 *
                 * The `associable` list is not an all-authoritive structure;
                 * setting this does not prevent certain other associations from being
                 * created programmatically between two Associable Entites that
                 * do not have one another defined within their `associable` list.
                 * It is up to the developer to decide how to best use this list.
                 *
                 * One use case is to render a set of UI controls that allow the user
                 * to manage an Associable Entity's associations, but only renders
                 * the controls for each element in the `assosciable` array.
                 *
                 * @type {Array}
                 */
                this.associable = [
                    'playbooks',
                    'scenarios',
                    'plays',
                    'formations',
                    'personnel',
                    'assignmentGroups',
                    'leagues',
                    'conferences',
                    'divisions',
                    'locations',
                    'teams',
                    'seasons',
                    'games'
                ];
            }
            AssociableEntity.prototype.generateAssociationKey = function () {
                this.associationKey = [
                    this.impaktDataType,
                    '|',
                    this.key,
                    '|',
                    this.guid
                ].join('');
            };
            AssociableEntity.prototype.toJson = function () {
                return $.extend({
                    key: this.key,
                    impaktDataType: this.impaktDataType,
                    associationKey: this.associationKey,
                    name: this.name
                }, _super.prototype.toJson.call(this));
            };
            AssociableEntity.prototype.fromJson = function (json) {
                if (!json)
                    throw new Error('AssociableEntity fromJson(): json is null or undefined');
                this.key = json.key;
                this.impaktDataType = json.impaktDataType;
                this.name = json.name;
                _super.prototype.fromJson.call(this, json);
                this.generateAssociationKey();
            };
            return AssociableEntity;
        })(Common.Models.Actionable);
        Models.AssociableEntity = AssociableEntity;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var AssociableEntityCollection = (function (_super) {
            __extends(AssociableEntityCollection, _super);
            function AssociableEntityCollection(impaktDataType, size) {
                _super.call(this, size);
                this._associableEntity = new Common.Models.AssociableEntity(impaktDataType);
            }
            AssociableEntityCollection.prototype.toJson = function () {
                return $.extend(this._associableEntity.toJson(), _super.prototype.toJson.call(this));
            };
            AssociableEntityCollection.prototype.fromJson = function (json) {
                if (!json)
                    throw new Error('AssociableEntity fromJson(): json is null or undefined');
                this._associableEntity.fromJson(json);
                _super.prototype.fromJson.call(this, json);
            };
            return AssociableEntityCollection;
        })(Common.Models.Collection);
        Models.AssociableEntityCollection = AssociableEntityCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var AssociationCollection = (function (_super) {
            __extends(AssociationCollection, _super);
            function AssociationCollection(contextId) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this._data = {};
                this._size = 0;
                this.contextId = contextId;
            }
            /**
             * Returns the size of the association collection
             * @return {number} size
             */
            AssociationCollection.prototype.size = function () {
                return this._size;
            };
            /**
             * Returns whether the association collection has elements
             * @return {boolean} true or false
             */
            AssociationCollection.prototype.isEmpty = function () {
                return this.size() == 0;
            };
            /**
             * Returns whether the array has elements
             * @return {boolean} true or false
             */
            AssociationCollection.prototype.hasElements = function () {
                return this.size() > 0;
            };
            /**
             * Creates an association, and an inverse association, between
             * the two given entities.
             *
             * @param {Common.Interfaces.IAssociable} fromEntity [description]
             * @param {Common.Interfaces.IAssociable} toEntity   [description]
             */
            AssociationCollection.prototype.add = function (fromEntity, toEntity) {
                var fromAssociation = new Common.Models.Association(fromEntity.key, fromEntity.impaktDataType, fromEntity.guid, toEntity.key, toEntity.impaktDataType, toEntity.guid, this.contextId);
                this.addAssociation(fromAssociation);
            };
            /**
             * Creates an association between the given entity and all of the
             * given array of entities.
             *
             * @param {Common.Interfaces.IAssociable}   fromEntity [description]
             * @param {Common.Interfaces.IAssociable[]} entities   [description]
             */
            AssociationCollection.prototype.addAll = function (fromEntity, entities) {
                if (Common.Utilities.isNullOrUndefined(entities))
                    throw new Error('AssociationCollection addAll(): entities[] is null or undefined');
                for (var i = 0; i < entities.length; i++) {
                    var toEntity = entities[i];
                    if (Common.Utilities.isNullOrUndefined(toEntity))
                        continue;
                    var fromAssociation = new Common.Models.Association(fromEntity.key, fromEntity.impaktDataType, fromEntity.guid, toEntity.key, toEntity.impaktDataType, toEntity.guid, this.contextId);
                    this.addAssociation(fromAssociation);
                }
            };
            /**
             * Creates an 'inverse' association with the given association, and
             * adds both to the association collection
             *
             * @param {Common.Models.Association} association the 'from' association
             */
            AssociationCollection.prototype.addAssociation = function (association) {
                var toAssociation = new Common.Models.Association(association.toKey, association.toType, association.toGuid, association.fromKey, association.fromType, association.fromGuid, this.contextId);
                if (!this._data[association.internalKey]) {
                    this._data[association.internalKey] = [];
                    this._size++;
                }
                if (this._data[association.internalKey].indexOf(toAssociation.internalKey) < 0)
                    this._data[association.internalKey].push(toAssociation.internalKey);
                if (!this._data[toAssociation.internalKey]) {
                    this._data[toAssociation.internalKey] = [];
                    this._size++;
                }
                if (this._data[toAssociation.internalKey].indexOf(association.internalKey) < 0)
                    this._data[toAssociation.internalKey].push(association.internalKey);
            };
            AssociationCollection.prototype.addInternalKey = function (internalKey, associations) {
                if (Common.Utilities.isNullOrUndefined(internalKey) ||
                    Common.Utilities.isNullOrUndefined(associations)) {
                    throw new Error('AssociationCollection addInternalKey(): \
					internalKey or associations[] is null or undefined');
                }
                if (this.exists(internalKey)) {
                    // merge the internalKey's associations
                    // with the existing internalKey's associations
                    this._data[internalKey] = Common.Utilities.uniqueArray(this._data[internalKey].concat(associations));
                }
                else {
                    this._data[internalKey] = associations;
                    this._size++;
                }
            };
            /**
             * Merges another association collection into this association collection;
             * ignores any duplicate entries.
             *
             * @param {Common.Models.AssociationCollection} associationCollection association collection to merge
             */
            AssociationCollection.prototype.merge = function (associationCollection) {
                if (Common.Utilities.isNullOrUndefined(associationCollection))
                    throw new Error('AssignmentCollection merge(): associationCollection to \
					merge is null or undefined');
                if (associationCollection.isEmpty())
                    return;
                // iterate over all entries in associationCollection to merge
                var targetCollection = this;
                associationCollection.forEach(function (self, internalKey) {
                    // gather the to merge collection's array of associations
                    var associations = self.getByInternalKey(internalKey);
                    // add the internalKey to the target collection with blank array
                    targetCollection.addInternalKey(internalKey, associations);
                });
            };
            AssociationCollection.prototype.getByInternalKey = function (internalKey) {
                if (Common.Utilities.isNullOrUndefined(internalKey))
                    throw new Error('AssociationCollection get(): internalKey is null or undefined');
                return this._data[internalKey];
            };
            AssociationCollection.prototype.hasAssociations = function (internalKey) {
                if (Common.Utilities.isNullOrUndefined(internalKey))
                    throw new Error('AssociationCollection hasAssociations(): internalKey is null or undefined');
                if (!this.exists(internalKey)) {
                    return false;
                }
                var associations = this._data[internalKey];
                if (Common.Utilities.isNullOrUndefined(associations)) {
                    // shouldn't be null or undefined, so let's set it
                    // for proper house keeping...any issues with this,
                    // or any reason an internal key might point to null/undefined?
                    this._data[internalKey] = [];
                }
                return associations.length > 0;
            };
            AssociationCollection.prototype.empty = function () {
                this._data = {};
                this._size = 0;
            };
            AssociationCollection.prototype.delete = function (internalKey) {
                if (Common.Utilities.isNullOrUndefined(internalKey))
                    throw new Error('AssociationCollection remove(): internalKey is null or undefined');
                var associationsRemoved = new Common.Models.AssociationCollection(this.contextId);
                if (this.exists(internalKey)) {
                    var internalKeyParts = Common.Models.Association.parse(internalKey);
                    var associations = this._data[internalKey];
                    for (var i = 0; i < associations.length; i++) {
                        if (Common.Utilities.isNullOrUndefined(associations[i]))
                            continue;
                        var associatedKeyParts = Common.Models.Association.parse(associations[i]);
                        var association = new Common.Models.Association(internalKeyParts.entityKey, internalKeyParts.entityType, internalKeyParts.entityGuid, associatedKeyParts.entityKey, associatedKeyParts.entityType, associatedKeyParts.entityGuid, this.contextId);
                        associationsRemoved.addAssociation(association);
                    }
                    delete this._data[internalKey];
                    this._size--;
                    this.forEach(function (self, associationKey) {
                        var associations = self._data[associationKey].associations;
                        if (!associations || associations.length == 0) {
                            // Clean up; we shouldn't have empty arrays
                            // in the associations collection; we know that
                            // if there is only 1 element in the associations array,
                            // then we should effectively 
                            delete self._data[associationKey];
                            self._size--;
                            return;
                        }
                        if (associations.length > 0) {
                            var index = associations.indexOf(internalKey);
                            if (index >= 0) {
                                associations.splice(index, 1);
                                if (associations.length == 0) {
                                    delete self._data[associationKey];
                                    self._size--;
                                }
                            }
                        }
                    });
                }
                return associationsRemoved;
            };
            /**
             * Removes the association ONLY between the two entities, and only
             * completely removes them if their respective association arrays
             * are empty as a result.
             *
             * @param {Common.Interfaces.IAssociable} fromEntity [description]
             * @param {Common.Interfaces.IAssociable} toEntity   [description]
             */
            AssociationCollection.prototype.disassociate = function (fromEntity, toEntity) {
                if (Common.Utilities.isNullOrUndefined(fromEntity) ||
                    Common.Utilities.isNullOrUndefined(toEntity))
                    throw new Error('AssociationCollection disassociate(): from or to entity is null or undefined');
                var fromAssociation = new Common.Models.Association(fromEntity.key, fromEntity.impaktDataType, fromEntity.guid, toEntity.key, toEntity.impaktDataType, toEntity.guid, this.contextId);
                var toAssociation = new Common.Models.Association(toEntity.key, toEntity.impaktDataType, toEntity.guid, fromEntity.key, fromEntity.impaktDataType, fromEntity.guid, this.contextId);
                var fromAssociations = this._data[fromAssociation.internalKey];
                if (Common.Utilities.isNotNullOrUndefined(fromAssociations)) {
                    if (fromAssociations.length > 1) {
                        var index = fromAssociations.indexOf(toAssociation.internalKey);
                        if (index >= 0) {
                            fromAssociations.splice(index, 1);
                        }
                    }
                    else {
                        delete this._data[fromAssociation.internalKey];
                        this._size--;
                    }
                }
                else {
                    throw new Error('AssociationCollection disassociate(): No from association found');
                }
                var toAssociations = this._data[toAssociation.internalKey];
                if (Common.Utilities.isNotNullOrUndefined(toAssociations)) {
                    if (toAssociations.length > 1) {
                        var index = toAssociations.indexOf(fromAssociation.internalKey);
                        if (index >= 0) {
                            toAssociations.splice(index, 1);
                        }
                    }
                    else {
                        delete this._data[toAssociation.internalKey];
                        this._size--;
                    }
                }
                else {
                    throw new Error('AssociationCollection disassociate(): No to association found');
                }
            };
            /**
             * Returns whether the given guid exists
             * @param  {string}  guid the guid to check
             * @return {boolean}      true if it exists, otherwise false
             */
            AssociationCollection.prototype.exists = function (internalKey) {
                return Common.Utilities.isNotNullOrUndefined(this._data[internalKey]);
            };
            /**
             * Returns whether there is an existing association between the given
             * 'from' internalKey, 'to' the given internal key
             * @param  {string}  fromInternalKey [description]
             * @param  {string}  toInternalKey   [description]
             * @return {boolean}                 [description]
             */
            AssociationCollection.prototype.associationExists = function (fromInternalKey, toInternalKey) {
                if (this.exists(fromInternalKey)) {
                    var associations = this.getByInternalKey(fromInternalKey);
                    return associations.indexOf(toInternalKey) >= 0;
                }
                else {
                    return false;
                }
            };
            /**
             * Replaces guid1, if found, with guid2
             * @param  {string} guid1 guid to be replaced
             * @param  {string} guid2 guid to replace with
             */
            AssociationCollection.prototype.replace = function (guid1, guid2) {
                // TODO @theBull
            };
            /**
             * Iterates over each element in the array
             * @param {Function} iterator the iterator function to call per element
             */
            AssociationCollection.prototype.forEach = function (iterator) {
                // TODO @theBull
                for (var internalKey in this._data) {
                    iterator(this, internalKey);
                }
            };
            AssociationCollection.prototype.toArray = function (toJson) {
                toJson = toJson === true;
                var array = [];
                for (var fromInternalKey in this._data) {
                    var fromParts = Common.Models.Association.parse(fromInternalKey);
                    var associations = this._data[fromInternalKey];
                    for (var i = 0; i < associations.length; i++) {
                        var toInternalKey = associations[i];
                        var toParts = Common.Models.Association.parse(toInternalKey);
                        var association = new Common.Models.Association(fromParts.entityKey, fromParts.entityType, fromParts.entityGuid, toParts.entityKey, toParts.entityType, toParts.entityGuid, this.contextId);
                        if (toJson) {
                            array.push(association.toJson());
                        }
                        else {
                            array.push(association);
                        }
                    }
                }
                return array;
            };
            AssociationCollection.prototype.toJson = function () {
                return this.toArray(true);
            };
            AssociationCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                // iterate over array of associations
                for (var i = 0; i < json.length; i++) {
                    var rawAssociation = json[i];
                    if (Common.Utilities.isNullOrUndefined(rawAssociation)) {
                        throw new Error('AssociationCollection fromJson(): an association result\
						is null or undefined');
                    }
                    if (Common.Utilities.isNullOrUndefined(rawAssociation.data)) {
                        throw new Error('AssociationCollection fromJson(): the data property of\
						an association result is null or undefined');
                    }
                    var association = new Common.Models.Association(rawAssociation.fromKey, rawAssociation.fromType, rawAssociation.data.fromGuid, rawAssociation.toKey, rawAssociation.toType, rawAssociation.data.toGuid, rawAssociation.contextID);
                    this.addAssociation(association);
                }
            };
            AssociationCollection.prototype.getInternalKeys = function () {
                var internalKeyArray = [];
                for (var internalKey in this._data) {
                    internalKeyArray.push(internalKey);
                }
                return internalKeyArray;
            };
            return AssociationCollection;
        })(Common.Models.Modifiable);
        Models.AssociationCollection = AssociationCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        /**
         * Associates an element with one or more other elements
         * by guid.
         */
        var Association = (function (_super) {
            __extends(Association, _super);
            function Association(fromKey, fromType, fromGuid, toKey, toType, toGuid, contextId) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.fromKey = fromKey;
                this.fromType = fromType;
                this.fromGuid = fromGuid;
                this.toKey = toKey;
                this.toType = toType;
                this.toGuid = toGuid;
                this.data = {
                    guid: this.guid,
                    fromGuid: this.fromGuid,
                    toGuid: this.toGuid
                };
                this.version = 1;
                this.contextId = contextId;
                this.internalKey = Common.Models.Association.buildKey(this);
                this.associationType = Common.Enums.AssociationTypes.Peer;
            }
            Association.buildKey = function (association) {
                return [association.fromType, '|', association.fromKey, '|', association.fromGuid].join('');
            };
            Association.parse = function (internalKey) {
                if (Common.Utilities.isNullOrUndefined(internalKey))
                    throw new Error('Association parse(): internalKey is null or undefined');
                var parts = internalKey.split('|');
                if (parts.length <= 0)
                    throw new Error('Association parse(): internalKey is invalid; missing "|" separator');
                if (parts.length != Common.Models.Association.KEY_PART_LENGTH)
                    throw new Error('Association parse(): internalKey is invalid; invalid number of parts');
                // assume by this point we have an array of 3 parts
                // part 1: EntityType
                // part 2: EntityKey (fromKey)
                // part 3: Entity guid (client-generated for quick lookup)
                // - get the entity type
                // - ensure it exists in the ImpaktDataTypes enum
                if (Common.Utilities.isNullOrUndefined(parts[0])) {
                    throw new Error('Association parse(): internalKey is invalid; entityType is null or undefined');
                }
                var entityType = parseInt(parts[0]);
                if (Common.Utilities.isNullOrUndefined(Common.Enums.ImpaktDataTypes[entityType])) {
                    throw new Error('Association parse(): internalKey is invalid; entityType is not valid ImpaktDataType');
                }
                // - get the entity key
                // - ensure it is a valid key
                if (Common.Utilities.isNullOrUndefined(parts[1]) || parseInt(parts[1]) <= 0) {
                    throw new Error('Association parse(): internalKey is invalid; entityKey is invalid');
                }
                var entityKey = parseInt(parts[1]);
                // - get the entity guid
                if (Common.Utilities.isNullOrUndefined(parts[2])) {
                    throw new Error('Association parse(): internalKey is invalid; entity guid is null or undefined');
                }
                var entityGuid = parts[2];
                return new Common.Models.AssociationParts(entityType, entityKey, entityGuid);
            };
            Association.prototype.toJson = function () {
                return {
                    fromKey: this.fromKey,
                    fromType: this.fromType,
                    toKey: this.toKey,
                    toType: this.toType,
                    contextID: this.contextId + '',
                    data: this.data,
                    version: this.version,
                    associationType: this.associationType
                };
            };
            Association.prototype.fromJson = function (json) {
                if (!json)
                    return;
                if (json.data) {
                    this.guid = json.data.guid;
                    this.fromGuid = json.data.fromGuid;
                    this.toGuid = json.data.toGuid;
                }
                else {
                    throw new Error('Association fromJson(): data is null or undefined');
                }
                this.fromKey = json.fromKey;
                this.fromType = json.fromType;
                this.toKey = json.toKey;
                this.toType = json.toType;
                this.contextId = json.contextID;
                this.data = json.data;
                this.associationType = json.associationType;
                this.version = json.version;
            };
            Association.KEY_PART_LENGTH = 3;
            return Association;
        })(Common.Models.Modifiable);
        Models.Association = Association;
        var AssociationParts = (function () {
            function AssociationParts(entityType, entityKey, guid) {
                this.entityType = entityType;
                this.entityKey = entityKey;
                this.entityGuid = guid;
            }
            return AssociationParts;
        })();
        Models.AssociationParts = AssociationParts;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var AssociationResults = (function () {
            function AssociationResults() {
                this.playbooks = new Common.Models.PlaybookModelCollection(Team.Enums.UnitTypes.Mixed);
                this.scenarios = new Common.Models.ScenarioCollection(Team.Enums.UnitTypes.Mixed);
                this.plays = new Common.Models.PlayCollection(Team.Enums.UnitTypes.Mixed);
                this.formations = new Common.Models.FormationCollection(Team.Enums.UnitTypes.Mixed);
                this.personnel = new Team.Models.PersonnelCollection(Team.Enums.UnitTypes.Mixed);
                this.assignmentGroups = new Common.Models.AssignmentGroupCollection(Team.Enums.UnitTypes.Mixed);
                this.leagues = new League.Models.LeagueModelCollection();
                this.conferences = new League.Models.ConferenceCollection();
                this.divisions = new League.Models.DivisionCollection();
                this.locations = new League.Models.LocationCollection();
                this.teams = new Team.Models.TeamModelCollection();
                this.seasons = new Season.Models.SeasonModelCollection();
                this.games = new Season.Models.GameCollection();
            }
            AssociationResults.prototype.count = function () {
                var count = 0;
                count += this.playbooks.size();
                count += this.scenarios.size();
                count += this.plays.size();
                count += this.formations.size();
                count += this.personnel.size();
                count += this.assignmentGroups.size();
                count += this.leagues.size();
                count += this.conferences.size();
                count += this.divisions.size();
                count += this.locations.size();
                count += this.teams.size();
                count += this.seasons.size();
                count += this.games.size();
                return count;
            };
            AssociationResults.prototype.hasAssociations = function () {
                return this.count() > 0;
            };
            AssociationResults.prototype.isEmpty = function () {
                return this.count() == 0;
            };
            AssociationResults.prototype.getPopulatedAssociationKeys = function () {
                var populated = [];
                if (this.playbooks.hasElements())
                    populated.push('playbooks');
                if (this.scenarios.hasElements())
                    populated.push('scenarios');
                if (this.plays.hasElements())
                    populated.push('plays');
                if (this.formations.hasElements())
                    populated.push('formations');
                if (this.personnel.hasElements())
                    populated.push('personnel');
                if (this.assignmentGroups.hasElements())
                    populated.push('assignmentGroups');
                if (this.leagues.hasElements())
                    populated.push('leagues');
                if (this.conferences.hasElements())
                    populated.push('conferences');
                if (this.divisions.hasElements())
                    populated.push('divisions');
                if (this.locations.hasElements())
                    populated.push('locations');
                if (this.teams.hasElements())
                    populated.push('teams');
                if (this.seasons.hasElements())
                    populated.push('seasons');
                if (this.games.hasElements())
                    populated.push('games');
                return populated;
            };
            return AssociationResults;
        })();
        Models.AssociationResults = AssociationResults;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Notification = (function (_super) {
            __extends(Notification, _super);
            function Notification(message, type) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.message = message;
                this.type = type;
            }
            /**
             * Updates this notification with the given message and type
             * @param  {string}                         updatedMessage New message to display
             * @param  {Common.Models.NotificationType} updatedType    New type to display as
             * @return {Common.Models.Notification}                    This updated notification
             */
            Notification.prototype.update = function (updatedMessage, updatedType) {
                this.message = updatedMessage;
                this.type = updatedType;
                return this;
            };
            /**
             * Shorthand to update this notification as successful
             * @param  {string}                     message The updated message to display
             * @return {Common.Models.Notification}         This updated success notification
             */
            Notification.prototype.success = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return this.update(this._concat(args), Common.Models.NotificationType.Success);
            };
            /**
             * Shorthand to update this notification as an error
             * @param  {string}                     message The updated error message to display
             * @return {Common.Models.Notification}         This updated error notification
             */
            Notification.prototype.error = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return this.update(this._concat(args), Common.Models.NotificationType.Error);
            };
            /**
             * Shorthand to update this notification as a warning
             * @param  {string}                     message The updated warning message to display
             * @return {Common.Models.Notification}         This updated warning notification
             */
            Notification.prototype.warning = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return this.update(this._concat(args), Common.Models.NotificationType.Warning);
            };
            /**
             * Shorthand to update this notification as an info notification
             * @param  {string}                     message The updated info message to display
             * @return {Common.Models.Notification}         This updated info notification
             */
            Notification.prototype.info = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return this.update(this._concat(args), Common.Models.NotificationType.Info);
            };
            /**
             * Shorthand to update this notification as pending
             * @param  {string}                     message The updated pending message to display
             * @return {Common.Models.Notification}         This updated pending notification
             */
            Notification.prototype.pending = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return this.update(this._concat(args), Common.Models.NotificationType.Pending);
            };
            Notification.prototype._concat = function (args) {
                return !args || !args.length || args.length <= 0 ? '' : args.join('');
            };
            return Notification;
        })(Common.Models.Modifiable);
        Models.Notification = Notification;
        (function (NotificationType) {
            NotificationType[NotificationType["None"] = 0] = "None";
            NotificationType[NotificationType["Success"] = 1] = "Success";
            NotificationType[NotificationType["Error"] = 2] = "Error";
            NotificationType[NotificationType["Warning"] = 3] = "Warning";
            NotificationType[NotificationType["Info"] = 4] = "Info";
            NotificationType[NotificationType["Pending"] = 5] = "Pending";
        })(Models.NotificationType || (Models.NotificationType = {}));
        var NotificationType = Models.NotificationType;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var NotificationCollection = (function (_super) {
            __extends(NotificationCollection, _super);
            function NotificationCollection() {
                _super.call(this);
            }
            return NotificationCollection;
        })(Common.Models.Collection);
        Models.NotificationCollection = NotificationCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Icons;
    (function (Icons) {
        var Glyphicon = (function () {
            function Glyphicon(icon) {
                this.prefix = 'glyphicon glyphicon-';
                this.icon = 'asterisk';
                this.icon = icon || this.icon;
            }
            Object.defineProperty(Glyphicon.prototype, "name", {
                get: function () {
                    return this.prefix + this.icon;
                },
                set: function (n) {
                    this.name = n;
                },
                enumerable: true,
                configurable: true
            });
            return Glyphicon;
        })();
        Icons.Glyphicon = Glyphicon;
    })(Icons = Common.Icons || (Common.Icons = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Assignment = (function (_super) {
            __extends(Assignment, _super);
            function Assignment(unitType) {
                _super.call(this, Common.Enums.ImpaktDataTypes.Assignment);
                _super.prototype.setContext.call(this, this);
                this.unitType = unitType;
                this.routes = new Common.Models.RouteCollection();
                this.routeArray = [];
                this.positionIndex = -1;
                this.setType = Common.Enums.SetTypes.Assignment;
                var self = this;
                this.routes.onModified(function () {
                    self.setModified(true);
                });
            }
            Assignment.prototype.toJson = function () {
                return $.extend({
                    routes: this.routes.toJson(),
                    positionIndex: this.positionIndex,
                    unitType: this.unitType
                }, _super.prototype.toJson.call(this));
            };
            Assignment.prototype.fromJson = function (json) {
                if (!json)
                    return;
                // NOTE:
                // Route models rely on the presence of a field
                // object in order to be constructed ( :-/ )
                // for now, avoid serializing
                this.routeArray = json.routes;
                this.positionIndex = json.positionIndex;
                this.unitType = json.unitType;
                _super.prototype.fromJson.call(this, json);
            };
            Assignment.prototype.copy = function (newAssignment) {
                var copyAssignment = newAssignment || new Common.Models.Assignment(this.unitType);
                var copied = _super.prototype.copy.call(this, copyAssignment, this);
                // explicitly set the routeArray field here since it's not part
                // of this object's toJson() result
                copied.routeArray = this.routeArray;
                return copied;
            };
            Assignment.prototype.remove = function () {
                this.routes.removeAll();
            };
            Assignment.prototype.setContext = function (context) {
                this.routes.forEach(function (route, index) {
                    route.setContext(context);
                });
            };
            Assignment.prototype.draw = function () {
                this.routes.forEach(function (route, index) {
                    route.draw();
                });
            };
            Assignment.prototype.addRoute = function (route) {
                if (Common.Utilities.isNullOrUndefined(route))
                    return;
                this.routes.add(route);
                this.routeArray = this.routes.toJson();
            };
            Assignment.prototype.setRoutes = function (player, renderType) {
                // intiialize the routeArray json for transferrence between
                // different rendering types for editor and preview modes
                if (!this.hasRouteArray() && this.routes.isEmpty())
                    // no route data! skip ahead...
                    return;
                if (this.routes.hasElements()) {
                    // we have routes but no generic route json; we need to
                    // convert the routes into json so that we can convert
                    // the routes between preview/editor/etc. modes.
                    this.routeArray = this.routes.toJson();
                }
                var routesToAdd = [];
                for (var i = 0; i < this.routeArray.length; i++) {
                    var routeJson = this.routeArray[i];
                    if (Common.Utilities.isNotNullOrUndefined(routeJson)) {
                        var route = null;
                        switch (renderType) {
                            case Common.Enums.RenderTypes.Preview:
                                route = new Playbook.Models.PreviewRoute();
                                break;
                            case Common.Enums.RenderTypes.Editor:
                                route = new Playbook.Models.EditorRoute();
                                break;
                        }
                        if (Common.Utilities.isNullOrUndefined(route))
                            throw new Error('Assignment setRoutes(): converted route is null or undefined');
                        // NOTE: must setPlayer() before calling fromJson ( >:/ )
                        // set the player context on the route
                        route.setPlayer(player);
                        // convert json into respective type
                        route.fromJson(routeJson);
                        routesToAdd.push(route);
                    }
                }
                if (routesToAdd.length > 0) {
                    this.routes.listen(false);
                    this.routes.addAll(routesToAdd);
                    this.routes.listen(true);
                }
            };
            Assignment.prototype.hasRouteArray = function () {
                return this.routeArray && this.routeArray.length > 0;
            };
            Assignment.prototype.updateRouteArray = function () {
                this.routeArray = this.routes.toJson();
            };
            Assignment.prototype.flip = function () {
                if (Common.Utilities.isNotNullOrUndefined(this.routes)) {
                    this.routes.forEach(function (route, index) {
                        if (Common.Utilities.isNotNullOrUndefined(route))
                            route.flip();
                    });
                    this.flipped = !this.flipped;
                }
            };
            return Assignment;
        })(Common.Models.AssociableEntity);
        Models.Assignment = Assignment;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var AssignmentGroup = (function (_super) {
            __extends(AssignmentGroup, _super);
            // at this point I'm expecting an object literal with data / count
            // properties, but not a valid AssignmentCollection; Essentially
            // this is to get around 
            function AssignmentGroup(unitType, count) {
                _super.call(this, Common.Enums.ImpaktDataTypes.AssignmentGroup);
                this.unitType = unitType;
                this.assignments = new Common.Models.Collection(11);
                if (count) {
                    for (var i = 0; i < count; i++) {
                        var assignment = new Common.Models.Assignment(this.unitType);
                        assignment.positionIndex = i;
                        this.assignments.add(assignment);
                    }
                }
                this.name = 'Untitled';
                this.key = -1;
                this.flipped = false;
                this.onModified(function () {
                    // TODO
                });
                this.associable = [
                    'playbooks',
                    'scenarios',
                    'plays',
                    'formations',
                    'personnel',
                    'assignmentGroups',
                    'teams'
                ];
            }
            AssignmentGroup.prototype.copy = function (newAssignmentGroup) {
                var copyAssignmentGroup = newAssignmentGroup || new Common.Models.AssignmentGroup(this.unitType);
                copyAssignmentGroup.assignments = new Common.Models.Collection();
                var copied = _super.prototype.copy.call(this, copyAssignmentGroup, this);
                this.assignments.forEach(function (assignment, index) {
                    if (Common.Utilities.isNotNullOrUndefined(assignment))
                        copied.assignments.add(assignment.copy());
                });
                return copied;
            };
            AssignmentGroup.prototype.toJson = function () {
                return $.extend({
                    unitType: this.unitType,
                    name: this.name,
                    assignments: this.assignments.toJson()
                }, _super.prototype.toJson.call(this));
            };
            AssignmentGroup.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.unitType = json.unitType;
                this.name = json.name;
                var assignments = json.assignments || [];
                for (var i = 0; i < assignments.length; i++) {
                    var rawAssignment = assignments[i];
                    if (Common.Utilities.isNullOrUndefined(rawAssignment))
                        continue;
                    rawAssignment.unitType = Common.Utilities.isNotNullOrUndefined(rawAssignment.unitType) &&
                        rawAssignment.unitType >= 0 ? rawAssignment.unitTpe : Team.Enums.UnitTypes.Other;
                    var assignmentModel = new Common.Models.Assignment(rawAssignment.unitType);
                    assignmentModel.fromJson(rawAssignment);
                    this.assignments.addAtIndex(assignmentModel, i);
                }
                _super.prototype.fromJson.call(this, json);
            };
            AssignmentGroup.prototype.getAssignmentByPositionIndex = function (index) {
                var result = null;
                if (this.assignments.hasElements()) {
                    result = this.assignments.filterFirst(function (assignment) {
                        return assignment.positionIndex == index;
                    });
                }
                return result;
            };
            AssignmentGroup.prototype.flip = function () {
                if (Common.Utilities.isNotNullOrUndefined(this.assignments)) {
                    this.assignments.forEach(function (assignment, index) {
                        if (Common.Utilities.isNotNullOrUndefined(assignment))
                            assignment.flip();
                    });
                    this.flipped = !this.flipped;
                }
            };
            return AssignmentGroup;
        })(Common.Models.AssociableEntity);
        Models.AssignmentGroup = AssignmentGroup;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var AssignmentGroupCollection = (function (_super) {
            __extends(AssignmentGroupCollection, _super);
            // at this point I'm expecting an object literal with data / count
            // properties, but not a valid AssignmentCollection; Essentially
            // this is to get around 
            function AssignmentGroupCollection(unitType) {
                _super.call(this);
                this.unitType = unitType;
                this.onModified(function () {
                    // TODO
                });
            }
            AssignmentGroupCollection.prototype.toJson = function () {
                return {
                    unitType: this.unitType,
                    assignmentCollections: _super.prototype.toJson.call(this)
                };
            };
            AssignmentGroupCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.unitType = json.unitType;
                var assignmentCollections = json.assignmentCollections || [];
                for (var i = 0; i < assignmentCollections.length; i++) {
                    var rawAssignmentCollection = assignmentCollections[i];
                    if (Common.Utilities.isNullOrUndefined(rawAssignmentCollection))
                        continue;
                    rawAssignmentCollection.unitType =
                        Common.Utilities.isNotNullOrUndefined(rawAssignmentCollection.unitType) &&
                            rawAssignmentCollection.unitType >= 0 ?
                            rawAssignmentCollection.unitTpe :
                            Team.Enums.UnitTypes.Other;
                    var assignmentCollection = new Common.Models.AssignmentGroup(rawAssignmentCollection.unitType);
                    assignmentCollection.fromJson(rawAssignmentCollection);
                    this.add(assignmentCollection);
                }
            };
            return AssignmentGroupCollection;
        })(Common.Models.ActionableCollection);
        Models.AssignmentGroupCollection = AssignmentGroupCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Formation = (function (_super) {
            __extends(Formation, _super);
            function Formation(unitType) {
                _super.call(this, Common.Enums.ImpaktDataTypes.Formation);
                this.unitType = unitType;
                this.parentRK = 1;
                this.editorType = Playbook.Enums.EditorTypes.Formation;
                this.name = name || 'New formation';
                this.placements = new Common.Models.PlacementCollection();
                this.png = null;
                //this.setDefault();
                var self = this;
                this.onModified(function () { });
                this.placements.onModified(function () {
                    self.setModified(true);
                });
                this.associable = [
                    'playbooks',
                    'scenarios',
                    'plays',
                    'formations',
                    'personnel',
                    'assignmentGroups',
                    'teams'
                ];
            }
            Formation.prototype.copy = function (newFormation) {
                var copyFormation = newFormation || new Common.Models.Formation(this.unitType);
                return _super.prototype.copy.call(this, copyFormation, this);
            };
            Formation.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    parentRK: this.parentRK,
                    unitType: this.unitType,
                    editorType: this.editorType,
                    placements: this.placements.toJson(),
                    png: this.png
                }, _super.prototype.toJson.call(this));
            };
            Formation.prototype.fromJson = function (json) {
                if (!json)
                    return;
                var self = this;
                this.parentRK = json.parentRK;
                this.editorType = Playbook.Enums.EditorTypes.Formation;
                this.name = json.name;
                this.unitType = json.unitType;
                this.placements.fromJson(json.placements);
                this.png = json.png;
                _super.prototype.fromJson.call(this, json);
                this.placements.onModified(function () {
                    self.setModified(true);
                });
                this.onModified(function () {
                });
            };
            Formation.prototype.setDefault = function (ball) {
                if (!ball)
                    throw new Error('Formation setDefault(): \
					Field reference is null or undefined');
                this.placements.removeAll();
                this.placements.addAll([
                    new Common.Models.Placement(0, -1, ball, 0),
                    new Common.Models.Placement(1.5, -1, ball, 1),
                    new Common.Models.Placement(-1.5, -1, ball, 2),
                    new Common.Models.Placement(-3, -1, ball, 3),
                    new Common.Models.Placement(3, -1, ball, 4),
                    new Common.Models.Placement(0, -2, ball, 5),
                    new Common.Models.Placement(-4, -2, ball, 6),
                    new Common.Models.Placement(-16, -1, ball, 7),
                    new Common.Models.Placement(14, -1, ball, 8),
                    new Common.Models.Placement(0, -4, ball, 9),
                    new Common.Models.Placement(0, -6, ball, 10)
                ]);
            };
            Formation.prototype.isValid = function () {
                // TODO add validation for 7 players on LOS
                return this.placements.size() == 11;
            };
            Formation.prototype.setPlacements = function (placements) {
                this.placements = placements;
                this.setModified(true);
            };
            Formation.prototype.setUnitType = function (unitType) {
                this.unitType = unitType;
                this.setModified(true);
            };
            Formation.prototype.flip = function () {
                if (Common.Utilities.isNotNullOrUndefined(this.placements)) {
                    this.placements.flip();
                    this.flipped = this.placements.flipped;
                }
            };
            return Formation;
        })(Common.Models.AssociableEntity);
        Models.Formation = Formation;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var FormationCollection = (function (_super) {
            __extends(FormationCollection, _super);
            // at this point I'm expecting an object literal with data / count
            // properties, but not a valid FormationCollection; Essentially
            // this is to get around 
            function FormationCollection(unitType) {
                _super.call(this);
                this.parentRK = -1;
                this.unitType = unitType;
                this.onModified(function () { });
            }
            FormationCollection.prototype.toJson = function () {
                return {
                    formations: _super.prototype.toJson.call(this),
                    unitType: this.unitType,
                    guid: this.guid
                };
            };
            FormationCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                // this.guid = json.guid || this.guid;
                // this.unitType = json.unitType || this.unitType;
                // this.parentRK = json.parentRK || this.parentRK
                var self = this;
                var formations = json || [];
                for (var i = 0; i < formations.length; i++) {
                    var rawFormation = formations[i];
                    if (Common.Utilities.isNullOrUndefined(rawFormation))
                        continue;
                    rawFormation.unitType = Common.Utilities.isNotNullOrUndefined(rawFormation.unitType) &&
                        rawFormation.unitType >= 0 ? rawFormation.unitType : Team.Enums.UnitTypes.Other;
                    var formationModel = new Common.Models.Formation(rawFormation.unitType);
                    formationModel.fromJson(rawFormation);
                    this.add(formationModel);
                }
                this.forEach(function (formation, index) {
                    formation.onModified(function () {
                        console.log('formation collection modified: formation');
                        self.setModified(true);
                    });
                });
            };
            return FormationCollection;
        })(Common.Models.ActionableCollection);
        Models.FormationCollection = FormationCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Play = (function (_super) {
            __extends(Play, _super);
            function Play(unitType) {
                _super.call(this, Common.Enums.ImpaktDataTypes.Play);
                this.field = null;
                this.name = 'New play';
                this.unitType = unitType;
                this.assignmentGroup = null;
                this.formation = null;
                this.personnel = null;
                this.png = null;
                this.contextmenuTemplateUrl = Common.Constants.PLAY_CONTEXTMENU_TEMPLATE_URL;
                this.playType = Playbook.Enums.PlayTypes.Unknown;
                this.flipped = false;
                this.associable = [
                    'playbooks',
                    'scenarios',
                    'plays',
                    'formations',
                    'personnel',
                    'assignmentGroups',
                    'teams'
                ];
            }
            Play.prototype.copy = function (newPlay) {
                newPlay.formation = this.formation && this.formation.copy();
                newPlay.personnel = this.personnel && this.personnel.copy();
                newPlay.assignmentGroup = this.assignmentGroup && this.assignmentGroup.copy();
                return _super.prototype.copy.call(this, newPlay, this);
            };
            Play.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    unitType: this.unitType,
                    png: this.png,
                    playType: this.playType
                }, _super.prototype.toJson.call(this));
            };
            Play.prototype.fromJson = function (json) {
                // TODO
                this.name = json.name;
                this.unitType = json.unitType;
                this.png = json.png;
                this.playType = json.playType || this.playType;
                _super.prototype.fromJson.call(this, json);
            };
            Play.prototype.setPlaybook = function (playbook) {
                // TODO @theBull - handle associations
                // TODO @theBull
                // - add playbook field?
                // - what happens when changing to playbooks of different unit types? 
                this.setModified(true);
            };
            Play.prototype.setFormation = function (formation) {
                if (Common.Utilities.isNotNullOrUndefined(formation)) {
                    if (formation.unitType != this.unitType) {
                    }
                }
                else {
                    this.setAssignmentGroup(null);
                    this.setPersonnel(null);
                }
                this.formation = formation;
                this.unitType = formation.unitType;
                this.setModified(true);
            };
            Play.prototype.setAssignmentGroup = function (assignmentGroup) {
                if (Common.Utilities.isNotNullOrUndefined(assignmentGroup)) {
                    if (assignmentGroup.unitType != this.unitType)
                        throw new Error('Play setAssignmentGroup(): Assignments unit type does not match play unit type');
                }
                else {
                }
                this.assignmentGroup = assignmentGroup;
                this.setModified(true);
            };
            Play.prototype.setPersonnel = function (personnel) {
                if (Common.Utilities.isNotNullOrUndefined(personnel)) {
                    if (personnel.unitType != this.unitType)
                        throw new Error('Play setPersonnel(): Cannot apply personnel with different unit type.');
                }
                else {
                }
                this.personnel = personnel;
                this.setModified(true);
            };
            Play.prototype.setUnitType = function (unitType) {
                this.isFieldSet(this.field);
                this.isBallSet(this.field.ball);
                if (unitType != this.unitType) {
                    this.unitType = unitType;
                    // 1. reset formation unit type
                    if (this.formation) {
                        this.formation.setUnitType(unitType);
                    }
                    // 2. reset default personnel
                    if (this.personnel && this.personnel.unitType != unitType) {
                        this.personnel.unitType = unitType;
                        this.personnel.setDefault();
                    }
                    // 3. clear assignments
                    if (this.assignmentGroup && this.assignmentGroup.unitType != this.unitType) {
                        this.assignmentGroup = null;
                    }
                    this.setModified(true);
                }
            };
            Play.prototype.hasAssignments = function () {
                return this.assignmentGroup && this.assignmentGroup.assignments.size() > 0;
            };
            Play.prototype.setDefault = function (field) {
                this.isFieldSet(field);
                this.field = field;
                // empty what's already there, if anything...
                if (!this.personnel)
                    this.personnel = new Team.Models.Personnel(this.unitType);
                if (!this.formation)
                    this.formation = new Common.Models.Formation(this.unitType);
                this.personnel.setDefault();
                this.formation.setDefault(this.field.ball);
                // assignments?
                // this.draw(field);
            };
            Play.prototype.getOpposingUnitType = function () {
                var opponentUnitType = Team.Enums.UnitTypes.Other;
                switch (this.unitType) {
                    case Team.Enums.UnitTypes.Offense:
                        opponentUnitType = Team.Enums.UnitTypes.Defense;
                        break;
                    case Team.Enums.UnitTypes.Defense:
                        opponentUnitType = Team.Enums.UnitTypes.Offense;
                        break;
                }
                return opponentUnitType;
            };
            Play.prototype.isFieldSet = function (field) {
                if (!field)
                    throw new Error('Play draw(): Field is null or undefined');
                return true;
            };
            Play.prototype.isBallSet = function (ball) {
                if (!ball)
                    throw new Error('Play draw(): Ball is null or undefined');
                return true;
            };
            Play.prototype.setField = function (field) {
                this.isFieldSet(field);
                this.isBallSet(field.ball);
                this.field = field;
            };
            Play.toPrimary = function (play) {
                if (play.playType == Playbook.Enums.PlayTypes.Primary)
                    return play;
                var newPlay = new Common.Models.PlayPrimary(play.unitType);
                newPlay.fromJson(play.toJson());
                newPlay.playType = Playbook.Enums.PlayTypes.Primary;
                newPlay.assignmentGroup = play.assignmentGroup;
                newPlay.formation = play.formation;
                newPlay.personnel = play.personnel;
                return newPlay;
            };
            Play.toOpponent = function (play) {
                if (play.playType == Playbook.Enums.PlayTypes.Opponent)
                    return play;
                var newPlay = new Common.Models.PlayOpponent(play.unitType);
                newPlay.fromJson(play.toJson());
                newPlay.playType = Playbook.Enums.PlayTypes.Opponent;
                newPlay.assignmentGroup = play.assignmentGroup;
                newPlay.formation = play.formation;
                newPlay.personnel = play.personnel;
                return newPlay;
            };
            Play.prototype.flip = function () {
                if (Common.Utilities.isNotNullOrUndefined(this.formation)) {
                    this.formation.flip();
                }
                if (Common.Utilities.isNotNullOrUndefined(this.assignmentGroup)) {
                }
                this.flipped = !this.flipped;
            };
            return Play;
        })(Common.Models.AssociableEntity);
        Models.Play = Play;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayPrimary = (function (_super) {
            __extends(PlayPrimary, _super);
            function PlayPrimary(unitType) {
                _super.call(this, unitType);
                this.playType = Playbook.Enums.PlayTypes.Primary;
            }
            PlayPrimary.prototype.copy = function (newPlay) {
                var copyPlay = newPlay || new Common.Models.PlayPrimary(this.unitType);
                return _super.prototype.copy.call(this, copyPlay);
            };
            PlayPrimary.prototype.draw = function (field) {
                _super.prototype.setField.call(this, field);
                this.field.clearPrimaryPlayers();
                var self = this;
                // set defaults, in case no assignments / personnel were assigned
                if (!this.personnel) {
                    this.personnel = new Team.Models.Personnel(this.unitType);
                }
                if (!this.personnel.positions) {
                    this.personnel.setDefault();
                }
                if (!this.assignmentGroup) {
                    this.assignmentGroup = new Common.Models.AssignmentGroup(this.unitType);
                }
                if (!this.formation) {
                    this.formation = new Common.Models.Formation(this.unitType);
                }
                if (!this.formation.placements || this.formation.placements.isEmpty()) {
                    this.formation.setDefault(this.field.ball);
                }
                this.field.primaryPlayers.listen(false);
                this.formation.placements.forEach(function (placement, index) {
                    var position = self.personnel.positions.getIndex(index);
                    var assignment = self.assignmentGroup.assignments.getIndex(index);
                    self.field.addPrimaryPlayer(placement, position, assignment);
                });
                this.field.primaryPlayers.listen(true);
                this.field.primaryPlayers.setModified(true);
            };
            return PlayPrimary;
        })(Common.Models.Play);
        Models.PlayPrimary = PlayPrimary;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayOpponent = (function (_super) {
            __extends(PlayOpponent, _super);
            function PlayOpponent(unitType) {
                _super.call(this, unitType);
                this.playType = Playbook.Enums.PlayTypes.Opponent;
            }
            PlayOpponent.prototype.copy = function (newPlay) {
                var copyPlay = newPlay || new Common.Models.PlayOpponent(this.unitType);
                return _super.prototype.copy.call(this, copyPlay);
            };
            PlayOpponent.prototype.draw = function (field) {
                _super.prototype.setField.call(this, field);
                this.field.clearOpponentPlayers();
                var self = this;
                // set defaults, in case no assignments / personnel were assigned
                if (!this.personnel) {
                    this.personnel = new Team.Models.Personnel(this.unitType);
                }
                if (!this.personnel.positions) {
                    this.personnel.setDefault();
                }
                if (!this.assignmentGroup) {
                    this.assignmentGroup = new Common.Models.AssignmentGroup(this.unitType);
                }
                if (!this.formation) {
                    this.formation = new Common.Models.Formation(this.unitType);
                }
                if (!this.formation.placements || this.formation.placements.isEmpty()) {
                    this.formation.setDefault(this.field.ball);
                }
                this.field.opponentPlayers.listen(false);
                this.formation.placements.forEach(function (placement, index) {
                    // placement.relative.rx *= -1;
                    // placement.relative.ry *= -1;
                    var position = self.personnel.positions.getIndex(index);
                    var assignment = self.assignmentGroup.assignments.getIndex(index);
                    self.field.addOpponentPlayer(placement, position, assignment);
                });
                // flip the formation and assignments
                if (Common.Utilities.isNotNullOrUndefined(this.field.opponentPlayers) && !this.flipped) {
                    this.field.opponentPlayers.forEach(function (player, index) {
                        if (Common.Utilities.isNotNullOrUndefined(player) && !player.flipped) {
                            player.flip();
                        }
                    });
                    this.flipped = !this.flipped;
                }
                this.field.opponentPlayers.listen(true);
                this.field.opponentPlayers.setModified(true);
            };
            return PlayOpponent;
        })(Common.Models.Play);
        Models.PlayOpponent = PlayOpponent;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayCollection = (function (_super) {
            __extends(PlayCollection, _super);
            function PlayCollection(unitType) {
                _super.call(this);
                this.unitType = unitType;
            }
            PlayCollection.prototype.toJson = function () {
                var self = this;
                return $.extend(_super.prototype.toJson.call(this), {
                    unitType: self.unitType
                });
            };
            PlayCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.unitType = json.unitType;
                var plays = json.plays;
                if (!plays)
                    plays = [];
                for (var i = 0; i < plays.length; i++) {
                    var obj = plays[i];
                    var rawPlay = obj.data.play;
                    if (Common.Utilities.isNullOrUndefined(rawPlay))
                        continue;
                    rawPlay.unitType = Common.Utilities.isNullOrUndefined(rawPlay.unitType) &&
                        rawPlay.unitType >= 0 ? rawPlay.unitType : Team.Enums.UnitTypes.Other;
                    rawPlay.key = obj.key;
                    // TODO
                    var playModel = new Common.Models.PlayPrimary(rawPlay.unitType);
                    playModel.fromJson(rawPlay);
                    this.add(playModel);
                }
            };
            return PlayCollection;
        })(Common.Models.ActionableCollection);
        Models.PlayCollection = PlayCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlaybookModel = (function (_super) {
            __extends(PlaybookModel, _super);
            function PlaybookModel(unitType) {
                _super.call(this, Common.Enums.ImpaktDataTypes.Playbook);
                this.name = 'Untitled';
                this.unitType = unitType;
                this.associable = [
                    'scenarios',
                    'plays',
                    'formations',
                    'assignmentGroups',
                    'teams',
                    'games'
                ];
            }
            PlaybookModel.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    unitType: this.unitType
                }, _super.prototype.toJson.call(this));
            };
            PlaybookModel.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                this.unitType = json.unitType;
                _super.prototype.fromJson.call(this, json);
            };
            return PlaybookModel;
        })(Common.Models.AssociableEntity);
        Models.PlaybookModel = PlaybookModel;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlaybookModelCollection = (function (_super) {
            __extends(PlaybookModelCollection, _super);
            function PlaybookModelCollection(unitType) {
                _super.call(this);
                this.unitType = unitType;
            }
            PlaybookModelCollection.prototype.toJson = function () {
                return {
                    guid: this.guid,
                    playbooks: _super.prototype.toJson.call(this),
                    unitType: this.unitType
                };
            };
            PlaybookModelCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid || this.guid;
                this.unitType = json.unitType;
                var playbooks = json.playbooks || [];
                for (var i = 0; i < playbooks.length; i++) {
                    var rawPlaybook = playbooks[i];
                    if (Common.Utilities.isNullOrUndefined(rawPlaybook))
                        continue;
                    rawPlaybook.unitType = Common.Utilities.isNotNullOrUndefined(rawPlaybook.unitType) &&
                        rawPlaybook.unitType >= 0 ? rawPlaybook.unitType : Team.Enums.UnitTypes.Mixed;
                    // Allow mixed unit types to be added to the playbookmodel collection;
                    // a variety of unit types may exist in a playbook model collection
                    if (rawPlaybook.unitType != this.unitType) {
                        this.unitType = Team.Enums.UnitTypes.Mixed;
                    }
                    var playbookModel = new Common.Models.PlaybookModel(rawPlaybook.unitType);
                    playbookModel.fromJson(rawPlaybook);
                    this.add(playbookModel);
                }
            };
            return PlaybookModelCollection;
        })(Common.Models.ActionableCollection);
        Models.PlaybookModelCollection = PlaybookModelCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Scenario = (function (_super) {
            __extends(Scenario, _super);
            function Scenario() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Scenario);
                this.playPrimary = new Common.Models.PlayPrimary(Team.Enums.UnitTypes.Other);
                this.playPrimaryGuid = this.playPrimary.guid;
                this.playOpponent = new Common.Models.PlayOpponent(Team.Enums.UnitTypes.Other);
                this.playOpponentGuid = this.playOpponent.guid;
                this.unitType = this.playPrimary.unitType;
                this.editorType = Playbook.Enums.EditorTypes.Play;
                this.associable = [
                    'playbooks',
                    'scenarios',
                    'plays',
                    'formations',
                    'personnel',
                    'assignmentGroups',
                    'teams'
                ];
            }
            Scenario.prototype.copy = function (newScenario) {
                var copyScenario = newScenario || new Common.Models.Scenario();
                if (Common.Utilities.isNotNullOrUndefined(this.playPrimary))
                    copyScenario.playPrimary = this.playPrimary.copy();
                if (Common.Utilities.isNotNullOrUndefined(this.playOpponent))
                    copyScenario.playOpponent = this.playOpponent.copy();
                return _super.prototype.copy.call(this, copyScenario, this);
            };
            Scenario.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    png: this.png,
                    unitType: this.unitType,
                    editorType: this.editorType,
                    playPrimaryGuid: this.playPrimaryGuid,
                    playOpponentGuid: this.playOpponentGuid
                }, _super.prototype.toJson.call(this));
            };
            Scenario.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                this.unitType = json.unitType;
                this.png = json.png;
                this.editorType = json.editorType;
                this.playPrimaryGuid = json.playPrimaryGuid;
                this.playOpponentGuid = json.playOpponentGuid;
                _super.prototype.fromJson.call(this, json);
            };
            Scenario.prototype.setPlayPrimary = function (play) {
                if (Common.Utilities.isNullOrUndefined(play)) {
                    this.playPrimary = null;
                    return;
                }
                // ensure the play passed in is of type primary
                this.playPrimary = Common.Models.Play.toPrimary(play);
                this.playPrimaryGuid = this.playPrimary.guid;
                this.unitType = this.playPrimary.unitType;
                this.setModified(true);
            };
            Scenario.prototype.setPlayOpponent = function (play) {
                if (Common.Utilities.isNullOrUndefined(play)) {
                    this.playOpponent = null;
                    return;
                }
                // ensure the play passed in is of type Opponent
                this.playOpponent = Common.Models.Play.toOpponent(play);
                this.playOpponentGuid = this.playOpponent.guid;
                this.setModified(true);
            };
            Scenario.prototype.clear = function () {
                this.playPrimary = null;
                this.playPrimaryGuid = null;
                this.playOpponent = null;
                this.playOpponentGuid = null;
            };
            Scenario.prototype.draw = function (field) {
                if (Common.Utilities.isNotNullOrUndefined(this.playPrimary))
                    this.playPrimary.draw(field);
                if (Common.Utilities.isNotNullOrUndefined(this.playOpponent))
                    this.playOpponent.draw(field);
            };
            return Scenario;
        })(Common.Models.AssociableEntity);
        Models.Scenario = Scenario;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var ScenarioCollection = (function (_super) {
            __extends(ScenarioCollection, _super);
            function ScenarioCollection(unitType) {
                _super.call(this);
                this.unitType = unitType;
            }
            ScenarioCollection.prototype.toJson = function () {
                var self = this;
                return $.extend(_super.prototype.toJson.call(this), {
                    unitType: self.unitType
                });
            };
            ScenarioCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.unitType = json.unitType;
                if (!json.scenarios)
                    json.scenarios = [];
                for (var i = 0; i < json.scenarios.length; i++) {
                    var obj = json.scenarios[i];
                    var rawScenario = obj.data.scenario;
                    if (Common.Utilities.isNullOrUndefined(rawScenario))
                        continue;
                    rawScenario.unitType = Common.Utilities.isNullOrUndefined(rawScenario.unitType) &&
                        rawScenario.unitType >= 0 ? rawScenario.unitType : Team.Enums.UnitTypes.Other;
                    rawScenario.key = obj.key;
                    // TODO
                    var scenarioModel = new Common.Models.Scenario();
                    scenarioModel.fromJson(rawScenario);
                    this.add(scenarioModel);
                }
            };
            return ScenarioCollection;
        })(Common.Models.ActionableCollection);
        Models.ScenarioCollection = ScenarioCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Tab = (function (_super) {
            __extends(Tab, _super);
            function Tab(scenario) {
                _super.call(this);
                this.title = 'Untitled';
                this.active = true;
                _super.prototype.setContext.call(this, this);
                if (Common.Utilities.isNullOrUndefined(scenario))
                    throw new Error('Tab constructor(): scenario is null or undefined');
                this.scenario = scenario;
                switch (this.scenario.editorType) {
                    case Playbook.Enums.EditorTypes.Formation:
                        if (Common.Utilities.isNullOrUndefined(this.scenario.playPrimary) ||
                            Common.Utilities.isNullOrUndefined(this.scenario.playPrimary.formation))
                            throw new Error('Tab constructor(): scenario formation is null or undefined');
                        this.title = this.scenario.playPrimary.formation.name;
                        break;
                    case Playbook.Enums.EditorTypes.Play:
                        if (Common.Utilities.isNullOrUndefined(this.scenario.playPrimary))
                            throw new Error('Tab constructor(): scenario primary play is null or undefined');
                        this.title = this.scenario.playPrimary.name;
                        break;
                    case Playbook.Enums.EditorTypes.Scenario:
                        this.title = this.scenario.name;
                        break;
                }
                this._closeCallbacks = [function () {
                        console.log('tab closed', this.guid);
                    }];
            }
            Tab.prototype.onclose = function (callback) {
                this._closeCallbacks.push(callback);
            };
            Tab.prototype.close = function () {
                for (var i = 0; i < this._closeCallbacks.length; i++) {
                    this._closeCallbacks[i]();
                }
            };
            return Tab;
        })(Common.Models.Modifiable);
        Models.Tab = Tab;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var TabCollection = (function (_super) {
            __extends(TabCollection, _super);
            function TabCollection() {
                _super.call(this);
            }
            TabCollection.prototype.getByPlayGuid = function (guid) {
                return this.filterFirst(function (tab, index) {
                    return tab.play.guid == guid;
                });
            };
            TabCollection.prototype.close = function (tab) {
                this.remove(tab.guid);
                tab.close();
            };
            return TabCollection;
        })(Common.Models.Collection);
        Models.TabCollection = TabCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Template = (function (_super) {
            __extends(Template, _super);
            function Template(name, url) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.name = name;
                this.url = url;
                this.data = {};
            }
            return Template;
        })(Common.Models.Modifiable);
        Models.Template = Template;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var TemplateCollection = (function (_super) {
            __extends(TemplateCollection, _super);
            function TemplateCollection(name) {
                _super.call(this);
                this.name = name;
            }
            return TemplateCollection;
        })(Common.Models.Collection);
        Models.TemplateCollection = TemplateCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
var Common;
(function (Common) {
    var Input;
    (function (Input) {
        var KeyboardInputListener = (function () {
            function KeyboardInputListener() {
            }
            // TODO
            KeyboardInputListener.prototype.shiftPressed = function () {
            };
            KeyboardInputListener.prototype.ctrlPressed = function () {
            };
            KeyboardInputListener.prototype.altPressed = function () {
            };
            KeyboardInputListener.prototype.metaPressed = function () {
            };
            return KeyboardInputListener;
        })();
        Input.KeyboardInputListener = KeyboardInputListener;
        var MouseInputListener = (function () {
            function MouseInputListener() {
            }
            return MouseInputListener;
        })();
        Input.MouseInputListener = MouseInputListener;
        (function (Which) {
            Which[Which["LeftClick"] = 1] = "LeftClick";
            Which[Which["RightClick"] = 3] = "RightClick";
            Which[Which["Backspace"] = 8] = "Backspace";
            Which[Which["Enter"] = 13] = "Enter";
            Which[Which["Esc"] = 27] = "Esc";
            Which[Which["Left"] = 37] = "Left";
            Which[Which["Up"] = 38] = "Up";
            Which[Which["Right"] = 39] = "Right";
            Which[Which["Down"] = 40] = "Down";
            /**
             *
             * Uppercase (shift pressed)
             *
             */
            Which[Which["A"] = 65] = "A";
            Which[Which["B"] = 66] = "B";
            Which[Which["C"] = 67] = "C";
            Which[Which["D"] = 68] = "D";
            Which[Which["E"] = 69] = "E";
            Which[Which["F"] = 70] = "F";
            Which[Which["G"] = 71] = "G";
            Which[Which["H"] = 72] = "H";
            Which[Which["I"] = 73] = "I";
            Which[Which["J"] = 74] = "J";
            Which[Which["K"] = 75] = "K";
            Which[Which["L"] = 76] = "L";
            Which[Which["M"] = 77] = "M";
            Which[Which["N"] = 78] = "N";
            Which[Which["O"] = 79] = "O";
            Which[Which["P"] = 80] = "P";
            Which[Which["Q"] = 81] = "Q";
            Which[Which["R"] = 82] = "R";
            Which[Which["S"] = 83] = "S";
            Which[Which["T"] = 84] = "T";
            Which[Which["U"] = 85] = "U";
            Which[Which["V"] = 86] = "V";
            Which[Which["W"] = 87] = "W";
            Which[Which["X"] = 88] = "X";
            Which[Which["Y"] = 89] = "Y";
            Which[Which["Z"] = 90] = "Z";
            /**
             *
             * Lowercase (shift key not pressed)
             *
             */
            Which[Which["a"] = 97] = "a";
            Which[Which["b"] = 98] = "b";
            Which[Which["c"] = 99] = "c";
            Which[Which["d"] = 100] = "d";
            Which[Which["e"] = 101] = "e";
            Which[Which["f"] = 102] = "f";
            Which[Which["g"] = 103] = "g";
            Which[Which["h"] = 104] = "h";
            Which[Which["i"] = 105] = "i";
            Which[Which["j"] = 106] = "j";
            Which[Which["k"] = 107] = "k";
            Which[Which["l"] = 108] = "l";
            Which[Which["m"] = 109] = "m";
            Which[Which["n"] = 110] = "n";
            Which[Which["o"] = 111] = "o";
            Which[Which["p"] = 112] = "p";
            Which[Which["q"] = 113] = "q";
            Which[Which["r"] = 114] = "r";
            Which[Which["s"] = 115] = "s";
            Which[Which["t"] = 116] = "t";
            Which[Which["u"] = 117] = "u";
            Which[Which["v"] = 118] = "v";
            Which[Which["w"] = 119] = "w";
            Which[Which["x"] = 120] = "x";
            Which[Which["y"] = 121] = "y";
            Which[Which["z"] = 122] = "z";
        })(Input.Which || (Input.Which = {}));
        var Which = Input.Which;
    })(Input = Common.Input || (Common.Input = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var Listener = (function () {
            function Listener(context) {
                this.actions = {};
            }
            Listener.prototype.listen = function (actionId, fn) {
                if (!this.actions.hasOwnProperty[actionId])
                    this.actions[actionId] = [];
                this.actions[actionId].push(fn);
            };
            Listener.prototype.invoke = function (actionId, data, context) {
                if (!this.actions[actionId])
                    return;
                for (var i = 0; i < this.actions[actionId].length; i++) {
                    this.actions[actionId][i](data, context);
                }
            };
            return Listener;
        })();
        Models.Listener = Listener;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Canvas = (function (_super) {
            __extends(Canvas, _super);
            function Canvas(scenario, width, height) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                if (Common.Utilities.isNullOrUndefined(scenario))
                    throw new Error('EditorCanvas constructor(): scenario is null or undefined');
                this.scenario = scenario;
                /**
                 * Note that paper is created during the initialize() method;
                 * canvas is dependent on angular directive / dynamic HTML include
                 * of the canvas, before the $container/container properties are
                 * available; these containers are required by the paper, which
                 * implements a Raphael object, that requires a container HTML element.
                 */
                this.dimensions = new Common.Models.Dimensions();
                this.dimensions.setMinWidth(500);
                this.dimensions.setMinHeight(400);
                // TODO @theBull - look for performance improvements here
                // 
                // Maintains a window interval timer which checks every 1ms for
                // a change in container width; will fire a resize() if necessary
                this.widthChangeInterval = null;
                this.readyCallbacks = [];
                this.listener = new Common.Models.CanvasListener(this);
            }
            Canvas.prototype.clear = function () {
                this.paper.clear();
                this.scenario.clear();
                this.clearListeners();
                this.setModified(true);
            };
            /**
             * Converts this canvas's SVG graphics element into a data-URI
             * which can be used in an <img/> src attribute to render the image
             * as a PNG. Allows for retrieval and storage of the image as well.
             *
             * 3/9/2016: https://css-tricks.com/data-uris/
             * @return {string} [description]
             */
            Canvas.prototype.exportToPng = function () {
                if (!this.$container) {
                    throw new Error('Canvas exportToPng(): Cannot export to png; \
                SVG parent $container is null or undefined');
                }
                var svgElement = this.$container.find('svg')[0];
                if (!svgElement) {
                    throw new Error('Canvas exportToPng(): Cannot export to png; \
                Could not find SVG element inside of canvas $container');
                }
                return Common.Utilities.exportToPng(this, svgElement);
            };
            Canvas.prototype.getSvg = function () {
                var $svg = $('svg');
                var serializer = new XMLSerializer();
                var svg_blob = serializer.serializeToString($svg[0]);
                return svg_blob;
            };
            Canvas.prototype.updateScenario = function (scenario, redraw) {
                if (Common.Utilities.isNullOrUndefined(scenario))
                    return;
                this.paper.updateScenario(scenario);
                this.scenario = scenario;
                this.setModified(true);
            };
            Canvas.prototype.refresh = function () {
                if (Common.Utilities.isNullOrUndefined(this.paper))
                    return;
                this.paper.draw();
            };
            Canvas.prototype.onready = function (callback) {
                if (this.readyCallbacks && this.readyCallbacks.length > 1000)
                    throw new Error('Canvas onready(): callback not added; max ready callback limit exceeded');
                this.readyCallbacks.push(callback);
            };
            Canvas.prototype._ready = function () {
                if (Common.Utilities.isNullOrUndefined(this.readyCallbacks))
                    return;
                for (var i = 0; i < this.readyCallbacks.length; i++) {
                    this.readyCallbacks[i]();
                }
                this.clearListeners();
            };
            Canvas.prototype.clearListeners = function () {
                this.readyCallbacks = [];
            };
            Canvas.prototype.resize = function () {
                var self = this;
                this.dimensions.width = this.$container.width();
                this.dimensions.height = this.$container.height();
                this.paper.resize();
                if (this.scrollable) {
                    this.scrollable.initialize(this.$container, this.paper);
                    this.scrollable.onready(function (content) {
                        self.scrollable.scrollToPercentY(0.5);
                    });
                }
            };
            Canvas.prototype.setScrollable = function (scrollable) {
                this.scrollable = scrollable;
            };
            return Canvas;
        })(Common.Models.Modifiable);
        Models.Canvas = Canvas;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Drawing;
    (function (Drawing) {
        var Utilities = (function () {
            function Utilities(canvas, grid) {
                this.grid = grid;
                this.canvas = canvas;
                this.Raphael = this.Raphael || new Raphael(this.canvas.container, this.grid.dimensions.width, this.grid.dimensions.height // * 2
                );
            }
            Utilities.prototype.clear = function () {
                this.Raphael.clear();
            };
            Utilities.prototype.setAttribute = function (attribute, value) {
                this.Raphael.canvas.setAttribute(attribute, value);
            };
            Utilities.prototype.setViewBox = function (x, y, width, height, fit) {
                this.Raphael.setViewBox(x, y, width, height, fit);
            };
            Utilities.prototype.alignToGrid = function (x, y, absolute) {
                var coords = new Common.Models.Coordinates(x, y);
                return !absolute ?
                    this.grid.getAbsoluteFromCoordinates(coords.x, coords.y) :
                    coords;
            };
            Utilities.prototype.path = function (path) {
                return this.Raphael.path(path);
            };
            Utilities.prototype.rect = function (x, y, width, height, absolute, offsetX, offsetY) {
                var pixels = this.alignToGrid(x, y, absolute);
                offsetX = offsetX || 0;
                offsetY = offsetY || 0;
                var rect = this.Raphael.rect(pixels.x + offsetX, pixels.y + offsetY, width, height).attr({
                    x: pixels.x + offsetX,
                    y: pixels.y + offsetY
                });
                return rect;
            };
            Utilities.prototype.rhombus = function (x, y, width, height, absolute, offsetX, offsetY) {
                var rect = this.rect(x, y, width, height, absolute, offsetX, offsetY);
                rect.transform('r-45');
                return rect;
            };
            Utilities.prototype.ellipse = function (x, y, width, height, absolute, offsetX, offsetY) {
                var pixels = this.alignToGrid(x, y, absolute);
                offsetX = offsetX || 0;
                offsetY = offsetY || 0;
                var ellipse = this.Raphael.ellipse(pixels.x + offsetX, pixels.y + offsetY, width, height).attr({
                    cx: pixels.x + offsetX,
                    cy: pixels.y + offsetY
                });
                return ellipse;
            };
            Utilities.prototype.circle = function (x, y, radius, absolute, offsetX, offsetY) {
                var pixels = this.alignToGrid(x, y, absolute);
                offsetX = offsetX || 0;
                offsetY = offsetY || 0;
                var circle = this.Raphael.circle(pixels.x + offsetX, pixels.y + offsetY, radius).attr({
                    cx: pixels.x + offsetX,
                    cy: pixels.y + offsetY
                });
                return circle;
            };
            Utilities.prototype.triangle = function (x, y, height, absolute, offsetX, offsetY) {
                var pixels = this.alignToGrid(x, y, absolute);
                offsetX = offsetX || 0;
                offsetY = offsetY || 0;
                // get height of center
                var centerHeight = height / 2;
                // get side length
                var sideLength = (2 * height) / Math.sqrt(3);
                // create path string
                var pathString = Common.Drawing.Utilities.getClosedPathString(true, [
                    ((pixels.x + offsetX) - (sideLength / 2)), ((pixels.y + offsetY) + centerHeight),
                    (pixels.x + offsetX), ((pixels.y + offsetY) - centerHeight),
                    ((pixels.x + offsetX) + (sideLength / 2)), ((pixels.y + offsetY) + centerHeight)
                ]);
                var raphael = this.Raphael.path(pathString);
                raphael.data('element-type', 'triangle');
                return raphael;
            };
            Utilities.prototype.text = function (x, y, text, absolute, offsetX, offsetY) {
                var pixels = this.alignToGrid(x, y, absolute);
                offsetX = offsetX || 0;
                offsetY = offsetY || 0;
                return this.Raphael.text(pixels.x + offsetX, pixels.y + offsetY, text).attr({
                    'x': pixels.x + offsetX,
                    'y': pixels.y + offsetY
                });
            };
            Utilities.prototype.print = function (x, y, text, font, size, origin, letterSpacing, offsetX, offsetY) {
                var pixels = this.alignToGrid(x, y, false);
                offsetX = offsetX || 0;
                offsetY = offsetY || 0;
                return this.Raphael.print(pixels.x + offsetX, pixels.y + offsetY, text, font, size, origin, letterSpacing).attr({
                    'x': pixels.x + offsetX,
                    'y': pixels.y + offsetY
                });
            };
            Utilities.prototype.getFont = function (family, weight, style, stretch) {
                var fontWeight = weight || 100;
                var fontStyle = style || 'normal';
                var fontStretch = stretch || null;
                return this.Raphael.getFont(family, fontWeight, fontStyle, fontStretch);
            };
            Utilities.prototype.set = function () {
                return this.Raphael.set();
            };
            Utilities.pathMoveTo = function (ax, ay) {
                return ['M', ax, ' ', ay].join('');
            };
            Utilities.getPathString = function (initialize, coords) {
                // arguments must be passed; must be at least 4 arguments; number of arguments must be even
                if (!coords ||
                    coords.length < 4 ||
                    coords.length % 2 != 0)
                    return undefined;
                var str = initialize ? Common.Drawing.Utilities.pathMoveTo(coords[0], coords[1]) : '';
                for (var i = 2; i < coords.length; i += 2) {
                    str += Common.Drawing.Utilities.pathLineTo(coords[i], coords[i + 1]);
                }
                return str;
            };
            Utilities.pathLineTo = function (x, y) {
                return ['L', x, ' ', y].join('');
            };
            Utilities.getClosedPathString = function (initialize, coords) {
                return Common.Drawing.Utilities.getPathString(initialize, coords) + ' Z';
            };
            /**
             *
             * ---
             * From the W3C SVG specification:
             * Draws a quadratic Bézier curve from the current point to (x,y)
             * using (x1,y1) as the control point.
             * Q (uppercase) indicates that absolute coordinates will follow;
             * q (lowercase) indicates that relative coordinates will follow.
             * Multiple sets of coordinates may be specified to draw a polybézier.
             * At the end of the command, the new current point becomes
             * the final (x,y) coordinate pair used in the polybézier.
             * ---
             *
             * @param  {any[]}  ...args [description]
             * @return {string}         [description]
             */
            Utilities.getCurveString = function (initialize, coords) {
                // arguments must be passed; must be at least 4 arguments; 
                // number of arguments must be even
                if (!coords || coords.length % 2 != 0) {
                    throw new Error([
                        'You must pass an even number',
                        ' of coords to getCurveString()'
                    ].join(''));
                }
                // current (start) point
                var str = '';
                if (initialize) {
                    if (coords.length != 6) {
                        throw new Error([
                            'You must pass at least 6 coords to initialize',
                            ' a curved path'
                        ].join(''));
                    }
                    var initialCoords = coords.splice(0, 2);
                    str = Common.Drawing.Utilities.pathMoveTo(initialCoords[0], initialCoords[1]);
                }
                if (coords.length < 4) {
                    throw new Error([
                        'There must be 4 coords to create a curved path:',
                        ' control -> (x, y); end -> (x, y);',
                        ' [control.x, control.y, end.x, end.y]'
                    ].join(''));
                }
                for (var i = 0; i < coords.length; i += 4) {
                    str += Common.Drawing.Utilities.quadraticCurveTo(coords[i], // x1 (control x)
                    coords[i + 1], // y1 (control y)
                    coords[i + 2], // x (end x)
                    coords[i + 3] // y (end y)
                    );
                }
                return str;
            };
            Utilities.quadraticCurveTo = function (x1, y1, x, y) {
                return ['Q', x1, ',', y1, ' ', x, ',', y].join('');
            };
            Utilities.buildPath = function (from, to, width) {
                //console.log(from, to, width);
                var dist = this.distance(from.x, from.y, to.x, to.y);
                var theta = this.theta(from.x, from.y, to.x, to.y);
                var p1 = {
                    x: (Math.cos(theta + (Math.PI / 2)) * (width / 2)) + from.x,
                    y: (Math.sin(theta + (Math.PI / 2)) * (width / 2)) + from.y
                };
                var p2 = {
                    x: (Math.cos(theta) * dist) + p1.x,
                    y: (Math.sin(theta) * dist) + p1.y
                };
                var p3 = {
                    x: (Math.cos(theta + (1.5 * Math.PI)) * width) + p2.x,
                    y: (Math.sin(theta + (1.5 * Math.PI)) * width) + p2.y
                };
                var p4 = {
                    x: (Math.cos(theta + Math.PI) * dist) + p3.x,
                    y: (Math.sin(theta + Math.PI) * dist) + p3.y
                };
                var pathStr = Common.Drawing.Utilities.getClosedPathString(true, [p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y]);
                console.log(pathStr);
                return pathStr;
            };
            Utilities.distance = function (x1, y1, x2, y2) {
                return Math.sqrt(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2));
            };
            Utilities.theta = function (x1, y1, x2, y2) {
                var t = Math.atan2((y2 - y1), (x2 - x1));
                return t == Math.PI ? 0 : t;
            };
            Utilities.toDegrees = function (angle) {
                return angle * (180 / Math.PI);
            };
            Utilities.toRadians = function (angle) {
                return angle * (Math.PI / 180);
            };
            return Utilities;
        })();
        Drawing.Utilities = Utilities;
    })(Drawing = Common.Drawing || (Common.Drawing = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Layer = (function (_super) {
            __extends(Layer, _super);
            function Layer(actionable, layerType) {
                if (Common.Utilities.isNullOrUndefined(actionable)) {
                    throw new Error('Layer constructor(): actionable is null or undefined');
                }
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.actionable = actionable;
                this.type = layerType;
                this.visible = true;
                // sub layers
                this.layers = new Common.Models.LayerCollection();
                var self = this;
                this.onModified(function () {
                    self.setModified(true);
                });
            }
            Layer.prototype.containsLayer = function (layer) {
                if (!this.hasLayers())
                    return false;
                var self = this;
                var predicate = function (layer, index) {
                    return self.guid == layer.guid;
                };
                return this.guid == layer.guid || this.layers.hasElementWhich(predicate);
            };
            Layer.prototype.addLayer = function (layer) {
                this.layers.listen(false);
                if (this.hasLayers())
                    this.layers.add(layer);
                this.actionable.graphics.set.push(layer.actionable.graphics);
                this.layers.listen(true);
            };
            Layer.prototype.removeLayer = function (layer) {
                if (this.hasGraphics())
                    layer.actionable.graphics.remove();
                this.actionable.graphics.set.exclude(layer.actionable.graphics);
                return this.hasLayers() ? this.layers.remove(layer.guid) : null;
            };
            Layer.prototype.removeAllLayers = function () {
                if (this.hasLayers())
                    this.layers.removeAll();
            };
            Layer.prototype.toFront = function () {
                if (this.hasGraphics()) {
                    this.actionable.graphics.toFront();
                }
                if (this.hasLayers()) {
                    this.layers.forEach(function (layer, index) {
                        if (layer && layer.actionable.graphics) {
                            layer.actionable.graphics.toFront();
                        }
                    });
                }
            };
            Layer.prototype.toBack = function () {
                if (this.hasLayers()) {
                    this.layers.forEach(function (layer, index) {
                        if (layer && layer.actionable.graphics) {
                            layer.actionable.graphics.toBack();
                        }
                    });
                }
            };
            Layer.prototype.show = function () {
                this.visible = true;
                this.actionable.graphics.show();
                this.showLayers();
            };
            Layer.prototype.showLayers = function () {
                this.visible = true;
                if (this.hasLayers())
                    this.layers.forEach(function (layer, index) {
                        layer.show();
                    });
            };
            Layer.prototype.hide = function () {
                this.visible = false;
                this.actionable.graphics.hide();
                this.hideLayers();
            };
            Layer.prototype.hideLayers = function () {
                if (this.hasLayers())
                    this.layers.forEach(function (layer, index) {
                        layer.hide();
                    });
            };
            Layer.prototype.remove = function () {
                this.removeGraphics();
                this.removeAllLayers();
            };
            Layer.prototype.removeGraphics = function () {
                if (this.hasGraphics())
                    this.actionable.graphics.remove();
            };
            Layer.prototype.moveByDelta = function (dx, dy) {
                this.actionable.graphics.moveByDelta(dx, dy);
                if (this.hasLayers()) {
                    this.layers.forEach(function (layer, index) {
                        layer.moveByDelta(dx, dy);
                    });
                }
            };
            Layer.prototype.drop = function () {
                this.actionable.graphics.drop();
                if (this.hasLayers()) {
                    this.layers.forEach(function (layer, index) {
                        layer.drop();
                    });
                }
            };
            Layer.prototype.hasLayers = function () {
                return this.layers != null && this.layers != undefined;
            };
            Layer.prototype.hasGraphics = function () {
                return Common.Utilities.isNotNullOrUndefined(this.actionable) &&
                    Common.Utilities.isNotNullOrUndefined(this.actionable.graphics);
            };
            Layer.prototype.hasPlacement = function () {
                return this.hasGraphics() && this.actionable.graphics.hasPlacement();
            };
            /**
             * Draws the current layer and its nested layers (recursive)
             */
            Layer.prototype.draw = function () {
                if (this.hasGraphics())
                    this.actionable.graphics.draw();
                if (this.hasLayers() && this.layers.hasElements())
                    this.layers.forEach(function (layer, index) {
                        layer.draw();
                    });
            };
            Layer.prototype.flip = function () {
                this.actionable.graphics.flip(this.actionable.flippable);
                if (this.hasLayers()) {
                    this.layers.forEach(function (layer, index) {
                        layer.flip();
                    });
                }
            };
            return Layer;
        })(Common.Models.Modifiable);
        Models.Layer = Layer;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var LayerCollection = (function (_super) {
            __extends(LayerCollection, _super);
            function LayerCollection() {
                _super.call(this);
                this.onModified(function () { });
            }
            LayerCollection.prototype.dragAll = function (dx, dy) {
                // Not implemented
            };
            LayerCollection.prototype.removeAll = function () {
                // Recursively remove all sub layers
                this.forEach(function (layer, index) {
                    layer.remove();
                });
                _super.prototype.removeAll.call(this);
            };
            LayerCollection.prototype.drop = function () {
                this.forEach(function (layer, index) {
                    if (layer.hasGraphics())
                        layer.actionable.drop();
                });
            };
            LayerCollection.prototype.hide = function () {
                this.forEach(function (layer, index) {
                    if (layer.hasGraphics()) {
                        layer.actionable.graphics.hide();
                        if (layer.actionable.graphics.hasSet()) {
                            layer.actionable.graphics.set.hide();
                        }
                    }
                });
            };
            return LayerCollection;
        })(Common.Models.Collection);
        Models.LayerCollection = LayerCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var CanvasListener = (function () {
            function CanvasListener(context) {
                this.context = context;
                this.actions = {};
            }
            CanvasListener.prototype.listen = function (actionId, fn) {
                if (!this.actions.hasOwnProperty[actionId])
                    this.actions[actionId] = [];
                this.actions[actionId].push(fn);
            };
            CanvasListener.prototype.invoke = function (actionId, data) {
                if (!this.actions[actionId])
                    return;
                for (var i = 0; i < this.actions[actionId].length; i++) {
                    this.actions[actionId][i](data, this.context);
                }
            };
            return CanvasListener;
        })();
        Models.CanvasListener = CanvasListener;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Paper = (function () {
            function Paper(canvas) {
                this.canvas = this.canvas || canvas;
                // By default, paper should be scaled based on max canvas width
                this.sizingMode = this.sizingMode || Common.Enums.PaperSizingModes.MaxCanvasWidth;
                this.x = 0;
                this.y = 0;
                this.scrollSpeed = 0.5;
                this.zoomSpeed = 100;
                this.showBorder = false;
            }
            Paper.prototype.getWidth = function () {
                return this.grid.dimensions.width;
            };
            Paper.prototype.getHeight = function () {
                return this.grid.dimensions.height;
            };
            Paper.prototype.getXOffset = function () {
                return -Math.round((this.canvas.dimensions.width
                    - this.grid.dimensions.width) / 2);
            };
            Paper.prototype.draw = function () {
                this.field.initialize();
                if (this.showBorder)
                    this.drawOutline();
            };
            Paper.prototype.updateScenario = function (scenario) {
                this.field.updateScenario(scenario);
            };
            Paper.prototype.resize = function () {
                this.grid.resize(this.sizingMode);
                this.setViewBox();
                this.draw();
            };
            Paper.prototype.clear = function () {
                this.field.clearScenario();
            };
            Paper.prototype.setViewBox = function (center) {
                center = center === true;
                this.drawing.setAttribute('width', this.grid.dimensions.width);
                //this.x = this.getXOffset();
                var setting = this.drawing.setViewBox(this.x, this.y, this.grid.dimensions.width, this.grid.dimensions.height, true);
            };
            Paper.prototype.drawOutline = function () {
                var self = this;
                if (this.showBorder) {
                    // paper view port
                    if (!this.viewOutline) {
                        this.viewOutline = this.drawing.rect(this.x, this.y, this.canvas.dimensions.width, this.canvas.dimensions.height, true);
                    }
                    this.viewOutline.attr({
                        x: self.x + 1,
                        y: self.y + 1,
                        width: self.canvas.dimensions.width - 1,
                        height: self.canvas.dimensions.height - 1,
                        stroke: 'red'
                    });
                }
            };
            /**
             * Scrolls to the given x/y pixels (top/left). If center is set to true,
             * centers the scroll on the x/y pixels.
             *
             * @param {number}  scrollToX [description]
             * @param {number}  scrollToY [description]
             * @param {boolean} center    [description]
             */
            Paper.prototype.scroll = function (scrollToX, scrollToY, center) {
                center = center === true;
                this.y = center ? this.field.getLOSAbsolute() : scrollToY;
                return this.setViewBox(center);
            };
            return Paper;
        })();
        Models.Paper = Paper;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Grid = (function () {
            function Grid(paper, cols, rows) {
                this.paper = paper;
                this.cols = cols;
                this.rows = rows;
                this.dimensions = new Common.Models.Dimensions();
                this.dimensions.offset.x = 0;
                // sets this.width and this.height
                this.size = this.resize(this.paper.sizingMode);
                this.base = Playbook.Constants.GRID_BASE;
                this.divisor = 2; // TODO @theBull document this
                this.dashArray = ['- '];
                this.verticalStrokeOpacity = 0.2;
                this.horizontalStrokeOpacity = 0.25;
                this.strokeWidth = 0.5;
                this.color = '#000000';
                this.snapping = true;
            }
            Grid.prototype.getSize = function () {
                return this.size;
            };
            Grid.prototype.getWidth = function () {
                return this.dimensions.width;
            };
            Grid.prototype.getHeight = function () {
                return this.dimensions.height;
            };
            Grid.prototype.setSnapping = function (snapping) {
                this.snapping = snapping;
            };
            Grid.prototype.toggleSnapping = function () {
                this.snapping = !this.snapping;
            };
            /**
             * TODO @theBull - document this
             * @return {any} [description]
             */
            Grid.prototype.draw = function () {
                var cols = this.cols;
                var rows = this.rows;
                //var font = this.paper.getFont('Arial');
                for (var c = 1; c <= cols; c++) {
                    var colX = c * this.size;
                    var pathStr = Common.Drawing.Utilities.getPathString(true, [
                        colX,
                        0,
                        colX,
                        rows * this.size
                    ]);
                    var p = this.paper.drawing.path(pathStr).attr({
                        'stroke-dasharray': this.dashArray,
                        'stroke-opacity': this.verticalStrokeOpacity,
                        'stroke-width': this.strokeWidth,
                        'stroke': this.color,
                        'class': 'pointer-events-none'
                    });
                }
                for (var r = 1; r <= rows; r++) {
                    var rowY = r * this.size;
                    var pathStr = Common.Drawing.Utilities.getPathString(true, [
                        this.getSize(),
                        rowY,
                        this.dimensions.width,
                        rowY
                    ]);
                    var opacity, dashes;
                    if (r % 10 == 0) {
                        if (r > 10 && r < 100) {
                            var value = (r - 10);
                            if (value > 50)
                                value = value - ((value - 50) * 2);
                            var str = value.toString();
                            // let lineNumbersLeft = this.paper.print(
                            // 	2,
                            // 	r,
                            // 	str,
                            // 	font,
                            // 	30
                            // );.transform('r-90');
                            var lineNumbersLeft = this.paper.drawing.text(2, r, str, false).transform('r-90').attr({ 'class': 'no-highlight' });
                            // let lineNumbersRight = this.paper.print(
                            // 	50, 
                            // 	r, 
                            // 	str, 
                            // 	font, 
                            // 	30
                            // ).transform('r90');
                            var lineNumbersRight = this.paper.drawing.text(50, r, str, false).transform('r90').attr({ 'class': 'no-highlight' });
                        }
                        opacity = 1;
                        this.paper.drawing.path(pathStr).attr({
                            'stroke-opacity': this.horizontalStrokeOpacity,
                            'stroke-width': 3,
                            'stroke': '#ffffff',
                            'class': 'pointer-events-none'
                        });
                    }
                    else {
                        this.paper.drawing.path(pathStr).attr({
                            'stroke-dasharray': this.dashArray,
                            'stroke-opacity': this.horizontalStrokeOpacity,
                            'stroke-width': this.strokeWidth,
                            'stroke': this.color,
                            'class': 'pointer-events-none'
                        });
                    }
                }
            };
            /**
             * recalculates the width and height of the grid
             * with the context width and height
             */
            Grid.prototype.resize = function (sizingMode) {
                if (this.cols <= 0)
                    throw new Error('Grid cols must be defined and greater than 0');
                var canvasWidth = this.paper.canvas.dimensions.width;
                if (canvasWidth == 0)
                    throw new Error('Grid canvas width must be greater than 0');
                switch (this.paper.sizingMode) {
                    case Common.Enums.PaperSizingModes.TargetGridWidth:
                        this.size = Playbook.Constants.GRID_SIZE;
                        break;
                    case Common.Enums.PaperSizingModes.MaxCanvasWidth:
                        this.size = Math.floor(this.paper.canvas.dimensions.width / this.cols);
                        break;
                    case Common.Enums.PaperSizingModes.PreviewWidth:
                        this.size = this.paper.canvas.dimensions.width / this.cols; // don't round
                        break;
                }
                this.dimensions.width = this.cols * this.size;
                this.dimensions.height = this.rows * this.size;
                return this.size;
            };
            /**
             * TODO @theBull - document this
             * returns the grid value for the bottom-most grid line (horizontal)
             * @return {number} [description]
             */
            Grid.prototype.bottom = function () {
                return this.rows;
            };
            /**
             * TODO @theBull - document this
             * returns the grid value for the right-most grid line (vertical)
             * @return {number} [description]
             */
            Grid.prototype.right = function () {
                return this.cols;
            };
            /**
             * TODO @theBull - document this
             * @return {Playbook.Models.Coordinate} [description]
             */
            Grid.prototype.getCenter = function () {
                return new Common.Models.Coordinates((Math.round(this.cols / 2) + this.dimensions.offset.x), Math.round(this.rows / 2));
            };
            /**
             * TODO @theBull - document this
             * @return {Playbook.Models.Coordinate} [description]
             */
            Grid.prototype.getCenterInPixels = function () {
                var centerCoords = this.getCenter();
                return this.getAbsoluteFromCoordinates(centerCoords.x, centerCoords.y);
            };
            Grid.prototype.getCursorOffset = function (offsetX, offsetY) {
                var canvasOffsetX = offsetX + this.paper.x - this.getSize(); // -1 for left sideline offset
                var canvasOffsetY = offsetY + this.paper.y - (10 * this.getSize()); // -10 to account for endzones
                return new Common.Models.Coordinates(canvasOffsetX, canvasOffsetY);
            };
            Grid.prototype.getCursorPositionAbsolute = function (offsetX, offsetY) {
                return this.getCursorOffset(offsetX, offsetY);
            };
            Grid.prototype.getCursorPositionCoordinates = function (offsetX, offsetY) {
                var cursorOffset = this.getCursorOffset(offsetX, offsetY);
                return this.getCoordinatesFromAbsolute(cursorOffset.x, cursorOffset.y);
            };
            /**
             * TODO @theBull - document this
             * @return {Playbook.Models.Coordinate} [description]
             */
            Grid.prototype.getCoordinates = function () {
                return new Common.Models.Coordinates(-1, -1); // TODO
            };
            /**
             * TODO @theBull - document this
             * @return {Playbook.Models.Coordinate} [description]
             */
            Grid.prototype.getDimensions = function () {
                return this.dimensions;
            };
            /**
             * TODO @theBull - document this
             * @return {number} [description]
             */
            Grid.prototype.gridProportion = function () {
                return this.size / this.base;
            };
            /**
             * TODO @theBull - document this
             * @param  {number} val [description]
             * @return {number}     [description]
             */
            Grid.prototype.computeGridZoom = function (val) {
                return val * this.gridProportion();
            };
            /**
             * Calculates a single absolute pixel value from the given grid value
             * @param  {number} val the coord value to calculate
             * @return {number}     The calculated absolute pixel
             */
            Grid.prototype.getAbsoluteFromCoordinate = function (val) {
                return val * this.size;
            };
            /**
             * Returns the absolute pixel values of the given grid coords
             * @param  {Common.Models.Coordinate} coords the grid coords to calculate
             * @return {Common.Models.Coordinate}        the absolute pixel coords
             */
            Grid.prototype.getAbsoluteFromCoordinates = function (x, y) {
                var coords = new Common.Models.Coordinates(x, y);
                var calculatedCoords = new Common.Models.Coordinates(this.getAbsoluteFromCoordinate(coords.x + this.dimensions.offset.x), this.getAbsoluteFromCoordinate(coords.y));
                return calculatedCoords;
            };
            /**
             * Calculates grid coords from the given pixel values
             * @param {Playbook.Models.Coordinate} coords coordinates in raw pixel form
             * @return {Playbook.Models.Coordinate}		the matching grid pixels as coords
             */
            Grid.prototype.getCoordinatesFromAbsolute = function (x, y) {
                // TODO: add in paper scroll offset
                var coordX = Math.round((x / this.size) * this.divisor) / this.divisor;
                var coordY = Math.round((y / this.size) * this.divisor) / this.divisor;
                return new Common.Models.Coordinates(coordX + this.dimensions.offset.x, coordY);
            };
            Grid.prototype.getRelativeFromAbsolute = function (ax, ay, relativeElement) {
                //let coords = this.getCoordinatesFromAbsolute(ax, ay);
                throw new Error('grid getRelativeFromAbsolute(): not implemented');
            };
            /**
             * Takes the given coords and snaps them to the nearest grid coords
             *
             * @param {Playbook.Models.Coordinate} coords Coordinates to snap
             * @return {Playbook.Models.Coordinate}		The nearest snapped coordinates
             */
            Grid.prototype.snapToNearest = function (ax, ay) {
                return this.getCoordinatesFromAbsolute(ax, ay);
            };
            /**
             * Snaps the given coords to the grid
             * @param {Playbook.Models.Coordinate} coords assumed non-snapped coordinates
             * @return {Playbook.Models.Coordinate}		the snapped coordinates
             */
            Grid.prototype.snap = function (x, y) {
                var coords = new Common.Models.Coordinates(x, y);
                var snapX = this.snapPixel(coords.x);
                var snapY = this.snapPixel(coords.y);
                return new Common.Models.Coordinates(snapX, snapY);
            };
            /**
             * takes a pixel value and translates it into a corresponding
             * number of grid units
             *
             * @param  {number} val value to calculate
             * @return {number}     calculated value
             */
            Grid.prototype.snapPixel = function (val) {
                return (Math.round(val / (this.size / this.divisor)) * (this.size / this.divisor)) + this.dimensions.offset.x;
            };
            /**
             * Determines whether the given value is equally divisible
             * by the gridsize
             *
             * @param {number} val The value to calculate
             * @return {boolean}	true if divisible, otherwise false
             */
            Grid.prototype.isDivisible = function (val) {
                return val % (this.size / this.divisor) == 0;
            };
            return Grid;
        })();
        Models.Grid = Grid;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Field = (function (_super) {
            __extends(Field, _super);
            function Field(paper, scenario) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.paper = paper;
                this.grid = this.paper.grid;
                this.scenario = scenario;
                this.primaryPlayers = new Common.Models.PlayerCollection();
                this.opponentPlayers = new Common.Models.PlayerCollection();
                this.selected = new Common.Models.Collection();
                this.layers = new Common.Models.LayerCollection();
                this.cursorCoordinates = new Common.Models.Coordinates(0, 0);
                this.editorType = Playbook.Enums.EditorTypes.Any;
                var self = this;
                this.selected.onModified(function () {
                    self.setModified(true);
                });
                this.primaryPlayers.onModified(function () {
                    self.setModified(true);
                });
                this.opponentPlayers.onModified(function () {
                    self.setModified(true);
                });
                this.onModified(function () {
                });
            }
            Field.prototype.registerLayer = function (layer) {
                this.layers.add(layer);
            };
            Field.prototype.draw = function () {
                this.ground.draw();
                this.grid.draw();
                this.los.draw();
                this.ball.draw();
                this.drawScenario();
            };
            Field.prototype.clearPlayers = function () {
                this.clearPrimaryPlayers();
                this.clearOpponentPlayers();
            };
            Field.prototype.clearPrimaryPlayers = function () {
                this.primaryPlayers.listen(false);
                this.primaryPlayers.forEach(function (player, index) {
                    if (Common.Utilities.isNotNullOrUndefined(player.assignment)) {
                        player.assignment.routes.forEach(function (route, index) {
                            route.layer.remove();
                        });
                    }
                    player.layer.remove();
                });
                this.primaryPlayers.removeAll();
                this.primaryPlayers.listen(true);
            };
            Field.prototype.clearOpponentPlayers = function () {
                this.opponentPlayers.listen(false);
                this.opponentPlayers.forEach(function (player, index) {
                    if (Common.Utilities.isNotNullOrUndefined(player.assignment)) {
                        player.assignment.routes.forEach(function (route, index) {
                            route.layer.remove();
                        });
                    }
                    player.layer.remove();
                });
                this.opponentPlayers.removeAll();
                this.opponentPlayers.listen(true);
            };
            Field.prototype.clearScenario = function () {
                this.clearPrimaryPlay();
                this.clearOpponentPlay();
            };
            Field.prototype.clearPrimaryPlay = function () {
                this.clearPrimaryPlayers();
            };
            Field.prototype.clearOpponentPlay = function () {
                this.clearOpponentPlayers();
            };
            Field.prototype.drawScenario = function () {
                // draw the play data onto the field
                this.scenario.draw(this);
            };
            Field.prototype.updateScenario = function (scenario) {
                this.clearScenario();
                this.scenario = scenario;
                this.drawScenario();
            };
            Field.prototype.updatePlacements = function () {
                var self = this;
                if (Common.Utilities.isNotNullOrUndefined(this.scenario)) {
                    if (Common.Utilities.isNotNullOrUndefined(this.scenario.playPrimary)) {
                        var primaryPlacementCollection = new Common.Models.PlacementCollection();
                        this.primaryPlayers.forEach(function (player, index) {
                            primaryPlacementCollection.add(player.graphics.placement);
                        });
                        self.scenario.playPrimary.formation.setPlacements(primaryPlacementCollection);
                    }
                    if (Common.Utilities.isNotNullOrUndefined(this.scenario.playOpponent)) {
                        var opponentPlacementCollection = new Common.Models.PlacementCollection();
                        this.opponentPlayers.forEach(function (player, index) {
                            opponentPlacementCollection.add(player.graphics.placement);
                        });
                        self.scenario.playOpponent.formation.setPlacements(opponentPlacementCollection);
                    }
                }
            };
            Field.prototype.setCursorCoordinates = function (offsetX, offsetY) {
                this.cursorCoordinates = this.grid.getCursorPositionCoordinates(offsetX, offsetY);
                this.setModified(true);
            };
            Field.prototype.getPrimaryPlayerWithPositionIndex = function (index) {
                var matchingPlayer = this.primaryPlayers.filterFirst(function (player) {
                    return player.hasPosition() && (player.position.index == index);
                });
                return matchingPlayer;
            };
            Field.prototype.getOpponentPlayerWithPositionIndex = function (index) {
                var matchingPlayer = this.opponentPlayers.filterFirst(function (player) {
                    return player.hasPosition() && (player.position.index == index);
                });
                return matchingPlayer;
            };
            Field.prototype.applyPrimaryPlay = function (play) {
                throw new Error('field applyPrimaryPlay() not implemented');
            };
            Field.prototype.applyPrimaryFormation = function (formation) {
                if (Common.Utilities.isNullOrUndefined(formation) ||
                    Common.Utilities.isNullOrUndefined(this.scenario) ||
                    Common.Utilities.isNullOrUndefined(this.scenario.playPrimary))
                    return;
                //console.log(formation);
                // the order of placements within the formation get applied straight across
                // to the order of personnel and positions.
                var self = this;
                this.primaryPlayers.forEach(function (player, index) {
                    // NOTE: we're not using the index from the forEach callback,
                    // because we can't assume the players collection stores the players
                    // in the order according to the player's actual index property
                    var playerIndex = player.position.index;
                    if (playerIndex < 0) {
                        throw new Error('Player must have a position index');
                    }
                    var newPlacement = formation.placements.getIndex(playerIndex);
                    if (!newPlacement) {
                        throw new Error('Updated player placement is invalid');
                    }
                    player.setPlacement(newPlacement);
                    player.draw();
                });
                this.scenario.playPrimary.setFormation(formation);
            };
            Field.prototype.applyPrimaryAssignmentGroup = function (assignmentGroup) {
                if (Common.Utilities.isNullOrUndefined(assignmentGroup) ||
                    Common.Utilities.isNullOrUndefined(this.scenario) ||
                    Common.Utilities.isNullOrUndefined(this.scenario.playPrimary))
                    return;
                var self = this;
                if (assignmentGroup.assignments.hasElements()) {
                    assignmentGroup.assignments.forEach(function (assignment, index) {
                        if (Common.Utilities.isNullOrUndefined(assignment))
                            return;
                        var player = self.getPrimaryPlayerWithPositionIndex(assignment.positionIndex);
                        if (player) {
                            assignment.setContext(player);
                            player.assignment.remove();
                            player.assignment = assignment;
                            player.draw();
                        }
                    });
                    this.scenario.playPrimary.setAssignmentGroup(assignmentGroup);
                }
            };
            Field.prototype.applyPrimaryPersonnel = function (personnel) {
                if (Common.Utilities.isNullOrUndefined(personnel) ||
                    Common.Utilities.isNullOrUndefined(this.scenario) ||
                    Common.Utilities.isNullOrUndefined(this.scenario.playPrimary))
                    return;
                var self = this;
                if (personnel && personnel.hasPositions()) {
                    this.primaryPlayers.forEach(function (player, index) {
                        var newPosition = personnel.positions.getIndex(index);
                        if (self.scenario.playPrimary.personnel &&
                            self.scenario.playPrimary.personnel.hasPositions()) {
                            self.scenario.playPrimary.personnel.positions.getIndex(index).fromJson(newPosition.toJson());
                        }
                        player.position.fromJson(newPosition.toJson());
                        player.draw();
                    });
                    this.scenario.playPrimary.setPersonnel(personnel);
                }
                else {
                    var details = personnel ? '# positions: ' + personnel.positions.size() : 'Personnel is undefined.';
                    alert([
                        'There was an error applying this personnel group. ',
                        'Please inspect it in the Team Management module. \n\n',
                        details
                    ].join(''));
                }
            };
            Field.prototype.applyPrimaryUnitType = function (unitType) {
                if (Common.Utilities.isNullOrUndefined(unitType) ||
                    Common.Utilities.isNullOrUndefined(this.scenario) ||
                    Common.Utilities.isNullOrUndefined(this.scenario.playPrimary))
                    return;
                this.scenario.playPrimary.setUnitType(unitType);
                if (Common.Utilities.isNotNullOrUndefined(this.scenario.playOpponent))
                    this.scenario.playOpponent.setUnitType(this.scenario.playPrimary.getOpposingUnitType());
                this.clearPlayers();
                this.drawScenario();
            };
            Field.prototype.deselectAll = function () {
                if (this.selected.isEmpty())
                    return;
                this.selected.forEach(function (element, index) {
                    element.deselect();
                });
                this.selected.removeAll();
            };
            Field.prototype.getSelectedByLayerType = function (layerType) {
                var collection = new Common.Models.Collection();
                this.selected.forEach(function (selectedElement, index) {
                    if (selectedElement.layer.type == layerType) {
                        collection.add(selectedElement);
                    }
                });
                return collection;
            };
            Field.prototype.toggleSelectionByLayerType = function (layerType) {
                var selectedElements = this.selected.filter(function (selectedElement, index) {
                    return selectedElement.layer.type == layerType;
                });
                if (selectedElements && selectedElements.length > 0) {
                    for (var i = 0; i < selectedElements.length; i++) {
                        var selectedElement = selectedElements[i];
                        if (selectedElement)
                            this.toggleSelection(selectedElement);
                    }
                }
            };
            /**
             * Sets the selected items to a single selected element; removes and deselects any
             * other currently selected elements.
             * @param {Common.Interfaces.IFieldElement} element [description]
             */
            Field.prototype.setSelection = function (element) {
                // clear any selected players
                this.selected.forEach(function (selectedElement, index) {
                    selectedElement.deselect();
                });
                this.selected.removeAll();
                element.select();
                this.selected.add(element);
            };
            /**
             * Toggles the selection state of the given element; adds it to the
             * list of selected elements if it isn't already added; if it's already
             * selected, deselects the element and removes it from the selected
             * @param {Common.Interfaces.IFieldElement} element [description]
             */
            Field.prototype.toggleSelection = function (element) {
                // element.graphics.toggleSelect();
                if (this.selected.contains(element.guid)) {
                    this.selected.remove(element.guid);
                    element.deselect();
                }
                else {
                    this.selected.add(element);
                    element.select();
                }
            };
            /**
             * Returns the absolute y-coordinate of the line of scrimmage
             * @return {number} [description]
             */
            Field.prototype.getLOSAbsolute = function () {
                if (!this.los)
                    throw new Error('Field getLOSAbsolute(): los is null or undefined');
                return this.los.graphics.location.ay;
            };
            return Field;
        })(Common.Models.Modifiable);
        Models.Field = Field;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var FieldElement = (function (_super) {
            __extends(FieldElement, _super);
            function FieldElement() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Unknown);
                _super.prototype.setContext.call(this, this);
                this.contextmenuTemplateUrl = Common.Constants.DEFAULT_CONTEXTMENU_TEMPLATE_URL;
            }
            FieldElement.prototype.initialize = function (field, relativeElement) {
                this.field = field;
                this.ball = this.field.ball;
                this.relativeElement = relativeElement;
                this.paper = this.field.paper;
                this.canvas = this.paper.canvas;
                this.grid = this.paper.grid;
                this.graphics = new Common.Models.Graphics(this.paper);
                this.layer = new Common.Models.Layer(this, Common.Enums.LayerTypes.FieldElement);
                this._originalScreenPositionX = null;
                this._originalScreenPositionY = null;
                var self = this;
                this.onModified(function () {
                    self.field.setModified(true);
                });
            };
            FieldElement.prototype.getContextmenuUrl = function () {
                return this.contextmenuTemplateUrl;
            };
            FieldElement.prototype.hasLayer = function () {
                return this.layer != null && this.layer != undefined;
            };
            FieldElement.prototype.getLayer = function () {
                return this.layer;
            };
            FieldElement.prototype.getGraphics = function () {
                return this.hasGraphics() ? this.graphics : null;
            };
            FieldElement.prototype.hasPlacement = function () {
                return this.layer.hasPlacement();
            };
            FieldElement.prototype.hoverIn = function (e) {
            };
            FieldElement.prototype.hoverOut = function (e) {
            };
            FieldElement.prototype.click = function (e) {
                console.log('fieldelement click');
                if (this.disabled)
                    return;
                this.toggleSelect(e.metaKey);
            };
            FieldElement.prototype.toggleSelect = function (metaKey) {
                metaKey = metaKey === true;
                _super.prototype.toggleSelect.call(this);
                if (metaKey) {
                    this.field.toggleSelection(this);
                }
                else {
                    this.field.setSelection(this);
                }
            };
            FieldElement.prototype.mousedown = function (e) {
                if (e.keyCode == Common.Input.Which.RightClick) {
                    this.contextmenu(e);
                }
            };
            FieldElement.prototype.dragMove = function (dx, dy, posx, posy, e) {
            };
            FieldElement.prototype.dragStart = function (x, y, e) {
                this.setOriginalDragPosition(x, y);
            };
            FieldElement.prototype.dragEnd = function (e) {
                this.setOriginalDragPosition(null, null);
                this.dragging = false;
            };
            FieldElement.prototype.drop = function () {
                this.layer.drop();
            };
            FieldElement.prototype.getOriginalScreenPosition = function () {
                return {
                    x: this._originalScreenPositionX,
                    y: this._originalScreenPositionY
                };
            };
            FieldElement.prototype.setOriginalDragPosition = function (x, y) {
                this._originalScreenPositionX = x;
                this._originalScreenPositionY = y;
            };
            FieldElement.prototype.isOriginalDragPositionSet = function () {
                return !Common.Utilities.isNull(this._originalScreenPositionX) &&
                    !Common.Utilities.isNull(this._originalScreenPositionY);
            };
            FieldElement.prototype.isOverDragThreshold = function (x, y) {
                return Math.abs(x) > Playbook.Constants.DRAG_THRESHOLD_X ||
                    Math.abs(y) > Playbook.Constants.DRAG_THRESHOLD_Y;
            };
            return FieldElement;
        })(Common.Models.Actionable);
        Models.FieldElement = FieldElement;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Ball = (function (_super) {
            __extends(Ball, _super);
            function Ball() {
                _super.call(this);
            }
            Ball.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field, null);
                this.layer.type = Common.Enums.LayerTypes.Ball;
                this.graphics.fill = 'brown';
                this.graphics.dimensions.setWidth(this.grid.getSize() * 0.15);
                this.graphics.dimensions.setHeight(this.grid.getSize() * 0.25);
                this.graphics.initializePlacement(new Common.Models.Placement(Playbook.Constants.BALL_DEFAULT_PLACEMENT_X, Playbook.Constants.BALL_DEFAULT_PLACEMENT_Y, null));
            };
            Ball.prototype.draw = function () {
                this.graphics.ellipse();
            };
            return Ball;
        })(Common.Models.FieldElement);
        Models.Ball = Ball;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Ground = (function (_super) {
            __extends(Ground, _super);
            function Ground() {
                _super.call(this);
            }
            Ground.prototype.initialize = function (field, relativeElement) {
                _super.prototype.initialize.call(this, field, null);
                this.selectable = false;
                this.graphics.initializePlacement(new Common.Models.Placement(this.paper.x, this.paper.y, null));
                this.graphics.dimensions.setWidth(this.grid.dimensions.width + 2);
                this.graphics.dimensions.setHeight(this.grid.dimensions.height + 2);
                this.graphics.setOriginalOpacity(1);
                this.graphics.setOriginalStrokeWidth(0);
                this.graphics.setOriginalFill(Playbook.Constants.FIELD_COLOR);
            };
            Ground.prototype.draw = function () {
                this.graphics.rect();
                this.graphics.onclick(this.click, this);
            };
            Ground.prototype.click = function (e) {
                // Do nothing
                console.log('ground clicked');
            };
            Ground.prototype.getClickCoordinates = function (offsetX, offsetY) {
                var absCoords = this.getClickAbsolute(offsetX, offsetY);
                return this.grid.getCoordinatesFromAbsolute(absCoords.x, absCoords.y);
            };
            Ground.prototype.getClickAbsolute = function (offsetX, offsetY) {
                return new Common.Models.Coordinates(offsetX + this.graphics.dimensions.offset.x - Math.abs(this.paper.x), offsetY + Math.abs(this.paper.y) + this.graphics.dimensions.offset.y);
            };
            return Ground;
        })(Common.Models.FieldElement);
        Models.Ground = Ground;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var LineOfScrimmage = (function (_super) {
            __extends(LineOfScrimmage, _super);
            function LineOfScrimmage() {
                _super.call(this);
            }
            LineOfScrimmage.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field, null);
                this.layer.type = Common.Enums.LayerTypes.LineOfScrimmage;
                this.graphics.setOriginalFill('yellow');
                this.graphics.setOriginalStrokeWidth(0);
                this.graphics.setOriginalOpacity(1);
                this.graphics.dimensions.width = this.grid.dimensions.width - (this.grid.getSize() * 2);
                this.graphics.dimensions.height = 1;
                this.graphics.initializePlacement(new Common.Models.Placement(1, this.field.ball.graphics.placement.coordinates.y, null));
            };
            return LineOfScrimmage;
        })(Common.Models.FieldElement);
        Models.LineOfScrimmage = LineOfScrimmage;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Endzone = (function (_super) {
            __extends(Endzone, _super);
            function Endzone(offsetY) {
                _super.call(this);
                this.offsetY = offsetY;
            }
            Endzone.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field, null);
                this.layer.type = Common.Enums.LayerTypes.Endzone;
                this.graphics.fill = 'black';
                this.graphics.setOpacity(0.25);
                this.graphics.initializePlacement(new Common.Models.Placement(1, this.offsetY, null));
                this.graphics.dimensions.setWidth(this.paper.getWidth() - (2 * this.grid.getSize()));
                this.graphics.dimensions.setHeight(10 * this.grid.getSize());
            };
            Endzone.prototype.draw = function () {
                this.graphics.rect();
            };
            return Endzone;
        })(Common.Models.FieldElement);
        Models.Endzone = Endzone;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Hashmark = (function (_super) {
            __extends(Hashmark, _super);
            function Hashmark(offsetX) {
                _super.call(this);
                this.offsetX = offsetX;
            }
            Hashmark.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field, null);
                // hash marks should be -x- grid units from center
                this.layer.type = Common.Enums.LayerTypes.Hashmark;
                this.graphics.dimensions.offset.x = -0.25 * this.grid.getSize();
                this.graphics.dimensions.offset.y = 0;
                this.graphics.initializePlacement(new Common.Models.Placement(this.offsetX, 0, null));
                this.start = 11;
                this.yards = 110;
            };
            Hashmark.prototype.draw = function () {
                var hashmarkWidth = this.grid.getSize() / 2;
                for (var i = this.start; i < this.yards; i++) {
                    var hashmark = this.paper.drawing.rect(this.graphics.placement.coordinates.x, i, hashmarkWidth, 1, false, this.graphics.dimensions.offset.x, 0).attr({
                        'fill': 'white',
                        'stroke-width': 0
                    });
                }
            };
            return Hashmark;
        })(Common.Models.FieldElement);
        Models.Hashmark = Hashmark;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Sideline = (function (_super) {
            __extends(Sideline, _super);
            function Sideline(offsetX) {
                _super.call(this);
                this.offsetX = offsetX;
            }
            Sideline.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field, null);
                this.graphics.fill = 'white';
                this.graphics.strokeWidth = 0;
                this.graphics.initializePlacement(new Common.Models.Placement(this.offsetX, 0, null));
                this.graphics.dimensions.width = this.grid.getSize();
                this.graphics.dimensions.height = this.grid.getHeight();
            };
            Sideline.prototype.draw = function () {
                this.graphics.rect();
            };
            return Sideline;
        })(Common.Models.FieldElement);
        Models.Sideline = Sideline;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var FieldSelectionBox = (function (_super) {
            __extends(FieldSelectionBox, _super);
            function FieldSelectionBox() {
                _super.call(this);
            }
            FieldSelectionBox.prototype.initialize = function (field, relativeElement) {
                _super.prototype.initialize.call(this, field, null);
                this.graphics.setOriginalFill('#1752FA');
                this.graphics.setOriginalStroke('#202BA2');
                this.graphics.setOriginalFillOpacity(0.3);
                this.graphics.setOriginalStrokeWidth(1);
                this.graphics.dimensions.setHeight(0);
                this.graphics.dimensions.setWidth(0);
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, null));
            };
            FieldSelectionBox.prototype.draw = function () {
                this.graphics.rect();
            };
            return FieldSelectionBox;
        })(Common.Models.FieldElement);
        Models.FieldSelectionBox = FieldSelectionBox;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        // @todo treat Player as a FieldElementSet
        var Player = (function (_super) {
            __extends(Player, _super);
            function Player(placement, position, assignment) {
                _super.call(this);
                this.placement = placement;
                this.position = position;
                this.unitType = this.position ? this.position.unitType : Team.Enums.UnitTypes.Other;
                this.assignment = assignment || new Common.Models.Assignment(this.unitType);
                this.flippable = true;
                if (Common.Utilities.isNotNullOrUndefined(this.assignment) &&
                    Common.Utilities.isNotNullOrUndefined(this.position)) {
                    this.assignment.positionIndex = this.position.index;
                }
            }
            Player.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field, field.ball);
                this.layer.type = Common.Enums.LayerTypes.Player;
                //this.graphics.setPlacement(this.placement);
                this.graphics.initializePlacement(this.placement);
                this.placement.setRelativeElement(this.field.ball);
                this.graphics.dimensions.setWidth(this.grid.getSize());
                this.graphics.dimensions.setHeight(this.grid.getSize());
                var self = this;
                this.onModified(function () {
                    self.field.primaryPlayers.setModified(true);
                });
                this.layer.onModified(function () {
                    self.setModified(true);
                });
            };
            Player.prototype.flip = function () {
                this.layer.flip();
                if (Common.Utilities.isNotNullOrUndefined(this.assignment) &&
                    Common.Utilities.isNotNullOrUndefined(this.assignment.routes)) {
                    this.assignment.routes.forEach(function (route, index) {
                        route.flip();
                    });
                }
                this.flipped = !this.flipped;
            };
            Player.prototype.remove = function () {
                this.layer.remove();
            };
            Player.prototype.drawRoute = function () {
                // Draw the player's assignment
                if (Common.Utilities.isNotNullOrUndefined(this.assignment)) {
                    if (this.assignment.routes.hasElements()) {
                        this.assignment.routes.forEach(function (route, index) {
                            route.draw();
                        });
                    }
                }
            };
            Player.prototype.moveAssignmentByDelta = function (dx, dy) {
                if (this.assignment) {
                    // TODO: implement route switching
                    this.assignment.routes.forEach(function (route, index) {
                        if (Common.Utilities.isNotNullOrUndefined(route)) {
                            route.layer.moveByDelta(dx, dy);
                        }
                    });
                }
            };
            Player.prototype.dropAssignment = function () {
                if (this.assignment) {
                    // TODO: implement route switching
                    this.assignment.routes.forEach(function (route, index) {
                        if (Common.Utilities.isNotNullOrUndefined(route)) {
                            if (route.dragInitialized) {
                                route.dragInitialized = false;
                            }
                            route.drop();
                            route.draw();
                        }
                    });
                }
            };
            Player.prototype.getPositionRelativeToBall = function () {
                return this.graphics.placement.relative;
            };
            Player.prototype.getCoordinatesFromAbsolute = function () {
                return this.graphics.placement.coordinates;
            };
            /**
             *
             * Assignment
             *
             */
            Player.prototype.hasAssignment = function () {
                return Common.Utilities.isNullOrUndefined(this.assignment);
            };
            Player.prototype.getAssignment = function () {
                return this.assignment;
            };
            Player.prototype.setAssignment = function (assignment) {
                this.assignment = assignment;
                this.setModified(true);
            };
            /**
             *
             * Position
             *
             */
            Player.prototype.hasPosition = function () {
                return Common.Utilities.isNullOrUndefined(this.position);
            };
            Player.prototype.getPosition = function () {
                return this.position;
            };
            Player.prototype.setPosition = function (position) {
                this.position = position;
                this.setModified(true);
            };
            /**
             *
             * Placement
             *
             */
            Player.prototype.hasPlacement = function () {
                return Common.Utilities.isNullOrUndefined(this.graphics.placement);
            };
            Player.prototype.getPlacement = function () {
                return this.graphics.placement;
            };
            Player.prototype.setPlacement = function (placement) {
                this.graphics.placement.update(placement);
                this.setModified(true);
            };
            return Player;
        })(Common.Models.FieldElement);
        Models.Player = Player;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayerCollection = (function (_super) {
            __extends(PlayerCollection, _super);
            function PlayerCollection() {
                _super.call(this);
                this.onModified(function () { });
            }
            return PlayerCollection;
        })(Common.Models.Collection);
        Models.PlayerCollection = PlayerCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayerSelectionBox = (function (_super) {
            __extends(PlayerSelectionBox, _super);
            function PlayerSelectionBox(player) {
                _super.call(this);
                this.player = player;
                this.initialize(this.player.field, this.player);
                this.layer.type = Common.Enums.LayerTypes.PlayerSelectionBox;
                this.selectable = false;
                this.graphics.setOriginalOpacity(1);
                this.graphics.setOriginalFill('');
                this.graphics.setOriginalStroke('blue');
                this.graphics.setOriginalStrokeWidth(1);
                this.graphics.dimensions.width = (this.player.graphics.dimensions.getWidth());
                this.graphics.dimensions.height = (this.player.graphics.dimensions.getHeight());
                this.graphics.setOffsetXY(-this.player.graphics.dimensions.getWidth() / 2, -this.player.graphics.dimensions.getHeight() / 2);
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
            }
            PlayerSelectionBox.prototype.draw = function () {
                this.graphics.rect();
                this.graphics.hide();
            };
            return PlayerSelectionBox;
        })(Common.Models.FieldElement);
        Models.PlayerSelectionBox = PlayerSelectionBox;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayerIcon = (function (_super) {
            __extends(PlayerIcon, _super);
            function PlayerIcon(player) {
                _super.call(this);
                this.player = player;
                this.initialize(this.player.field, this.player);
                this.layer.type = Common.Enums.LayerTypes.PlayerIcon;
                this.graphics.dimensions.setRadius(this.grid.getSize() / 2);
                this.graphics.dimensions.setWidth(this.player.graphics.dimensions.getWidth());
                this.graphics.dimensions.setHeight(this.player.graphics.dimensions.getHeight());
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
                this.flippable = true;
            }
            PlayerIcon.prototype.draw = function () {
                switch (this.player.unitType) {
                    case Team.Enums.UnitTypes.Offense:
                        this.graphics.setOffsetXY(0, 0);
                        this.graphics.circle();
                        break;
                    case Team.Enums.UnitTypes.Defense:
                        this.graphics.setOffsetXY(0, 0);
                        this.graphics.triangle();
                        break;
                    case Team.Enums.UnitTypes.SpecialTeams:
                        this.graphics.setOffsetXY(-(this.graphics.dimensions.getWidth() / 2), -(this.graphics.dimensions.getHeight() / 2));
                        this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
                        this.graphics.rect();
                        break;
                    case Team.Enums.UnitTypes.Other:
                        this.graphics.setOffsetXY(-(this.graphics.dimensions.getWidth() / 2), -(this.graphics.dimensions.getHeight() / 2));
                        this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
                        this.graphics.rhombus();
                        break;
                }
            };
            return PlayerIcon;
        })(Common.Models.FieldElement);
        Models.PlayerIcon = PlayerIcon;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayerRelativeCoordinatesLabel = (function (_super) {
            __extends(PlayerRelativeCoordinatesLabel, _super);
            function PlayerRelativeCoordinatesLabel(player) {
                _super.call(this);
                this.player = player;
                this.initialize(this.player.field, this.player);
                this.layer.type = Common.Enums.LayerTypes.PlayerRelativeCoordinatesLabel;
                this.selectable = false;
                this.graphics.snapping = false;
                this.graphics.setOffsetXY(0, this.grid.getSize());
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
            }
            PlayerRelativeCoordinatesLabel.prototype.draw = function () {
                this.graphics.text([
                    this.player.graphics.placement.relative.rx, ', ',
                    this.player.graphics.placement.relative.ry
                ].join(''));
                this.graphics.setAttribute('class', 'no-highlight');
                this.layer.hide();
            };
            return PlayerRelativeCoordinatesLabel;
        })(Common.Models.FieldElement);
        Models.PlayerRelativeCoordinatesLabel = PlayerRelativeCoordinatesLabel;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayerPersonnelLabel = (function (_super) {
            __extends(PlayerPersonnelLabel, _super);
            function PlayerPersonnelLabel(player) {
                _super.call(this);
                this.player = player;
                this.initialize(this.player.field, this.player);
                this.layer.type = Common.Enums.LayerTypes.PlayerPersonnelLabel;
                this.selectable = false;
                this.graphics.snapping = false;
                this.graphics.setOffsetXY(0, -(this.player.graphics.dimensions.getHeight() / 2) * 0.1);
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
            }
            PlayerPersonnelLabel.prototype.draw = function () {
                this.graphics.text(this.player.position.label);
                this.graphics.setAttribute('class', 'no-highlight');
            };
            return PlayerPersonnelLabel;
        })(Common.Models.FieldElement);
        Models.PlayerPersonnelLabel = PlayerPersonnelLabel;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlayerIndexLabel = (function (_super) {
            __extends(PlayerIndexLabel, _super);
            function PlayerIndexLabel(player) {
                _super.call(this);
                this.player = player;
                this.initialize(this.player.field, this.player);
                this.layer.type = Common.Enums.LayerTypes.PlayerIndexLabel;
                this.selectable = false;
                this.graphics.snapping = false;
                this.graphics.setOffsetXY(0, (this.player.graphics.dimensions.getHeight() / 2) * 0.6);
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.player));
            }
            PlayerIndexLabel.prototype.draw = function () {
                this.graphics.text((this.player.position.index).toString());
                this.graphics.setAttribute('class', 'no-highlight');
            };
            return PlayerIndexLabel;
        })(Common.Models.FieldElement);
        Models.PlayerIndexLabel = PlayerIndexLabel;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Route = (function (_super) {
            __extends(Route, _super);
            function Route(dragInitialized) {
                _super.call(this);
                this.dragInitialized = dragInitialized === true;
                this.type = Common.Enums.RouteTypes.Generic;
                this.flippable = true;
                this.unitType = Team.Enums.UnitTypes.Other;
            }
            Route.prototype.setPlayer = function (player) {
                this.player = player;
                this.unitType = this.player.unitType;
                this.initialize(this.player.field, this.player);
                this.graphics.initializePlacement(this.player.graphics.placement);
                if (this.player) {
                    this.nodes = new Common.Models.LinkedList();
                    var self_3 = this;
                    this.nodes.onModified(function () {
                        self_3.setModified(true);
                    });
                }
                /**
                 * Add layer to Player layers
                 * @type {[type]}
                 */
                this.layer.type = Common.Enums.LayerTypes.PlayerRoute;
            };
            Route.prototype.fromJson = function (json) {
                if (Common.Utilities.isNullOrUndefined(this.player))
                    throw new Error('Route fromJson(): setPlayer() must be called before serializing from json');
                this.guid = json.guid;
                this.type = json.type;
                this.unitType = json.unitType;
                // initialize route nodes
                if (json.nodes) {
                    // Don't listen to changes while initializing the nodes list
                    // (performance issue)
                    this.nodes.listen(false);
                    for (var i = 0; i < json.nodes.length; i++) {
                        var rawNode = json.nodes[i];
                        var relativeCoords = new Common.Models.RelativeCoordinates(0, 0, this.player);
                        if (Common.Utilities.isNotNullOrUndefined(rawNode.relative)) {
                            relativeCoords.fromJson(rawNode.relative);
                        }
                        var routeNode = null;
                        switch (rawNode.renderType) {
                            case Common.Enums.RenderTypes.Preview:
                                routeNode = new Playbook.Models.PreviewRouteNode(relativeCoords, rawNode.type);
                                break;
                            case Common.Enums.RenderTypes.Editor:
                                routeNode = new Playbook.Models.EditorRouteNode(relativeCoords, rawNode.type);
                                break;
                        }
                        routeNode.initialize(this.field, this);
                        routeNode.fromJson(rawNode);
                        // shitty temp fix
                        if (i == 0) {
                            routeNode.layer.toBack();
                            routeNode.disable();
                        }
                        this.addNode(routeNode, false);
                    }
                    // start listening for changes in the nodes list again
                    // (performance issue)
                    this.nodes.listen(true);
                }
            };
            Route.prototype.toJson = function () {
                return {
                    nodes: this.nodes.toJson(),
                    type: this.type,
                    guid: this.guid,
                    unitType: this.unitType
                };
            };
            Route.prototype.remove = function () {
                this.routePath.remove();
                this.nodes.forEach(function (node, index) {
                    node.layer.remove();
                });
            };
            Route.prototype.draw = function () {
                if (!this.player) {
                    throw new Error('Route player is not set');
                }
                this.routePath.pathString = this.getMixedStringFromNodes(this.nodes.toArray());
                this.routePath.draw();
                // ensure the route nodes are above the route path
                this.bringNodesToFront();
                this.player.assignment.updateRouteArray();
            };
            Route.prototype.drawCurve = function (node) {
                if (!this.player) {
                    throw new Error('Route player is not set');
                }
                if (node) {
                }
                // update path
                this.routePath.pathString = this.getCurveStringFromNodes(true, this.nodes.toArray());
                this.routePath.draw();
                // ensure the route nodes are above the route path
                this.bringNodesToFront();
            };
            Route.prototype.drawLine = function () {
                if (!this.player) {
                    throw new Error('Route player is not set');
                }
                this.routePath.pathString = this.getPathStringFromNodes(true, this.nodes.toArray());
                this.routePath.draw();
                // ensure the route nodes are above the route path
                this.bringNodesToFront();
            };
            Route.prototype.bringNodesToFront = function () {
                this.nodes.forEach(function (routeNode) {
                    routeNode.layer.toFront();
                });
                // move the route back so it's behind the player
                this.player.layer.toFront();
                // Fack! just do what I SAY!!!
                this.routePath.layer.toBack();
            };
            Route.prototype.addNode = function (routeNode, render) {
                if (this.nodes.isEmpty() && (routeNode.type != Common.Enums.RouteNodeTypes.Root &&
                    routeNode.type != Common.Enums.RouteNodeTypes.CurveStart)) {
                    throw new Error('Route addNode(): first route node must be of type Root or CurveStart');
                }
                this.nodes.add(routeNode);
                routeNode.draw();
                if (routeNode.type == Common.Enums.RouteNodeTypes.Root)
                    this.disableRootNode(routeNode);
                this.draw();
                return routeNode;
            };
            Route.prototype.disableRootNode = function (routeNode) {
                // ...then update its graphical info
                routeNode.layer.toBack();
                routeNode.layer.hide();
                routeNode.disable();
            };
            Route.prototype.getLastNode = function () {
                //return this.nodes.getLast<Common.Models.FieldElement>();
                return null;
            };
            Route.prototype.flip = function () {
                this.nodes.forEach(function (routeNode) {
                    routeNode.flip();
                });
                this.flipped = !this.flipped;
                this.draw();
            };
            Route.prototype.getMixedStringFromNodes = function (nodeArray) {
                if (!nodeArray || nodeArray.length <= 1) {
                    return '';
                }
                var str = '';
                for (var i = 0; i < nodeArray.length; i++) {
                    var routeNode = nodeArray[i];
                    if (Common.Utilities.isNullOrUndefined(routeNode))
                        continue;
                    if (!routeNode.next) {
                        // just in case
                        break;
                    }
                    // must always have at least 2 nodes
                    var type = routeNode.type;
                    var nextType = routeNode.next.type;
                    if (type == Common.Enums.RouteNodeTypes.CurveStart) {
                        if (nextType != Common.Enums.RouteNodeTypes.CurveControl) {
                            throw new Error('A curve start node must be followed by a curve control node');
                        }
                        // Good: next node is curve control
                        // check for 2 subsequent nodes
                        if (!routeNode.next.next) {
                            throw new Error('a curve must have a control and end node');
                        }
                        var endType = routeNode.next.next.type;
                        if (endType != Common.Enums.RouteNodeTypes.CurveEnd) {
                            throw new Error('A curve must end with a curve end node');
                        }
                        str += this.getCurveStringFromNodes(true, [
                            routeNode,
                            routeNode.next,
                            routeNode.next.next // next (end)
                        ]);
                        i++;
                    }
                    else if (type == Common.Enums.RouteNodeTypes.CurveEnd) {
                        if (i == 0) {
                            throw new Error('curveEnd node cannot be the first node');
                        }
                        if (nextType == Common.Enums.RouteNodeTypes.CurveControl) {
                            // check for 2 subsequent nodes
                            if (!routeNode.next.next) {
                                throw new Error('a curve must have a control and end node');
                            }
                            var endType = routeNode.next.next.type;
                            if (endType != Common.Enums.RouteNodeTypes.CurveEnd) {
                                throw new Error('A curve must end with a curve end node');
                            }
                            str += this.getCurveStringFromNodes(false, [
                                routeNode,
                                routeNode.next,
                                routeNode.next.next // next (end)
                            ]);
                            i++;
                        }
                        else {
                            // next node is normal node
                            str += this.getPathStringFromNodes(false, [
                                routeNode,
                                routeNode.next
                            ]);
                        }
                    }
                    else {
                        // assuming we are drawing a straight path
                        str += this.getPathStringFromNodes(i == 0, [
                            routeNode,
                            routeNode.next
                        ]);
                    }
                }
                return str;
            };
            Route.prototype.getPathStringFromNodes = function (initialize, nodeArray) {
                return Common.Drawing.Utilities.getPathString(initialize, this._prepareNodesForPath(nodeArray));
            };
            Route.prototype.getCurveStringFromNodes = function (initialize, nodeArray) {
                return Common.Drawing.Utilities.getCurveString(initialize, this._prepareNodesForPath(nodeArray));
            };
            Route.prototype._prepareNodesForPath = function (nodeArray) {
                var coords = [];
                for (var i = 0; i < nodeArray.length; i++) {
                    var routeNode = nodeArray[i];
                    if (Common.Utilities.isNullOrUndefined(routeNode))
                        continue;
                    coords.push(routeNode.graphics.location.ax, routeNode.graphics.location.ay);
                }
                return coords;
            };
            return Route;
        })(Common.Models.FieldElement);
        Models.Route = Route;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RouteAction = (function (_super) {
            __extends(RouteAction, _super);
            function RouteAction(action) {
                _super.call(this);
                this.action = action;
            }
            RouteAction.prototype.initialize = function (field, routeNode) {
                _super.prototype.initialize.call(this, field, routeNode);
                this.routeNode = routeNode;
                this.disabled = this.routeNode.type == Common.Enums.RouteNodeTypes.CurveControl;
                this.layer.type = Common.Enums.LayerTypes.PlayerRouteAction;
                this.graphics.setOffsetXY(0.5, 0.5);
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.routeNode));
            };
            RouteAction.prototype.draw = function () {
                Common.Factories.RouteActionFactory.draw(this);
            };
            RouteAction.prototype.toJson = function () {
                return $.extend({
                    action: this.action
                }, _super.prototype.toJson.call(this));
            };
            RouteAction.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.action = json.action;
                _super.prototype.fromJson.call(this, json);
            };
            return RouteAction;
        })(Common.Models.FieldElement);
        Models.RouteAction = RouteAction;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RouteCollection = (function (_super) {
            __extends(RouteCollection, _super);
            function RouteCollection() {
                _super.call(this);
            }
            RouteCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            RouteCollection.prototype.fromJson = function (routes) {
                return;
            };
            return RouteCollection;
        })(Common.Models.Collection);
        Models.RouteCollection = RouteCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RouteControlPath = (function (_super) {
            __extends(RouteControlPath, _super);
            function RouteControlPath() {
                _super.call(this);
            }
            RouteControlPath.prototype.initialize = function (field, routeNode) {
                _super.prototype.initialize.call(this, field, routeNode);
                this.routeNode = routeNode;
                this.layer.type = Common.Enums.LayerTypes.PlayerRouteControlPath;
                this.graphics.setStroke('grey');
                this.graphics.setStrokeWidth(1);
                this.graphics.setOpacity(0.2);
                this.graphics.initializePlacement(new Common.Models.Placement(0, 0, this.routeNode));
            };
            RouteControlPath.prototype.toJson = function () {
                return {
                    pathString: this.pathString
                };
            };
            RouteControlPath.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.pathString = json.pathString;
            };
            RouteControlPath.prototype.draw = function () {
                // TODO @theBull - implement
                // let startNode, controlNode, endNode;
                // if (this.routeNode.type == Common.Enums.RouteNodeTypes.CurveControl) {
                //     if (!this.routeNode.node.next || !this.routeNode.node.prev) {
                //         throw new Error('controlNode does not have next and prev nodes');
                //     }
                //     startNode = this.routeNode.node.prev.data;
                //     controlNode = this;
                //     endNode = this.routeNode.node.next.data;
                // }
                // else if (this.routeNode.type == Common.Enums.RouteNodeTypes.CurveEnd) {
                //     if (!this.routeNode.node.prev || !this.routeNode.node.prev.prev) {
                //         throw new Error(['endNode node does not have previous controlNode or previous',
                //             'curve startNode nodes'].join(''));
                //     }
                //     startNode = this.routeNode.node.prev.prev.data;
                //     controlNode = this.routeNode.node.prev.data;
                //     endNode = this;
                // }
                // else if (this.routeNode.type == Common.Enums.RouteNodeTypes.CurveStart) {
                //     if (!this.routeNode.node.next || !this.routeNode.node.next.next) {
                //         throw new Error(['curve startNode node does not have subsequent',
                //             'controlNode and endNode nodes'].join(''));
                //     }
                //     startNode = this;
                //     controlNode = this.routeNode.node.next.data;
                //     endNode = this.routeNode.node.next.next.data;
                // }
                // // Generate a path string between the given startNode, controlNode, and endNode nodes
                // this.pathString = this.routeNode.player.route.getPathStringFromNodes(true, [startNode, controlNode, endNode]);
                // startNode.graphics.path(this.pathString);
            };
            return RouteControlPath;
        })(Common.Models.FieldElement);
        Models.RouteControlPath = RouteControlPath;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RouteNode = (function (_super) {
            __extends(RouteNode, _super);
            function RouteNode(relativeCoordinates, type) {
                _super.call(this);
                if (Common.Utilities.isNullOrUndefined(relativeCoordinates))
                    throw new Error('RouteNode constructor(): RelativeCoordinates is null or undefined');
                this.relativeCoordinates = relativeCoordinates;
                this.type = type;
                this.flippable = true;
            }
            RouteNode.prototype.initialize = function (field, route) {
                _super.prototype.initialize.call(this, field, this.relativeCoordinates.relativeElement);
                this.route = route;
                this.graphics.initializePlacement(new Common.Models.Placement(this.relativeCoordinates.rx, this.relativeCoordinates.ry, this.relativeElement));
                this.graphics.dimensions.radius = this.grid.getSize() / 3.5;
                this.graphics.dimensions.width = this.graphics.dimensions.radius * 2;
                this.graphics.dimensions.height = this.graphics.dimensions.radius * 2;
                this.layer.type = Common.Enums.LayerTypes.PlayerRouteNode;
            };
            RouteNode.prototype.draw = function () {
                this.graphics.circle();
            };
            RouteNode.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.routeAction.fromJson(json.routeAction);
                this.type = json.type;
                this.renderType = json.renderType;
                this.relativeCoordinates.fromJson(json.relative);
            };
            RouteNode.prototype.toJson = function () {
                return {
                    relative: this.graphics.placement.relative.toJson(),
                    type: this.type,
                    routeAction: this.routeAction.toJson(),
                    renderType: this.renderType,
                    guid: this.guid
                };
            };
            RouteNode.prototype.isCurveNode = function () {
                return this.type == Common.Enums.RouteNodeTypes.CurveControl ||
                    this.type == Common.Enums.RouteNodeTypes.CurveEnd ||
                    this.type == Common.Enums.RouteNodeTypes.CurveStart;
            };
            RouteNode.prototype.setAction = function (action) {
                this.routeAction.action = action;
                this.routeAction.draw();
                // route node has been modified
                this.setModified();
            };
            RouteNode.prototype.flip = function () {
                this.graphics.flip(true);
                this.flipped = !this.flipped;
            };
            return RouteNode;
        })(Common.Models.FieldElement);
        Models.RouteNode = RouteNode;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RoutePath = (function (_super) {
            __extends(RoutePath, _super);
            function RoutePath() {
                _super.call(this);
            }
            RoutePath.prototype.initialize = function (field, route) {
                _super.prototype.initialize.call(this, field, route);
                this.route = route;
                this.unitType = this.route.unitType;
                this.graphics.setOriginalFill(null);
                this.graphics.setOriginalOpacity(1);
                switch (this.unitType) {
                    case Team.Enums.UnitTypes.Offense:
                        this.graphics.setOriginalStroke('#001199');
                        break;
                    case Team.Enums.UnitTypes.Defense:
                        this.graphics.setOriginalStroke('#0063FF');
                        break;
                    case Team.Enums.UnitTypes.SpecialTeams:
                        this.graphics.setOriginalStroke('black');
                        break;
                    case Team.Enums.UnitTypes.Other:
                        this.graphics.setOriginalStroke('#333333');
                        break;
                    default:
                        this.graphics.setOriginalStroke('#22B98F');
                        break;
                }
                this.graphics.setOriginalStrokeWidth(3);
                this.graphics.initializePlacement(this.route.graphics.placement);
                this.layer.type = Common.Enums.LayerTypes.PlayerRoutePath;
            };
            RoutePath.prototype.toJson = function () {
                return {
                    pathString: this.pathString
                };
            };
            RoutePath.prototype.remove = function () {
                this.layer.remove();
            };
            RoutePath.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.pathString = json.pathString;
            };
            /**
             * Draws a RoutePath graphic onto the paper;
             * NOTE: assumes the pathString is already set to a valid SVG path string
             */
            RoutePath.prototype.draw = function () {
                this.graphics.path(this.pathString);
                this.graphics.setAttribute('class', 'painted-fill');
            };
            return RoutePath;
        })(Common.Models.FieldElement);
        Models.RoutePath = RoutePath;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Placement = (function (_super) {
            __extends(Placement, _super);
            function Placement(rx, ry, relativeElement, index) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.updateFromRelative(rx, ry, relativeElement);
                this.flipped = false;
                this.index = index >= 0 ? index : -1;
                //this.onModified(function() {});
            }
            Placement.prototype.copy = function (newPlacement) {
                var copyPlacement = newPlacement || new Common.Models.Placement(this.relative.rx, this.relative.ry, this.relativeElement);
                return _super.prototype.copy.call(this, copyPlacement, this);
            };
            Placement.prototype.toJson = function () {
                return {
                    relative: this.relative.toJson(),
                    coordinates: this.coordinates.toJson(),
                    index: this.index,
                    guid: this.guid
                };
            };
            Placement.prototype.fromJson = function (json) {
                this.relative.fromJson(json.relative);
                this.coordinates.fromJson(json.coordinates);
                this.index = json.index;
                this.guid = json.guid;
            };
            Placement.prototype.setRelativeElement = function (relativeElement) {
                if (Common.Utilities.isNotNullOrUndefined(relativeElement)) {
                    this.relative.relativeElement = relativeElement;
                    this.relativeElement = relativeElement;
                    this.grid = this.relativeElement.grid;
                }
            };
            Placement.prototype.update = function (placement) {
                if (Common.Utilities.isNullOrUndefined(placement))
                    return;
                this.setRelativeElement(placement.relativeElement);
                this.fromJson(placement.toJson());
            };
            Placement.prototype.updateFromAbsolute = function (ax, ay) {
                if (Common.Utilities.isNullOrUndefined(this.grid))
                    throw new Error('Placement updateFromAbsolute(): grid is null or undefined');
                var coords = this.grid.getCoordinatesFromAbsolute(ax, ay);
                this.relative.updateFromGridCoordinates(coords.x, coords.y);
                this.coordinates.update(coords.x, coords.y);
            };
            Placement.prototype.updateFromCoordinates = function (x, y) {
                this.coordinates.update(x, y);
                this.relative.updateFromGridCoordinates(this.coordinates.x, this.coordinates.y);
            };
            Placement.prototype.updateFromRelative = function (rx, ry, relativeElement) {
                if (!relativeElement) {
                    this.coordinates = new Common.Models.Coordinates(rx, ry);
                    this.relative = new Common.Models.RelativeCoordinates(0, 0, null);
                    this.relativeElement = null;
                    this.grid = null;
                }
                else {
                    this.relativeElement = relativeElement;
                    this.grid = this.relativeElement.grid;
                    this.relative = new Common.Models.RelativeCoordinates(rx, ry, this.relativeElement);
                    this.coordinates = this.relative.getCoordinates();
                }
            };
            Placement.prototype.flip = function () {
                this.updateFromRelative(this.relative.rx * -1, this.relative.ry * -1, this.relativeElement);
                this.flipped = !this.flipped;
            };
            return Placement;
        })(Common.Models.Modifiable);
        Models.Placement = Placement;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var PlacementCollection = (function (_super) {
            __extends(PlacementCollection, _super);
            function PlacementCollection() {
                _super.call(this);
                this.flipped = false;
            }
            PlacementCollection.prototype.fromJson = function (placements) {
                if (!placements)
                    return;
                var self = this;
                this.empty();
                for (var i = 0; i < placements.length; i++) {
                    var rawPlacement = placements[i];
                    var placementModel = new Common.Models.Placement(0, 0, null);
                    placementModel.fromJson(rawPlacement);
                    this.add(placementModel);
                }
                this.forEach(function (placement, index) {
                    placement.onModified(function () {
                        console.log('placement collection modified: placement:', placement.guid);
                        self.setModified(true);
                    });
                });
                this.setModified(true);
            };
            PlacementCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            PlacementCollection.prototype.flip = function () {
                if (this.hasElements()) {
                    this.forEach(function (placement, index) {
                        placement.flip();
                    });
                    this.flipped = !this.flipped;
                }
            };
            return PlacementCollection;
        })(Common.Models.Collection);
        Models.PlacementCollection = PlacementCollection;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Coordinates = (function (_super) {
            __extends(Coordinates, _super);
            // public ax: number;
            // public ay: number;
            // public ox: number;
            // public oy: number;
            // public dx: number;
            // public dy: number;
            // x/y are grid coords
            function Coordinates(x, y) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.x = x;
                this.y = y;
                //this.onModified(function() { });
            }
            Coordinates.prototype.toJson = function () {
                return {
                    x: this.x,
                    y: this.y
                };
            };
            Coordinates.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.x = json.x;
                this.y = json.y;
            };
            Coordinates.prototype.update = function (x, y) {
                this.x = x;
                this.y = y;
                //this.setModified(true);
            };
            /**
             * Gets the relative coordinates from this' coordinates TO the given coordinates.
             * Example: An element 3 grid squares to the right of 'this' would result in an x value of -3
             * @param {Common.Models.Coordinates}       coords  [description]
             * @param {Common.Interfaces.IFieldElement} element [description]
             */
            Coordinates.prototype.getRelativeTo = function (coords, element) {
                return new Common.Models.RelativeCoordinates(coords.x - this.x, this.y - coords.y, element);
            };
            return Coordinates;
        })(Common.Models.Modifiable);
        Models.Coordinates = Coordinates;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RelativeCoordinates = (function (_super) {
            __extends(RelativeCoordinates, _super);
            function RelativeCoordinates(rx, ry, relativeElement) {
                _super.call(this);
                this.rx = rx;
                this.ry = ry;
                if (relativeElement) {
                    this.relativeElement = relativeElement;
                    this.distance = this.getDistance();
                    this.theta = this.getTheta();
                }
                else {
                    this.relativeElement = null;
                    this.distance = 0;
                    this.theta = 0;
                }
            }
            RelativeCoordinates.prototype.drop = function () {
            };
            RelativeCoordinates.prototype.toJson = function () {
                return {
                    rx: this.rx,
                    ry: this.ry
                };
            };
            RelativeCoordinates.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.rx = json.rx;
                this.ry = json.ry;
            };
            RelativeCoordinates.prototype.getDistance = function () {
                if (Common.Utilities.isNullOrUndefined(this.relativeElement))
                    return null;
                return this.relativeElement ? Common.Drawing.Utilities.distance(this.rx, this.ry, this.relativeElement.graphics.placement.coordinates.x, this.relativeElement.graphics.placement.coordinates.y) : null;
            };
            RelativeCoordinates.prototype.getTheta = function () {
                if (Common.Utilities.isNullOrUndefined(this.relativeElement))
                    return null;
                return this.relativeElement ? Common.Drawing.Utilities.theta(this.rx, this.ry, this.relativeElement.graphics.placement.coordinates.x, this.relativeElement.graphics.placement.coordinates.y) : null;
            };
            RelativeCoordinates.prototype.updateFromGridCoordinates = function (x, y) {
                if (Common.Utilities.isNullOrUndefined(this.relativeElement))
                    return;
                this.rx = x - this.relativeElement.graphics.placement.coordinates.x;
                this.ry = this.relativeElement.graphics.placement.coordinates.y - y;
            };
            RelativeCoordinates.prototype.updateFromAbsoluteCoordinates = function (ax, ay) {
                // snap absolute coordinates to grid coordinates first...
                var gridCoords = this.relativeElement.grid.getCoordinatesFromAbsolute(ax, ay);
                this.updateFromGridCoordinates(gridCoords.x, gridCoords.y);
            };
            /**
             * Takes a set of relative x,y coordinates and returns the exact grid
             * coordinates; assumes the rx/ry values passed in are value grid coordinates
             *
             * @param  {number}                    rx relative x (grid coordinate)
             * @param  {number}                    ry relative y (grid coordinate)
             * @return {Common.Models.Coordinates}    The calculated coordinate
             */
            RelativeCoordinates.prototype.getCoordinatesFromRelative = function (rx, ry) {
                if (Common.Utilities.isNullOrUndefined(this.relativeElement))
                    return null;
                return new Common.Models.Coordinates(this.relativeElement.graphics.placement.coordinates.x + rx, this.relativeElement.graphics.placement.coordinates.y - ry);
            };
            RelativeCoordinates.prototype.getCoordinates = function () {
                var self = this;
                return new Common.Models.Coordinates(this.relativeElement.graphics.placement.coordinates.x + self.rx, this.relativeElement.graphics.placement.coordinates.y - self.ry);
            };
            return RelativeCoordinates;
        })(Common.Models.Storable);
        Models.RelativeCoordinates = RelativeCoordinates;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Location = (function (_super) {
            __extends(Location, _super);
            function Location(ax, ay) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.ax = ax;
                this.ay = ay;
                this.ox = this.ax;
                this.oy = this.ay;
                this.dx = 0;
                this.dy = 0;
                //this.onModified(function() { });
            }
            Location.prototype.toJson = function () {
                return {
                    ax: this.ax,
                    ay: this.ay,
                    ox: this.ox,
                    oy: this.oy,
                    dx: this.dx,
                    dy: this.dy
                };
            };
            Location.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.ax = json.ax;
                this.ay = json.ay;
                this.ox = json.ox;
                this.oy = json.oy;
                this.dx = json.dx;
                this.dy = json.dy;
            };
            Location.prototype.drop = function () {
                this.ox = this.ax;
                this.oy = this.ay;
                this.dx = 0;
                this.dy = 0;
            };
            Location.prototype.moveByDelta = function (dx, dy) {
                this.dx = dx;
                this.dy = dy;
                this.ax = this.ox + this.dx;
                this.ay = this.oy + this.dy;
                //this.setModified(true);
            };
            Location.prototype.updateFromAbsolute = function (ax, ay) {
                this.ax = Common.Utilities.isNullOrUndefined(ax) ? this.ax : ax;
                this.ay = Common.Utilities.isNullOrUndefined(ay) ? this.ay : ay;
                this.dx = 0;
                this.dy = 0;
                this.ox = this.ax;
                this.oy = this.ay;
                //this.setModified(true);
            };
            Location.prototype.hasChanged = function () {
                return Math.abs(this.dx) > 0 || Math.abs(this.dy) > 0;
            };
            return Location;
        })(Common.Models.Modifiable);
        Models.Location = Location;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Graphics = (function (_super) {
            __extends(Graphics, _super);
            function Graphics(paper) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.paper = paper;
                this.grid = paper.grid;
                this.placement = null; // new Common.Models.Placement(0, 0);
                this.location = new Common.Models.Location(0, 0);
                this.dimensions = new Common.Models.Dimensions();
                this.containment = new Common.Models.Containment(0, this.grid.getWidth(), 0, this.grid.getHeight());
                this.originalFill = 'white';
                this.originalStroke = 'black';
                this.originalOpacity = 1;
                this.originalFillOpacity = 1;
                this.originalStrokeWidth = 1;
                this.fill = this.originalFill;
                this.fillOpacity = this.originalFillOpacity;
                this.stroke = this.originalStroke;
                this.opacity = this.originalOpacity;
                this.strokeWidth = this.originalStrokeWidth;
                this.selectedFill = 'white';
                this.selectedFillOpacity = 1;
                this.selectedStroke = 'red';
                this.selectedOpacity = 1;
                this.disabledFill = '#aaaaaa';
                this.disabledFillOpacity = 1;
                this.disabledStroke = '#777777';
                this.disabledOpacity = 0.5;
                this.hoverOpacity = 0.4;
                this.hoverFillOpacity = 0.4;
                this.font = this.paper.drawing.getFont('Arial');
                this.drawingHandler = new Common.Models.DrawingHandler(this);
                this.set = new Common.Models.GraphicsSet(this);
                this.snapping = true;
            }
            Graphics.prototype.toJson = function () {
                return {
                    dimensions: this.dimensions.toJson(),
                    opacity: this.opacity,
                    fill: this.fill,
                    fillOpacity: this.fillOpacity,
                    stroke: this.stroke,
                    strokeWidth: this.strokeWidth,
                    originalOpacity: this.originalOpacity,
                    originalFill: this.originalFill,
                    originalFillOpacity: this.originalFillOpacity,
                    originalStroke: this.originalStroke,
                    originalStrokeWidth: this.originalStrokeWidth,
                    selectedFill: this.selectedFill,
                    selectedFillOpacity: this.selectedFillOpacity,
                    selectedStroke: this.selectedStroke,
                    selectedOpacity: this.selectedOpacity,
                    disabledFillOpacity: this.disabledFillOpacity,
                    disabledStroke: this.disabledStroke,
                    disabledOpacity: this.disabledOpacity,
                    hoverOpacity: this.hoverOpacity,
                    hoverFillOpacity: this.hoverFillOpacity,
                    placement: this.placement ? this.placement.toJson() : null,
                    location: this.location ? this.location.toJson() : null
                };
            };
            Graphics.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.dimensions.fromJson(json.dimensions);
                this.opacity = json.opacity;
                this.fill = json.fill;
                this.fillOpacity = json.fillOpacity;
                this.stroke = json.stroke;
                this.strokeWidth = json.strokeWidth;
                this.placement.fromJson(json.placement);
                this.location.fromJson(json.location);
                this.originalOpacity = json.originalOpacity;
                this.originalFill = json.originalFill;
                this.originalFillOpacity = json.originalFillOpacity;
                this.originalStroke = json.originalStroke;
                this.originalStrokeWidth = json.originalStrokeWidth;
                this.selectedFill = json.selectedFill;
                this.selectedFillOpacity = json.selectedFillOpacity;
                this.selectedStroke = json.selectedStroke;
                this.selectedOpacity = json.selectedOpacity;
                this.disabledFill = json.disabledFill;
                this.disabledFillOpacity = json.disabledFillOpacity;
                this.disabledStroke = json.disabledStroke;
                this.disabledOpacity = json.disabledOpacity;
                this.hoverOpacity = json.hoverOpacity;
                this.hoverFillOpacity = json.hoverFillOpacity;
            };
            /**
             * Alias for hasRaphael()
             * @return {boolean} [description]
             */
            Graphics.prototype.hasGraphics = function () {
                return this.hasRaphael();
            };
            Graphics.prototype.hasRaphael = function () {
                return this.raphael != null && this.raphael != undefined;
            };
            Graphics.prototype.hasSet = function () {
                return Common.Utilities.isNotNullOrUndefined(this.set);
            };
            Graphics.prototype.getFill = function () {
                return this.fill;
            };
            Graphics.prototype.setFill = function (fill) {
                this.fill = fill;
                return this.attr({ 'fill': this.fill });
            };
            Graphics.prototype.setOriginalFill = function (fill) {
                this.setFill(fill);
                this.originalFill = fill;
                return this;
            };
            Graphics.prototype.getFillOpacity = function () {
                return this.fillOpacity;
            };
            Graphics.prototype.setFillOpacity = function (opacity) {
                if (opacity > 1 || opacity < 0)
                    throw new Error('Graphics setFillOpacity(): opacity must be between 0 and 1');
                this.fillOpacity = opacity;
                return this.attr({ 'fill-opacity': this.fillOpacity });
            };
            Graphics.prototype.setOriginalFillOpacity = function (opacity) {
                this.setFillOpacity(opacity);
                this.originalFillOpacity = opacity;
                return this;
            };
            Graphics.prototype.getSelectedFill = function () {
                return this.selectedFill;
            };
            Graphics.prototype.setSelectedFill = function (fill) {
                this.selectedFill = fill;
                return this;
            };
            Graphics.prototype.getSelectedFillOpacity = function () {
                return this.selectedFillOpacity;
            };
            Graphics.prototype.setSelectedFillOpacity = function (opacity) {
                this.selectedFillOpacity = opacity;
                return this;
            };
            Graphics.prototype.getStroke = function () {
                return this.stroke;
            };
            Graphics.prototype.setStroke = function (stroke) {
                this.stroke = stroke;
                return this.attr({ 'stroke': this.stroke });
            };
            Graphics.prototype.setOriginalStroke = function (stroke) {
                this.setStroke(stroke);
                this.originalStroke = stroke;
                return this;
            };
            Graphics.prototype.setSelectedStroke = function (stroke) {
                this.setStroke(stroke);
                this.selectedStroke = stroke;
                return this;
            };
            Graphics.prototype.getStrokeWidth = function () {
                return this.strokeWidth;
            };
            Graphics.prototype.setStrokeWidth = function (width) {
                this.strokeWidth = width;
                return this.attr({ 'stroke-width': this.strokeWidth });
            };
            Graphics.prototype.setOriginalStrokeWidth = function (width) {
                this.setStrokeWidth(width);
                this.originalStrokeWidth = width;
                return this;
            };
            Graphics.prototype.setHoverOpacity = function (opacity) {
                if (opacity < 0 || opacity > 1)
                    throw new Error('Graphics setHoverOpacity(): opacity must be between 0 and 1, inclusive');
                this.hoverOpacity = opacity;
                return this;
            };
            Graphics.prototype.setHoverFillOpacity = function (opacity) {
                if (opacity < 0 || opacity > 1)
                    throw new Error('Graphics setHoverFillOpacity(): opacity must be between 0 and 1, inclusive');
                this.hoverFillOpacity = opacity;
                return this;
            };
            Graphics.prototype.setHeight = function (height) {
                this.dimensions.setHeight(height);
                return this.attr({ 'height': height });
            };
            /**
             * Gets the current opacity
             * @return {number} [description]
             */
            Graphics.prototype.getOpacity = function () {
                return this.opacity;
            };
            Graphics.prototype.setOpacity = function (opacity) {
                if (opacity > 1 || opacity < 0)
                    throw new Error('Graphics setOpacity(): opacity must be between 0 and 1');
                var self = this;
                this.opacity = opacity;
                return this.attr({ 'opacity': opacity });
            };
            Graphics.prototype.setOriginalOpacity = function (opacity) {
                this.setOpacity(opacity);
                this.originalOpacity = opacity;
                return this;
            };
            /**
             * Toggles the opacity for show/hide effect
             */
            Graphics.prototype.toggleOpacity = function () {
                this.setOpacity(this.opacity == this.originalOpacity ?
                    this.hoverOpacity : this.originalOpacity);
                this.setFillOpacity(this.fillOpacity == this.originalFillOpacity ?
                    this.hoverFillOpacity : this.originalFillOpacity);
            };
            Graphics.prototype.select = function () {
                this.fill = this.selectedFill;
                this.stroke = this.selectedStroke;
                this.opacity = this.selectedOpacity;
                this.fillOpacity = this.selectedFillOpacity;
                var self = this;
                this.attr({
                    'fill': self.fill,
                    'fill-opacity': self.fillOpacity,
                    'stroke': self.stroke,
                    'opacity': self.opacity
                });
            };
            /**
             * Generic deselection method
             */
            Graphics.prototype.deselect = function () {
                this.fill = this.originalFill;
                this.stroke = this.originalStroke;
                this.opacity = this.originalOpacity;
                this.fillOpacity = this.originalFillOpacity;
                var self = this;
                this.attr({
                    'fill': self.fill,
                    'fill-opacity': self.fillOpacity,
                    'stroke': self.stroke,
                    'opacity': self.opacity
                });
            };
            /**
             * Generic disable method
             */
            Graphics.prototype.disable = function () {
                this.fill = this.disabledFill;
                this.stroke = this.disabledStroke;
                this.opacity = this.disabledOpacity;
                this.fillOpacity = this.disabledFillOpacity;
                var self = this;
                this.attr({
                    'fill': self.fill,
                    'fill-opacity': self.fillOpacity,
                    'stroke': self.stroke,
                    'opacity': self.opacity
                });
            };
            /**
             * Generic enable method
             */
            Graphics.prototype.enable = function () {
                this.fill = this.originalFill;
                this.stroke = this.originalStroke;
                this.opacity = this.originalOpacity;
                this.fillOpacity = this.originalFillOpacity;
                var self = this;
                this.attr({
                    'fill': self.fill,
                    'fill-opacity': self.fillOpacity,
                    'stroke': self.stroke,
                    'opacity': self.opacity
                });
            };
            Graphics.prototype.setContainment = function (left, right, top, bottom) {
                this.containment.left = left;
                this.containment.right = right;
                this.containment.top = top;
                this.containment.bottom = bottom;
            };
            Graphics.prototype.getCoordinates = function () {
                return this.placement.coordinates;
            };
            /**
             * Returns whether the given difference in absolute x/y location
             * from the current absolute location is within the graphic's
             * containment area.
             *
             * @param  {number}  dx The potential move-to ax location
             * @param  {number}  dy The potential move-to ay location
             * @return {boolean}    true if the location to move to is within
             *                           the containment area
             */
            Graphics.prototype.canMoveByDelta = function (dx, dy) {
                return this.canMoveByDeltaX(dx) && this.canMoveByDeltaY(dy);
            };
            Graphics.prototype.canMoveByDeltaX = function (dx) {
                return this.containment.isContainedX(dx + this.dimensions.offset.x);
            };
            Graphics.prototype.canMoveByDeltaY = function (dy) {
                return this.containment.isContainedY(dy + this.dimensions.offset.y);
            };
            /**
             * [moveByDelta description]
             * @param {number} dx [description]
             * @param {number} dy [description]
             */
            Graphics.prototype.moveByDelta = function (dx, dy) {
                // Update graphical location
                if (Common.Utilities.isNotNullOrUndefined(this.location)) {
                    this.location.moveByDelta(dx, dy);
                    // Update placement when dropping
                    var coords = this.grid.getCoordinatesFromAbsolute(this.location.ax, this.location.ay);
                    if (Common.Utilities.isNotNullOrUndefined(this.placement)) {
                        this.placement.updateFromCoordinates(coords.x, coords.y);
                    }
                    // Transform (move to updateAbsolute/Coordinates methods?)
                    this.transform(this.location.dx, this.location.dy);
                }
            };
            Graphics.prototype.moveByDeltaX = function (dx) {
                if (this.canMoveByDeltaX(dx)) {
                    this.moveByDelta(dx, 0);
                }
            };
            Graphics.prototype.moveByDeltaY = function (dy) {
                if (this.canMoveByDeltaY(dy)) {
                    this.moveByDelta(0, dy);
                }
            };
            Graphics.prototype.hasLocation = function () {
                return Common.Utilities.isNotNullOrUndefined(this.location);
            };
            Graphics.prototype.hasPlacement = function () {
                return Common.Utilities.isNotNullOrUndefined(this.placement);
            };
            Graphics.prototype.setOffsetXY = function (x, y) {
                this.dimensions.setOffsetXY(x, y);
            };
            Graphics.prototype.initializePlacement = function (placement) {
                if (Common.Utilities.isNullOrUndefined(placement))
                    throw new Error('Graphics initializePlacement(): placement is null or undefined');
                if (Common.Utilities.isNullOrUndefined(this.placement)) {
                    this.placement = placement;
                }
                else {
                    this.placement.update(placement);
                }
                // ensure there is a grid established for the placement object
                if (Common.Utilities.isNullOrUndefined(this.placement.grid))
                    this.placement.grid = this.grid;
                var absCoords = this.grid.getAbsoluteFromCoordinates(this.placement.coordinates.x, this.placement.coordinates.y);
                this.location.updateFromAbsolute(absCoords.x + this.dimensions.offset.x, absCoords.y + this.dimensions.offset.y);
                this.refresh();
            };
            Graphics.prototype.updateFromAbsolute = function (ax, ay) {
                this.placement.updateFromAbsolute(ax, ay);
                this.location.updateFromAbsolute(ax, ay);
                this.refresh();
            };
            Graphics.prototype.updateFromRelative = function (rx, ry, relativeElement) {
                this.placement.updateFromRelative(rx, ry, relativeElement);
                var absCoords = this.grid.getAbsoluteFromCoordinates(this.placement.coordinates.x, this.placement.coordinates.y);
                this.location.updateFromAbsolute(absCoords.x + this.dimensions.offset.x, absCoords.y + this.dimensions.offset.y);
                this.refresh();
            };
            Graphics.prototype.updateFromCoordinates = function (x, y) {
                this.placement.updateFromCoordinates(x, y);
                var absCoords = this.grid.getAbsoluteFromCoordinates(this.placement.coordinates.x, this.placement.coordinates.y);
                this.location.updateFromAbsolute(absCoords.x, absCoords.y);
                this.refresh();
            };
            /**
             *
             * DRAWING METHODS
             *
             */
            Graphics.prototype.path = function (path) {
                this.remove();
                this.raphael = this.paper.drawing.path(path);
                this.refresh();
                return this;
            };
            Graphics.prototype.rect = function () {
                this.remove();
                this.raphael = this.paper.drawing.rect(this.placement.coordinates.x, this.placement.coordinates.y, this.dimensions.getWidth(), this.dimensions.getHeight(), false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                this.refresh();
                return this;
            };
            Graphics.prototype.rhombus = function () {
                this.remove();
                this.dimensions.rotation = -45;
                this.rect();
                return this;
            };
            Graphics.prototype.ellipse = function () {
                this.remove();
                this.raphael = this.paper.drawing.ellipse(this.placement.coordinates.x, this.placement.coordinates.y, this.dimensions.getWidth(), this.dimensions.getHeight(), false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                this.refresh();
                return this;
            };
            Graphics.prototype.circle = function () {
                this.remove();
                this.raphael = this.paper.drawing.circle(this.placement.coordinates.x, this.placement.coordinates.y, this.dimensions.getRadius(), false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                this.refresh();
                return this;
            };
            Graphics.prototype.triangle = function () {
                this.remove();
                this.raphael = this.paper.drawing.triangle(this.placement.coordinates.x, this.placement.coordinates.y, this.dimensions.getHeight(), false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                this.refresh();
                return this;
            };
            Graphics.prototype.text = function (text) {
                this.remove();
                this.raphael = this.paper.drawing.text(this.placement.coordinates.x, this.placement.coordinates.y, text, false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                return this;
            };
            Graphics.prototype.refresh = function () {
                if (!this.hasRaphael())
                    return;
                var attrs = {
                    x: this.location.ax,
                    y: this.location.ay,
                };
                if (this.getType() == 'circle') {
                    attrs['cx'] = this.location.ax;
                    attrs['cy'] = this.location.ay;
                }
                if (this.getType() != 'text') {
                    attrs['fill'] = this.fill;
                    attrs['fill-opacity'] = this.fillOpacity;
                    attrs['opacity'] = this.opacity;
                    attrs['stroke'] = this.stroke;
                    attrs['stroke-width'] = this.strokeWidth;
                }
                this.attr(attrs);
            };
            Graphics.prototype.toFront = function () {
                if (!this.hasRaphael())
                    return this;
                this.raphael.toFront();
                return this;
            };
            Graphics.prototype.toBack = function () {
                if (!this.hasRaphael())
                    return this;
                this.raphael.toBack();
                return this;
            };
            Graphics.prototype.attr = function (attrs) {
                if (!this.hasRaphael())
                    return;
                return this.raphael.attr(attrs);
            };
            Graphics.prototype.attrKeyValue = function (key, value) {
                if (!this.hasRaphael())
                    return;
                return this.raphael.attr(key, value);
            };
            Graphics.prototype.setAttribute = function (attribute, value) {
                if (!this.hasRaphael())
                    return;
                this.raphael.node.setAttribute(attribute, value);
            };
            Graphics.prototype.getBBox = function (isWithoutTransforms) {
                if (!this.hasRaphael())
                    return;
                return this.raphael.getBBox(isWithoutTransforms === true);
            };
            Graphics.prototype.transform = function (ax, ay) {
                if (!this.hasRaphael())
                    return;
                this.raphael.transform(['t', ax, ', ', ay, ' r', this.dimensions.rotation].join(''));
            };
            Graphics.prototype.resetTransform = function () {
                if (!this.hasRaphael())
                    return;
                this.raphael.transform('t 0, 0 r', this.dimensions.rotation);
            };
            Graphics.prototype.rotate = function (degrees) {
                if (!this.hasRaphael())
                    return;
                this.dimensions.rotation = degrees;
                this.raphael.rotate(degrees);
            };
            Graphics.prototype.remove = function () {
                if (!this.hasRaphael())
                    return;
                this.raphael && this.raphael[0] && this.raphael[0].remove();
                this.raphael = null;
            };
            Graphics.prototype.show = function () {
                if (!this.hasRaphael())
                    return;
                this.raphael.show();
                if (this.hasSet())
                    this.set.show();
            };
            Graphics.prototype.hide = function () {
                if (!this.hasRaphael())
                    return;
                this.raphael.hide();
                if (this.hasSet())
                    this.set.hide();
            };
            Graphics.prototype.glow = function () {
                if (!this.hasRaphael())
                    return;
                this.raphael.glow();
            };
            Graphics.prototype.getType = function () {
                if (!this.hasRaphael())
                    return;
                return this.raphael.type;
            };
            /**
             * Handles drawing of graphical element
             * @param  {any[]} ...args [description]
             * @return {any}           [description]
             */
            Graphics.prototype.ondraw = function (callback) {
                this.drawingHandler.ondraw(callback);
            };
            Graphics.prototype.draw = function () {
                this.drawingHandler.draw();
            };
            /**
             * Hover in/out handler registration method;
             * handles generic opacity toggling for all field elements.
             *
             * @param {any} hoverIn  [description]
             * @param {any} hoverOut [description]
             * @param {any} context  [description]
             */
            Graphics.prototype.onhover = function (hoverIn, hoverOut, context) {
                if (!this.hasRaphael())
                    return;
                var self = this;
                this.raphael.hover(function (e) {
                    hoverIn.call(context, e);
                }, function (e) {
                    hoverOut.call(context, e);
                });
            };
            Graphics.prototype.hoverIn = function (e) {
                if (!this.hasRaphael())
                    return;
                // Generic hover in functionality
                console.log('graphics hoverIn');
                this.toggleOpacity();
            };
            Graphics.prototype.hoverOut = function (e) {
                if (!this.hasRaphael())
                    return;
                // Generic hover out functionality
                console.log('graphics hoverOut');
                this.toggleOpacity();
            };
            /**
             * Click events
             * @param {any} fn      [description]
             * @param {any} context [description]
             */
            Graphics.prototype.onclick = function (fn, context) {
                if (!this.hasRaphael())
                    return;
                //console.log('fieldElement click');
                this.raphael.click(function (e) {
                    fn.call(context, e);
                });
            };
            Graphics.prototype.click = function (e) { };
            Graphics.prototype.oncontextmenu = function (fn, context) {
                if (!this.hasRaphael())
                    return;
                this.raphael.mousedown(function (e) {
                    if (e.which == Common.Input.Which.RightClick) {
                        fn.call(context, e);
                    }
                });
            };
            Graphics.prototype.contextmenu = function (e) { };
            /**
             * Mouse down event handler registration method
             * @param {any}                             fn      [description]
             * @param {Common.Interfaces.IActionable} context [description]
             */
            Graphics.prototype.onmousedown = function (fn, context) {
                if (!this.hasRaphael())
                    return;
                this.raphael.mousedown(function (e) {
                    fn.call(context, e);
                });
            };
            /**
             * Mouse up event handler registration method
             * @param {any}                             fn      [description]
             * @param {Common.Interfaces.IActionable} context [description]
             */
            Graphics.prototype.onmouseup = function (fn, context) {
                if (!this.hasRaphael())
                    return;
                this.raphael.mouseup(function (e) {
                    fn.call(context, e);
                });
            };
            /**
             * Default mousedown handler to be called if no other handlers are
             * registered with onmousedown
             * @param {any}                             e       [description]
             * @param {Common.Interfaces.IActionable} context [description]
             */
            Graphics.prototype.mousedown = function (e) {
                if (!this.hasRaphael())
                    return;
            };
            /**
             * Mouse move event handler registration method; attaches listeners
             * to be fired when the cursor moves over an element (such as for cursor tracking)
             * @param {any}                             fn      [description]
             * @param {Common.Interfaces.IActionable} context [description]
             */
            Graphics.prototype.onmousemove = function (fn, context) {
                if (!this.hasRaphael())
                    return;
                this.raphael.mousemove(function (e) {
                    fn.call(context, e);
                });
            };
            /**
             * Default mouse move handler to be called if no other handlers are
             * registered with onmousedown
             * @param {any}                             e       [description]
             * @param {Common.Interfaces.IActionable} context [description]
             */
            Graphics.prototype.mousemove = function (e) {
                if (!this.hasRaphael())
                    return;
            };
            Graphics.prototype.ondrag = function (dragMove, dragStart, dragEnd, context) {
                if (!this.hasRaphael())
                    return;
                this.raphael.drag(dragMove, dragStart, dragEnd, context, context, context);
            };
            Graphics.prototype.flip = function (rotate) {
                // update placemement
                this.placement.flip();
                this.updateFromRelative(this.placement.relative.rx, this.placement.relative.ry, this.placement.relativeElement);
                if (this.hasRaphael() && rotate === true) {
                    // rotate element
                    this.rotate(180);
                    // need to reset the transform because the rotation
                    // causes unresolved transforms that screw up the placement
                    // (thanks, raphael)
                    this.resetTransform();
                    this.cleanTransform();
                }
            };
            Graphics.prototype.drop = function () {
                if (this.location.hasChanged())
                    this.setModified(true);
                var snapX = this.grid.snapPixel(this.location.ax);
                var snapY = this.grid.snapPixel(this.location.ay);
                // Apply snap on drop
                this.updateFromAbsolute(this.snapping ? snapX : this.location.ax + (snapX - this.location.ax), this.snapping ? snapY : this.location.ay + (snapY - this.location.ay));
                if (!this.hasRaphael())
                    return;
                this.resetTransform();
                this.cleanTransform();
            };
            // Special case for triangle. Since the triangle is actually a `path` element,
            // the transform functionality doesn't work the same. We have to create a new
            // temporary triangle where the updated triangle's positon should be and then
            // reset the actual raphael path with the temp triangle's new coordinates.
            // For some reason, transform(0,0) doesn't work the same on a path.
            Graphics.prototype.cleanTransform = function () {
                if (this.raphael.data('element-type') == 'triangle') {
                    var tempTriangle = this.paper.drawing.triangle(this.placement.coordinates.x, this.placement.coordinates.y, this.dimensions.getHeight(), false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                    var pathStr = tempTriangle.attr('path').toString();
                    this.raphael.attr({ 'path': pathStr });
                    tempTriangle.remove();
                }
                else if (this.raphael.type == 'ellipse') {
                    var tempEllipse = this.paper.drawing.ellipse(this.placement.coordinates.x, this.placement.coordinates.y, this.dimensions.getWidth(), this.dimensions.getHeight(), false, this.dimensions.getOffsetX(), this.dimensions.getOffsetY());
                    tempEllipse.remove();
                }
            };
            return Graphics;
        })(Common.Models.Modifiable);
        Models.Graphics = Graphics;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var GraphicsSet = (function () {
            function GraphicsSet(context) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                this.context = context;
                this.paper = this.context.paper;
                this.canvas = this.paper.canvas;
                this.grid = this.paper.grid;
                this.items = [];
                this.raphaelSet = this.paper.drawing.set();
                if (args && args.length > 0) {
                    this.push.apply(this, args);
                }
                //console.log(this.items);
                this.length = this.items.length;
            }
            GraphicsSet.prototype.size = function () {
                return this.items.length;
            };
            GraphicsSet.prototype.push = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                for (var i = 0; i < args.length; i++) {
                    var graphics = args[i];
                    this.length++;
                    this.raphaelSet.exclude(graphics.raphael);
                    this.raphaelSet.push(graphics.raphael);
                    this.items.push(graphics);
                }
            };
            GraphicsSet.prototype.pop = function () {
                this.length--;
                this.raphaelSet.pop();
                return this.items.pop();
            };
            GraphicsSet.prototype.exclude = function (graphics) {
                var matchingGraphics = this.getByGuid(graphics.guid);
                if (!matchingGraphics)
                    throw new Error('GraphicsSet exclude(): no matching graphics found for exclusion');
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (item.guid == matchingGraphics.guid) {
                        this.splice(i, 1);
                        this.length--;
                        break;
                    }
                }
                return this.raphaelSet.exclude(matchingGraphics.raphael);
            };
            GraphicsSet.prototype.forEach = function (iterator, context) {
                return this.raphaelSet.forEach(iterator, context);
            };
            GraphicsSet.prototype.getByGuid = function (guid) {
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (item && item.guid && item.guid == guid)
                        return item;
                }
                return null;
            };
            GraphicsSet.prototype.splice = function (index, count) {
                this.length -= count;
                this.raphaelSet.splice(index, count);
                return this.items.splice(index, count);
            };
            GraphicsSet.prototype.removeAll = function () {
                while (this.raphaelSet.length > 0) {
                    this.pop();
                }
                this.items = [];
                this.length = 0;
            };
            GraphicsSet.prototype.dragOne = function (guid, dx, dy) {
                var graphics = this.getByGuid(guid);
                graphics.moveByDelta(dx, dy);
            };
            GraphicsSet.prototype.dragAll = function (dx, dy) {
                //console.log('dragging ' + this.length + ' items');
                // for each item in the set, update its drag position
                for (var i = 0; i < this.items.length; i++) {
                    var graphics = this.items[i];
                    graphics.moveByDelta(dx, dy);
                }
            };
            GraphicsSet.prototype.show = function () {
                this.raphaelSet.show();
            };
            GraphicsSet.prototype.hide = function () {
                this.raphaelSet.hide();
            };
            GraphicsSet.prototype.drop = function () {
                // iterate over each item and update its final position
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    item.drop();
                }
            };
            GraphicsSet.prototype.setOriginalPositions = function () {
                // for each item in the set, update its drag position
                for (var i = 0; i < this.items.length; i++) {
                    var graphics = this.items[i];
                    graphics.location.ax = graphics.location.ox;
                    graphics.location.ay = graphics.location.oy;
                }
            };
            return GraphicsSet;
        })();
        Models.GraphicsSet = GraphicsSet;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Dimensions = (function (_super) {
            __extends(Dimensions, _super);
            function Dimensions() {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.width = 0;
                this.height = 0;
                this.minWidth = 0;
                this.minHeight = 0;
                this.length = 0;
                this.depth = 0;
                this.radius = 0;
                this.diameter = 2 * this.radius;
                this.perimeter = 0;
                this.circumference = 0;
                this.area = 0;
                this.circularArea = 0;
                this.offset = new Common.Models.Offset(0, 0);
                this.rotation = 0;
            }
            Dimensions.prototype.toJson = function () {
                return {
                    width: this.width,
                    height: this.height,
                    minWidth: this.minWidth,
                    minHeight: this.minHeight,
                    length: this.length,
                    depth: this.depth,
                    radius: this.radius,
                    diameter: this.diameter,
                    perimeter: this.perimeter,
                    area: this.area,
                    circumference: this.circumference,
                    offset: this.offset.toJson(),
                    rotation: this.rotation
                };
            };
            Dimensions.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.width = json.width;
                this.height = json.height;
                this.minWidth = json.minWidth;
                this.minHeight = json.minHeight;
                this.length = json.length;
                this.depth = json.depth;
                this.radius = json.radius;
                this.diameter = json.diameter;
                this.perimeter = json.perimeter;
                this.area = json.area;
                this.circumference = json.circumference;
                this.offset.fromJson(json.offset);
                this.rotation = json.rotation;
            };
            Dimensions.prototype.calculateDimensions = function () {
                this._calculateDiameter();
                this._calculateArea();
                this._calculatePerimeter();
                this._calculateCircumference();
                this._calculateCircularArea();
                //this.setModified(true);
            };
            Dimensions.prototype.getHeight = function () {
                return this.height;
            };
            Dimensions.prototype.setHeight = function (height) {
                if (height < 0)
                    throw new Error('Dimensions setHeight(): height cannot be less than zero. You passed: ' + height);
                this.height = height;
                this.calculateDimensions();
            };
            Dimensions.prototype.getWidth = function () {
                return this.width;
            };
            Dimensions.prototype.setWidth = function (width) {
                this.width = width;
                this.calculateDimensions();
            };
            Dimensions.prototype.getMinWidth = function () {
                return this.minWidth;
            };
            Dimensions.prototype.setMinWidth = function (minWidth) {
                this.minWidth = minWidth;
                // only recalculate / set as modified if
                // the minWidth is greater then the current width;
                // enforce that the width isn't less than the minWidth
                if (this.minWidth > this.width)
                    this.setWidth(this.minWidth);
            };
            Dimensions.prototype.getMinHeight = function () {
                return this.minHeight;
            };
            Dimensions.prototype.setMinHeight = function (minHeight) {
                this.minHeight = minHeight;
                // only recalculate / set as modified if
                // the minHeight is greater then the current height;
                // enforce that the height isn't less than the minHeight
                if (this.minHeight > this.height)
                    this.setHeight(this.minHeight);
            };
            /**
             * Mostly for line segments
             * @return {number} [description]
             */
            Dimensions.prototype.getLength = function () {
                return this.length;
            };
            Dimensions.prototype.setLength = function (length) {
                this.length = length;
            };
            Dimensions.prototype.getDepth = function () {
                return this.depth;
            };
            Dimensions.prototype.setDepth = function (depth) {
                this.depth = depth;
                //this.setModified(true);
            };
            Dimensions.prototype.getRadius = function () {
                return this.radius;
            };
            Dimensions.prototype.setRadius = function (radius) {
                this.radius = radius;
                this.calculateDimensions();
            };
            Dimensions.prototype.getDiameter = function () {
                return this.diameter;
            };
            Dimensions.prototype.setDiameter = function (diameter) {
                this.diameter = diameter;
                this.radius = this.diameter / 2;
                //this.setModified(true);
            };
            Dimensions.prototype._calculateDiameter = function () {
                this.diameter = this.getRadius() * 2;
                return this.diameter;
            };
            Dimensions.prototype.getPerimeter = function () {
                return this.perimeter;
            };
            Dimensions.prototype._calculatePerimeter = function () {
                this.perimeter = (this.height * 2) + (this.width * 2);
                return this.perimeter;
            };
            Dimensions.prototype.getArea = function () {
                return this.area;
            };
            Dimensions.prototype._calculateArea = function () {
                this.area = this.height * this.width;
                return this.area;
            };
            Dimensions.prototype.getCircumference = function () {
                return this.circumference;
            };
            Dimensions.prototype._calculateCircumference = function () {
                this.circumference = 2 * Math.PI * this.getRadius();
                return this.circumference;
            };
            Dimensions.prototype.getCircularArea = function () {
                return this.circularArea;
            };
            Dimensions.prototype._calculateCircularArea = function () {
                this.circularArea = Math.PI * Math.pow(this.getRadius(), 2);
                return this.circularArea;
            };
            Dimensions.prototype.hasOffset = function () {
                return Common.Utilities.isNotNullOrUndefined(this.offset);
            };
            Dimensions.prototype.getOffset = function () {
                return this.offset;
            };
            Dimensions.prototype.setOffset = function (offset) {
                if (!this.hasOffset())
                    this.offset = new Common.Models.Offset(offset.x, offset.y);
                else
                    this.offset = offset;
                //this.setModified(true);
            };
            Dimensions.prototype.getOffsetX = function () {
                return this.hasOffset() ? this.offset.getX() : null;
            };
            Dimensions.prototype.setOffsetX = function (x) {
                if (!this.hasOffset())
                    this.offset = new Common.Models.Offset(x, 0);
                else
                    this.offset.x = x;
                //this.setModified(true);
            };
            Dimensions.prototype.getOffsetY = function () {
                return this.hasOffset() ? this.offset.getY() : null;
            };
            Dimensions.prototype.setOffsetY = function (y) {
                if (!this.hasOffset())
                    this.offset = new Common.Models.Offset(0, y);
                else
                    this.offset.y = y;
                //this.setModified(true);
            };
            Dimensions.prototype.setOffsetXY = function (x, y) {
                this.offset.setXY(x, y);
                //this.setModified(true);
            };
            return Dimensions;
        })(Common.Models.Modifiable);
        Models.Dimensions = Dimensions;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Offset = (function (_super) {
            __extends(Offset, _super);
            function Offset(x, y) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.x = x || 0;
                this.y = y || 0;
                this.onModified(function () {
                    //console.log('offset modified');
                });
            }
            Offset.prototype.toJson = function () {
                return {
                    x: this.x,
                    y: this.y
                };
            };
            Offset.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.x = json.x;
                this.y = json.y;
            };
            Offset.prototype.set = function (offset) {
                this.x = offset.x;
                this.y = offset.y;
                this.setModified(true);
            };
            Offset.prototype.hasXY = function () {
                return this.hasX() && this.hasY();
            };
            Offset.prototype.hasX = function () {
                return Common.Utilities.isNullOrUndefined(this.x);
            };
            Offset.prototype.getX = function () {
                return this.x;
            };
            Offset.prototype.setX = function (x) {
                this.x = x;
                this.setModified(true);
            };
            Offset.prototype.hasY = function () {
                return Common.Utilities.isNullOrUndefined(this.y);
            };
            Offset.prototype.getY = function () {
                return this.y;
            };
            Offset.prototype.setY = function (y) {
                this.y = y;
                this.setModified(true);
            };
            Offset.prototype.setXY = function (x, y) {
                this.x = x;
                this.y = y;
                this.setModified(true);
            };
            return Offset;
        })(Common.Models.Modifiable);
        Models.Offset = Offset;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Containment = (function () {
            function Containment(left, right, top, bottom) {
                this.left = left;
                this.right = right;
                this.top = top;
                this.bottom = bottom;
            }
            Containment.prototype.isContained = function (coordinates) {
                return this.isContainedX(coordinates.x) &&
                    this.isContainedY(coordinates.y);
            };
            Containment.prototype.isContainedX = function (x) {
                return x >= this.left && x <= this.right;
            };
            Containment.prototype.isContainedY = function (y) {
                return y <= this.top && y >= this.bottom;
            };
            return Containment;
        })();
        Models.Containment = Containment;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var RelativeContainment = (function (_super) {
            __extends(RelativeContainment, _super);
            function RelativeContainment(left, right, top, bottom) {
                _super.call(this, left, right, top, bottom);
            }
            return RelativeContainment;
        })(Common.Models.Containment);
        Models.RelativeContainment = RelativeContainment;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var DrawingHandler = (function () {
            function DrawingHandler(graphics) {
                this.callbacks = [];
            }
            DrawingHandler.prototype.ondraw = function (callback) {
                if (!this.callbacks)
                    throw new Error('Drawable ondraw(): callbacks array is null or undefined');
                this.callbacks.push(callback);
            };
            DrawingHandler.prototype.draw = function () {
                if (!this.callbacks)
                    return;
                for (var i = 0; i < this.callbacks.length; i++) {
                    var callback = this.callbacks[i];
                    if (callback && typeof callback == 'Function')
                        callback(this.graphics);
                }
            };
            return DrawingHandler;
        })();
        Models.DrawingHandler = DrawingHandler;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Common;
(function (Common) {
    var Models;
    (function (Models) {
        var Quote = (function () {
            function Quote(quote, author) {
                this.quote = quote;
                this.author = author;
            }
            return Quote;
        })();
        Models.Quote = Quote;
    })(Models = Common.Models || (Common.Models = {}));
})(Common || (Common = {}));
/// <reference path='../common.ts' />
/// <reference path='../interfaces/interfaces.ts' />
/// <reference path='./Storable.ts' />
/// <reference path='./Modifiable.ts' />
/// <reference path='./Collection.ts' />
/// <reference path='./LinkedList.ts' />
/// <reference path='./ModifiableCollection.ts' />
/// <reference path='./Datetime.ts' />
/// <reference path='./Expandable.ts' />
/// <reference path='./ContextmenuData.ts' />
/// <reference path='./ActionRegistry.ts' />
/// <reference path='./Actionable.ts' />
/// <reference path='./ActionableCollection.ts' />
/// <reference path='./AssociableEntity.ts' />
/// <reference path='./AssociableEntityCollection.ts' />
/// <reference path='./AssociationCollection.ts' />
/// <reference path='./Association.ts' />
/// <reference path='./AssociationResults.ts' />
/// <reference path='./Notification.ts' />
/// <reference path='./NotificationCollection.ts' />
/// <reference path='./Icon.ts' />
/// <reference path='./Assignment.ts' />
/// <reference path='./AssignmentGroup.ts' />
/// <reference path='./AssignmentGroupCollection.ts' />
/// <reference path='./Formation.ts' />
/// <reference path='./FormationCollection.ts' />
/// <reference path='./Play.ts' />
/// <reference path='./PlayPrimary.ts' />
/// <reference path='./PlayOpponent.ts' />
/// <reference path='./PlayCollection.ts' />
/// <reference path='./PlaybookModel.ts' />
/// <reference path='./PlaybookModelCollection.ts' />
/// <reference path='./Scenario.ts' />
/// <reference path='./ScenarioCollection.ts' />
/// <reference path='./Tab.ts' />
/// <reference path='./TabCollection.ts' />
/// <reference path='./Template.ts' />
/// <reference path='./TemplateCollection.ts' />
/// <reference path='./Input.ts' />
/// <reference path='./Listener.ts' />
/// <reference path='./Canvas.ts' />
/// <reference path='./Drawing.ts' />
/// <reference path='./Layer.ts' />
/// <reference path='./LayerCollection.ts' />
/// <reference path='./CanvasListener.ts' />
/// <reference path='./Paper.ts' />
/// <reference path='./Grid.ts' />
/// <reference path='./Field.ts' />
/// <reference path='./FieldElement.ts' />
/// <reference path='./Ball.ts' />
/// <reference path='./Ground.ts' />
/// <reference path='./LineOfScrimmage.ts' />
/// <reference path='./Endzone.ts' />
/// <reference path='./Hashmark.ts' />
/// <reference path='./Ground.ts' />
/// <reference path='./Sideline.ts' />
/// <reference path='./FieldSelectionBox.ts' />
/// <reference path='./Player.ts' />
/// <reference path='./PlayerCollection.ts' />
/// <reference path='./PlayerSelectionBox.ts' />
/// <reference path='./PlayerIcon.ts' />
/// <reference path='./PlayerRelativeCoordinatesLabel.ts' />
/// <reference path='./PlayerPersonnelLabel.ts' />
/// <reference path='./PlayerIndexLabel.ts' />
/// <reference path='./Route.ts' />
/// <reference path='./RouteAction.ts' />
/// <reference path='./RouteCollection.ts' />
/// <reference path='./RouteControlPath.ts' />
/// <reference path='./RouteNode.ts' />
/// <reference path='./RoutePath.ts' />
/// <reference path='./Placement.ts' />
/// <reference path='./PlacementCollection.ts' />
/// <reference path='./Coordinates.ts' />
/// <reference path='./RelativeCoordinates.ts' />
/// <reference path='./Location.ts' />
/// <reference path='./Graphics.ts' />
/// <reference path='./GraphicsSet.ts' />
/// <reference path='./Dimensions.ts' />
/// <reference path='./Offset.ts' />
/// <reference path='./Containment.ts' />
/// <reference path='./RelativeContainment.ts' />
/// <reference path='./DrawingHandler.ts' />
/// <reference path='./Quote.ts' />
/// <reference path='../common.ts' />
var Common;
(function (Common) {
    var Enums;
    (function (Enums) {
        (function (ImpaktDataTypes) {
            ImpaktDataTypes[ImpaktDataTypes["Unknown"] = 0] = "Unknown";
            ImpaktDataTypes[ImpaktDataTypes["PlaybookView"] = 1] = "PlaybookView";
            ImpaktDataTypes[ImpaktDataTypes["Playbook"] = 2] = "Playbook";
            ImpaktDataTypes[ImpaktDataTypes["Formation"] = 3] = "Formation";
            ImpaktDataTypes[ImpaktDataTypes["Set"] = 4] = "Set";
            ImpaktDataTypes[ImpaktDataTypes["Play"] = 10] = "Play";
            ImpaktDataTypes[ImpaktDataTypes["PlayTemplate"] = 98] = "PlayTemplate";
            ImpaktDataTypes[ImpaktDataTypes["Variant"] = 99] = "Variant";
            ImpaktDataTypes[ImpaktDataTypes["Team"] = 200] = "Team";
            ImpaktDataTypes[ImpaktDataTypes["GenericEntity"] = 1000] = "GenericEntity";
            ImpaktDataTypes[ImpaktDataTypes["League"] = 1010] = "League";
            ImpaktDataTypes[ImpaktDataTypes["Season"] = 1011] = "Season";
            ImpaktDataTypes[ImpaktDataTypes["Opponent"] = 1012] = "Opponent";
            ImpaktDataTypes[ImpaktDataTypes["Game"] = 1013] = "Game";
            ImpaktDataTypes[ImpaktDataTypes["Position"] = 1014] = "Position";
            ImpaktDataTypes[ImpaktDataTypes["PersonnelGroup"] = 1015] = "PersonnelGroup";
            ImpaktDataTypes[ImpaktDataTypes["TeamMember"] = 1016] = "TeamMember";
            ImpaktDataTypes[ImpaktDataTypes["UnitType"] = 1017] = "UnitType";
            ImpaktDataTypes[ImpaktDataTypes["Conference"] = 1018] = "Conference";
            ImpaktDataTypes[ImpaktDataTypes["Division"] = 1019] = "Division";
            ImpaktDataTypes[ImpaktDataTypes["Scenario"] = 1020] = "Scenario";
            ImpaktDataTypes[ImpaktDataTypes["MatchupPlaybook"] = 1021] = "MatchupPlaybook";
            ImpaktDataTypes[ImpaktDataTypes["Situation"] = 1022] = "Situation";
            ImpaktDataTypes[ImpaktDataTypes["Assignment"] = 1023] = "Assignment";
            ImpaktDataTypes[ImpaktDataTypes["AssignmentGroup"] = 1024] = "AssignmentGroup";
            ImpaktDataTypes[ImpaktDataTypes["GamePlan"] = 1030] = "GamePlan";
            ImpaktDataTypes[ImpaktDataTypes["PracticePlan"] = 1031] = "PracticePlan";
            ImpaktDataTypes[ImpaktDataTypes["PracticeSchedule"] = 1032] = "PracticeSchedule";
            ImpaktDataTypes[ImpaktDataTypes["ScoutCard"] = 1033] = "ScoutCard";
            ImpaktDataTypes[ImpaktDataTypes["Drill"] = 1034] = "Drill";
            ImpaktDataTypes[ImpaktDataTypes["QBWristband"] = 1035] = "QBWristband";
            ImpaktDataTypes[ImpaktDataTypes["GameAnalysis"] = 1050] = "GameAnalysis";
            ImpaktDataTypes[ImpaktDataTypes["PlayByPlayAnalysis"] = 1051] = "PlayByPlayAnalysis";
            ImpaktDataTypes[ImpaktDataTypes["Location"] = 1101] = "Location";
            ImpaktDataTypes[ImpaktDataTypes["GenericSetting"] = 2000] = "GenericSetting";
            ImpaktDataTypes[ImpaktDataTypes["User"] = 2010] = "User";
            ImpaktDataTypes[ImpaktDataTypes["SecureUser"] = 2011] = "SecureUser";
            ImpaktDataTypes[ImpaktDataTypes["Account"] = 2020] = "Account";
            ImpaktDataTypes[ImpaktDataTypes["Organization"] = 2021] = "Organization";
        })(Enums.ImpaktDataTypes || (Enums.ImpaktDataTypes = {}));
        var ImpaktDataTypes = Enums.ImpaktDataTypes;
        (function (AssociationTypes) {
            AssociationTypes[AssociationTypes["Any"] = -1] = "Any";
            AssociationTypes[AssociationTypes["Unknown"] = 0] = "Unknown";
            AssociationTypes[AssociationTypes["Peer"] = 1] = "Peer";
            AssociationTypes[AssociationTypes["Dependency"] = 2] = "Dependency";
        })(Enums.AssociationTypes || (Enums.AssociationTypes = {}));
        var AssociationTypes = Enums.AssociationTypes;
        (function (DimensionTypes) {
            DimensionTypes[DimensionTypes["Square"] = 0] = "Square";
            DimensionTypes[DimensionTypes["Circle"] = 1] = "Circle";
            DimensionTypes[DimensionTypes["Ellipse"] = 2] = "Ellipse";
        })(Enums.DimensionTypes || (Enums.DimensionTypes = {}));
        var DimensionTypes = Enums.DimensionTypes;
        /**
         * Allows the paper to be scaled/sized differently.
         * To specify an initial paper size, for example,
         * Paper is initialized with MaxCanvasWidth,
         * which causes the paper to determine its width based
         * on the current maximum width of its parent canvas. On the
         * contrary, the paper can be told to set its width based
         * on a given, target grid cell size. For example, if the target
         * grid width is 20px and the grid is 50 cols, the resulting
         * paper width will calculate to 1000px.
         */
        (function (PaperSizingModes) {
            PaperSizingModes[PaperSizingModes["TargetGridWidth"] = 0] = "TargetGridWidth";
            PaperSizingModes[PaperSizingModes["MaxCanvasWidth"] = 1] = "MaxCanvasWidth";
            PaperSizingModes[PaperSizingModes["PreviewWidth"] = 2] = "PreviewWidth";
        })(Enums.PaperSizingModes || (Enums.PaperSizingModes = {}));
        var PaperSizingModes = Enums.PaperSizingModes;
        var CursorTypes = (function () {
            function CursorTypes() {
            }
            CursorTypes.pointer = 'pointer';
            CursorTypes.crosshair = 'crosshair';
            return CursorTypes;
        })();
        Enums.CursorTypes = CursorTypes;
        (function (SetTypes) {
            SetTypes[SetTypes["None"] = 0] = "None";
            SetTypes[SetTypes["Personnel"] = 1] = "Personnel";
            SetTypes[SetTypes["Assignment"] = 2] = "Assignment";
            SetTypes[SetTypes["UnitType"] = 3] = "UnitType";
        })(Enums.SetTypes || (Enums.SetTypes = {}));
        var SetTypes = Enums.SetTypes;
        (function (LayerTypes) {
            LayerTypes[LayerTypes["Generic"] = 0] = "Generic";
            LayerTypes[LayerTypes["FieldElement"] = 1] = "FieldElement";
            LayerTypes[LayerTypes["Player"] = 2] = "Player";
            LayerTypes[LayerTypes["PlayerIcon"] = 3] = "PlayerIcon";
            LayerTypes[LayerTypes["PlayerPersonnelLabel"] = 4] = "PlayerPersonnelLabel";
            LayerTypes[LayerTypes["PlayerIndexLabel"] = 5] = "PlayerIndexLabel";
            LayerTypes[LayerTypes["PlayerCoordinates"] = 6] = "PlayerCoordinates";
            LayerTypes[LayerTypes["PlayerRelativeCoordinatesLabel"] = 7] = "PlayerRelativeCoordinatesLabel";
            LayerTypes[LayerTypes["PlayerSelectionBox"] = 8] = "PlayerSelectionBox";
            LayerTypes[LayerTypes["PlayerRoute"] = 9] = "PlayerRoute";
            LayerTypes[LayerTypes["PlayerSecondaryRoutes"] = 10] = "PlayerSecondaryRoutes";
            LayerTypes[LayerTypes["PlayerAlternateRoutes"] = 11] = "PlayerAlternateRoutes";
            LayerTypes[LayerTypes["PlayerRouteAction"] = 12] = "PlayerRouteAction";
            LayerTypes[LayerTypes["PlayerRouteNode"] = 13] = "PlayerRouteNode";
            LayerTypes[LayerTypes["PlayerRoutePath"] = 14] = "PlayerRoutePath";
            LayerTypes[LayerTypes["PlayerRouteControlPath"] = 15] = "PlayerRouteControlPath";
            LayerTypes[LayerTypes["PrimaryPlayer"] = 16] = "PrimaryPlayer";
            LayerTypes[LayerTypes["PrimaryPlayerIcon"] = 17] = "PrimaryPlayerIcon";
            LayerTypes[LayerTypes["PrimaryPlayerLabel"] = 18] = "PrimaryPlayerLabel";
            LayerTypes[LayerTypes["PrimaryPlayerCoordinates"] = 19] = "PrimaryPlayerCoordinates";
            LayerTypes[LayerTypes["PrimaryPlayerRelativeCoordinatesLabel"] = 20] = "PrimaryPlayerRelativeCoordinatesLabel";
            LayerTypes[LayerTypes["PrimaryPlayerSelectionBox"] = 21] = "PrimaryPlayerSelectionBox";
            LayerTypes[LayerTypes["PrimaryPlayerRoute"] = 22] = "PrimaryPlayerRoute";
            LayerTypes[LayerTypes["PrimaryPlayerSecondaryRoutes"] = 23] = "PrimaryPlayerSecondaryRoutes";
            LayerTypes[LayerTypes["PrimaryPlayerAlternateRoutes"] = 24] = "PrimaryPlayerAlternateRoutes";
            LayerTypes[LayerTypes["PrimaryPlayerRouteAction"] = 25] = "PrimaryPlayerRouteAction";
            LayerTypes[LayerTypes["PrimaryPlayerRouteNode"] = 26] = "PrimaryPlayerRouteNode";
            LayerTypes[LayerTypes["PrimaryPlayerRoutePath"] = 27] = "PrimaryPlayerRoutePath";
            LayerTypes[LayerTypes["PrimaryPlayerRouteControlPath"] = 28] = "PrimaryPlayerRouteControlPath";
            LayerTypes[LayerTypes["OpponentPlayer"] = 29] = "OpponentPlayer";
            LayerTypes[LayerTypes["OpponentPlayerIcon"] = 30] = "OpponentPlayerIcon";
            LayerTypes[LayerTypes["OpponentPlayerLabel"] = 31] = "OpponentPlayerLabel";
            LayerTypes[LayerTypes["OpponentPlayerCoordinates"] = 32] = "OpponentPlayerCoordinates";
            LayerTypes[LayerTypes["OpponentPlayerRelativeCoordinatesLabel"] = 33] = "OpponentPlayerRelativeCoordinatesLabel";
            LayerTypes[LayerTypes["OpponentPlayerSelectionBox"] = 34] = "OpponentPlayerSelectionBox";
            LayerTypes[LayerTypes["OpponentPlayerRoute"] = 35] = "OpponentPlayerRoute";
            LayerTypes[LayerTypes["OpponentPlayerSecondaryRoutes"] = 36] = "OpponentPlayerSecondaryRoutes";
            LayerTypes[LayerTypes["OpponentPlayerAlternateRoutes"] = 37] = "OpponentPlayerAlternateRoutes";
            LayerTypes[LayerTypes["OpponentPlayerRouteAction"] = 38] = "OpponentPlayerRouteAction";
            LayerTypes[LayerTypes["OpponentPlayerRouteNode"] = 39] = "OpponentPlayerRouteNode";
            LayerTypes[LayerTypes["OpponentPlayerRoutePath"] = 40] = "OpponentPlayerRoutePath";
            LayerTypes[LayerTypes["OpponentPlayerRouteControlPath"] = 41] = "OpponentPlayerRouteControlPath";
            LayerTypes[LayerTypes["Ball"] = 42] = "Ball";
            LayerTypes[LayerTypes["Field"] = 43] = "Field";
            LayerTypes[LayerTypes["Sideline"] = 44] = "Sideline";
            LayerTypes[LayerTypes["Hashmark"] = 45] = "Hashmark";
            LayerTypes[LayerTypes["SidelineHashmark"] = 46] = "SidelineHashmark";
            LayerTypes[LayerTypes["Endzone"] = 47] = "Endzone";
            LayerTypes[LayerTypes["LineOfScrimmage"] = 48] = "LineOfScrimmage";
        })(Enums.LayerTypes || (Enums.LayerTypes = {}));
        var LayerTypes = Enums.LayerTypes;
        (function (RouteTypes) {
            RouteTypes[RouteTypes["None"] = 0] = "None";
            RouteTypes[RouteTypes["Generic"] = 1] = "Generic";
            RouteTypes[RouteTypes["Block"] = 2] = "Block";
            RouteTypes[RouteTypes["Scan"] = 3] = "Scan";
            RouteTypes[RouteTypes["Run"] = 4] = "Run";
            RouteTypes[RouteTypes["Route"] = 5] = "Route";
            RouteTypes[RouteTypes["Cover"] = 6] = "Cover";
            RouteTypes[RouteTypes["Zone"] = 7] = "Zone";
            RouteTypes[RouteTypes["Spy"] = 8] = "Spy";
            RouteTypes[RouteTypes["Option"] = 9] = "Option";
            RouteTypes[RouteTypes["HandOff"] = 10] = "HandOff";
            RouteTypes[RouteTypes["Pitch"] = 11] = "Pitch";
        })(Enums.RouteTypes || (Enums.RouteTypes = {}));
        var RouteTypes = Enums.RouteTypes;
        (function (RenderTypes) {
            RenderTypes[RenderTypes["Preview"] = 0] = "Preview";
            RenderTypes[RenderTypes["Editor"] = 1] = "Editor";
            RenderTypes[RenderTypes["Unknown"] = 2] = "Unknown";
        })(Enums.RenderTypes || (Enums.RenderTypes = {}));
        var RenderTypes = Enums.RenderTypes;
        (function (RouteNodeTypes) {
            RouteNodeTypes[RouteNodeTypes["None"] = 0] = "None";
            RouteNodeTypes[RouteNodeTypes["Normal"] = 1] = "Normal";
            RouteNodeTypes[RouteNodeTypes["Root"] = 2] = "Root";
            RouteNodeTypes[RouteNodeTypes["CurveStart"] = 3] = "CurveStart";
            RouteNodeTypes[RouteNodeTypes["CurveControl"] = 4] = "CurveControl";
            RouteNodeTypes[RouteNodeTypes["CurveEnd"] = 5] = "CurveEnd";
            RouteNodeTypes[RouteNodeTypes["End"] = 6] = "End";
        })(Enums.RouteNodeTypes || (Enums.RouteNodeTypes = {}));
        var RouteNodeTypes = Enums.RouteNodeTypes;
        (function (RouteNodeActions) {
            RouteNodeActions[RouteNodeActions["None"] = 0] = "None";
            RouteNodeActions[RouteNodeActions["Block"] = 1] = "Block";
            RouteNodeActions[RouteNodeActions["Delay"] = 2] = "Delay";
            RouteNodeActions[RouteNodeActions["Continue"] = 3] = "Continue";
            RouteNodeActions[RouteNodeActions["Juke"] = 4] = "Juke";
            RouteNodeActions[RouteNodeActions["ZigZag"] = 5] = "ZigZag";
        })(Enums.RouteNodeActions || (Enums.RouteNodeActions = {}));
        var RouteNodeActions = Enums.RouteNodeActions;
        (function (Actions) {
            Actions[Actions["None"] = 0] = "None";
            Actions[Actions["Create"] = 1] = "Create";
            Actions[Actions["Save"] = 2] = "Save";
            Actions[Actions["Overwrite"] = 3] = "Overwrite";
            Actions[Actions["Copy"] = 4] = "Copy";
            Actions[Actions["Edit"] = 5] = "Edit";
            Actions[Actions["Update"] = 6] = "Update";
            Actions[Actions["Delete"] = 7] = "Delete";
            Actions[Actions["View"] = 8] = "View";
            Actions[Actions["Details"] = 9] = "Details";
            Actions[Actions["Select"] = 10] = "Select";
        })(Enums.Actions || (Enums.Actions = {}));
        var Actions = Enums.Actions;
    })(Enums = Common.Enums || (Common.Enums = {}));
})(Common || (Common = {}));
/// <reference path='../common.ts' />
var Common;
(function (Common) {
    var Constants;
    (function (Constants) {
        Constants.DEFAULT_GRID_COLS = 100;
        Constants.DEFAULT_GRID_ROWS = 100;
        Constants.COMMON_URL = 'common/';
        Constants.MODULES_URL = 'modules/';
        Constants.PLAYBOOK_URL = 'playbook/';
        Constants.CONTEXTMENUS_URL = 'contextmenus/';
        /**
         *
         * Contextmenu template URLs
         *
         */
        Constants.DEFAULT_CONTEXTMENU_TEMPLATE_URL = [
            Common.Constants.COMMON_URL,
            Common.Constants.CONTEXTMENUS_URL,
            'default-contextmenu.tpl.html'
        ].join('');
        Constants.EDITOR_ROUTENODE_CONTEXTMENU_TEMPLATE_URL = [
            Common.Constants.MODULES_URL,
            Common.Constants.PLAYBOOK_URL,
            Common.Constants.CONTEXTMENUS_URL,
            'routeNode/contextmenu-routeNode.tpl.html'
        ].join('');
        Constants.PLAY_CONTEXTMENU_TEMPLATE_URL = [
            Common.Constants.MODULES_URL,
            Common.Constants.PLAYBOOK_URL,
            Common.Constants.CONTEXTMENUS_URL,
            'play/contextmenu-play.tpl.html'
        ].join('');
        Constants.PLAYER_CONTEXTMENU_TEMPLATE_URL = [
            Common.Constants.MODULES_URL,
            Common.Constants.PLAYBOOK_URL,
            Common.Constants.CONTEXTMENUS_URL,
            'player/contextmenu-player.tpl.html'
        ].join('');
    })(Constants = Common.Constants || (Common.Constants = {}));
})(Common || (Common = {}));
/// <reference path='./factories.ts' />
var Common;
(function (Common) {
    var Factories;
    (function (Factories) {
        var PlayerIconFactory = (function () {
            function PlayerIconFactory() {
            }
            PlayerIconFactory.getPlayerIcon = function (player) {
            };
            return PlayerIconFactory;
        })();
        Factories.PlayerIconFactory = PlayerIconFactory;
    })(Factories = Common.Factories || (Common.Factories = {}));
})(Common || (Common = {}));
/// <reference path='./factories.ts' />
var Common;
(function (Common) {
    var Factories;
    (function (Factories) {
        var RouteActionFactory = (function () {
            function RouteActionFactory() {
            }
            RouteActionFactory.draw = function (routeAction) {
                if (Common.Utilities.isNullOrUndefined(routeAction))
                    throw new Error('RouteActionFactory draw(): route action is null or undefined');
                switch (routeAction.action) {
                    case Common.Enums.RouteNodeActions.None:
                        Common.Factories.RouteActionFactory.none(routeAction.getGraphics());
                        break;
                    case Common.Enums.RouteNodeActions.Block:
                        Common.Factories.RouteActionFactory.block(routeAction.routeNode.getGraphics(), routeAction.getGraphics());
                        break;
                    case Common.Enums.RouteNodeActions.Delay:
                        Common.Factories.RouteActionFactory.delay(routeAction.routeNode.getGraphics(), routeAction.getGraphics());
                        break;
                }
            };
            RouteActionFactory.none = function (routeActionGraphics) {
                if (Common.Utilities.isNullOrUndefined(routeActionGraphics))
                    throw new Error('RouteActionFactory none(): route action graphics is null');
                return routeActionGraphics.remove();
            };
            RouteActionFactory.block = function (routeNodeGraphics, routeActionGraphics) {
                if (Common.Utilities.isNullOrUndefined(routeActionGraphics))
                    throw new Error('RouteActionFactory block(): route action graphics is null');
                if (Common.Utilities.isNullOrUndefined(routeNodeGraphics))
                    throw new Error('RouteActionFactory block(): route node graphics is null');
                var theta = Common.Drawing.Utilities.theta(routeNodeGraphics.location.ax, routeNodeGraphics.location.ay, routeActionGraphics.location.ax, routeActionGraphics.location.ay);
                var thetaDegrees = Common.Drawing.Utilities.toDegrees(theta);
                routeActionGraphics.placement.coordinates.x = routeNodeGraphics.placement.coordinates.x;
                routeActionGraphics.placement.coordinates.y = routeNodeGraphics.placement.coordinates.y;
                routeActionGraphics.dimensions.offset.x = 0.5;
                routeActionGraphics.location.ax = routeNodeGraphics.location.ax - routeActionGraphics.dimensions.getWidth();
                routeActionGraphics.location.ay = routeNodeGraphics.location.ay;
                routeActionGraphics.setFill('blue');
                routeActionGraphics.setStrokeWidth(2);
                routeActionGraphics.dimensions.width = routeNodeGraphics.dimensions.getWidth() * 2;
                routeActionGraphics.dimensions.height = routeNodeGraphics.dimensions.getHeight() * 2;
                var pathStr = Common.Drawing.Utilities.getPathString(true, [
                    routeActionGraphics.location.ax,
                    routeActionGraphics.location.ay,
                    routeActionGraphics.location.ax + (routeActionGraphics.dimensions.getWidth() * 2),
                    routeActionGraphics.location.ay
                ]);
                routeActionGraphics.path(pathStr);
                routeActionGraphics.setAttribute('class', 'painted-fill');
                routeActionGraphics.rotate(90 - thetaDegrees);
            };
            RouteActionFactory.delay = function (routeNodeGraphics, routeActionGraphics) {
                if (Common.Utilities.isNullOrUndefined(routeActionGraphics))
                    throw new Error('RouteActionFactory block(): route action graphics is null');
                if (Common.Utilities.isNullOrUndefined(routeNodeGraphics))
                    throw new Error('RouteActionFactory block(): route node graphics is null');
                routeActionGraphics.dimensions.offset.x = 0.5;
                routeActionGraphics.dimensions.offset.y = 0.5;
                routeActionGraphics.dimensions.width = routeNodeGraphics.dimensions.getWidth() * 2;
                routeActionGraphics.dimensions.height = routeNodeGraphics.dimensions.getHeight() * 2;
                routeActionGraphics.setFill('orange');
                routeActionGraphics.setStrokeWidth(1);
                routeActionGraphics.rect();
                routeActionGraphics.setAttribute('class', 'painted-fill');
            };
            return RouteActionFactory;
        })();
        Factories.RouteActionFactory = RouteActionFactory;
    })(Factories = Common.Factories || (Common.Factories = {}));
})(Common || (Common = {}));
/// <reference path='../common.ts' />
/// <reference path='./PlayerIconFactory.ts' />
/// <reference path='./RouteActionFactory.ts' />
/// <reference path='../js/impakt.ts' />
/// <reference path='../modules/modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='./enums/enums.ts' />
/// <reference path='./interfaces/interfaces.ts' />
/// <reference path='./constants/constants.ts' />
/// <reference path='./factories/factories.ts' />
var Common;
(function (Common) {
    var API;
    (function (API) {
        (function (Actions) {
            Actions[Actions["Nothing"] = 0] = "Nothing";
            Actions[Actions["Create"] = 1] = "Create";
            Actions[Actions["Overwrite"] = 2] = "Overwrite";
            Actions[Actions["Copy"] = 3] = "Copy";
        })(API.Actions || (API.Actions = {}));
        var Actions = API.Actions;
    })(API = Common.API || (Common.API = {}));
    var Base;
    (function (Base) {
        /**
         * The Common.Base.Component class allows you to dynamically
         * track when angular controllers, services, factories, etc. are
         * being loaded as dependencies of one another.
         *
         * TODO: Investigate this further; I implemented this early on
         * during development and may not have had a firm grasp on
         * the loading order of various angular components. I didn't
         * really take clear note of why I implemented this in the first place;
         * I believe it was necessary. I just need to validate my initial
         * assumptions.
         *
         */
        var Component = (function () {
            function Component(name, type, waitingOn) {
                this.name = name;
                this.type = type;
                this.guid = Common.Utilities.guid();
                this.waitingOn = waitingOn || [];
                this.loaded = this.waitingOn && this.waitingOn.length == 0;
                this.dependencies = new ComponentMap();
                this.onReadyCallback = function () {
                    //console.log('Component ready', this);
                };
            }
            Component.prototype.ready = function () {
                //console.log('component ready', this);
                this.loaded = true;
                this.onReadyCallback(this);
            };
            Component.prototype.onready = function (callback) {
                this.onReadyCallback = callback;
                // even when attaching the ready event listener,
                // if the component has no dependencies, and hence loaded,
                // fire off the ready callback
                if (this.loaded)
                    this.ready();
            };
            Component.prototype.loadDependency = function (dependency) {
                //console.log('loading dependency', dependency, this);
                this.dependencies.add(dependency);
                var index = this.waitingOn.indexOf(dependency.name);
                this.waitingOn.splice(index, 1);
                if (dependency.loaded)
                    dependency.ready();
                if (this.waitingOn.length == 0) {
                    this.ready();
                }
            };
            Component.prototype.registerDependencies = function () {
                for (var i = 0; i < this.waitingOn.length; i++) {
                    this.dependencies.add(new Component(this.waitingOn[i], Common.Base.ComponentType.Null));
                }
            };
            return Component;
        })();
        Base.Component = Component;
        (function (ComponentType) {
            ComponentType[ComponentType["Null"] = 0] = "Null";
            ComponentType[ComponentType["Service"] = 1] = "Service";
            ComponentType[ComponentType["Controller"] = 2] = "Controller";
            ComponentType[ComponentType["Directive"] = 3] = "Directive";
        })(Base.ComponentType || (Base.ComponentType = {}));
        var ComponentType = Base.ComponentType;
        var ComponentMap = (function () {
            function ComponentMap() {
                this.obj = {};
                this.count = 0;
            }
            /**
             * Adds a new component to the list or updates
             * the component if it already exists.
             * @param {Component} component The component to be added
             */
            ComponentMap.prototype.add = function (component) {
                if (this.obj[component.guid]) {
                    this.set(component);
                    return;
                }
                this.obj[component.guid] = component;
                this.count++;
            };
            ComponentMap.prototype.remove = function (guid) {
                var component = this.obj[guid];
                delete this.obj[guid];
                this.count--;
                return component;
            };
            ComponentMap.prototype.get = function (guid) {
                return this.obj[guid];
            };
            ComponentMap.prototype.set = function (component) {
                this.obj[component.guid] = component;
            };
            return ComponentMap;
        })();
        Base.ComponentMap = ComponentMap;
    })(Base = Common.Base || (Common.Base = {}));
    var Utilities = (function () {
        function Utilities() {
        }
        Utilities.notImplementedException = function () {
            throw new Error('Exception: Method not implemented');
        };
        Utilities.exportToPng = function (canvas, svgElement) {
            if (!svgElement)
                throw new Error('play-preview: Corresponding SVG element not found');
            // Serialize the SVG XML into a string
            var svgString = Common.Utilities.serializeXMLToString(svgElement);
            // canvg javascript library takes the canvas HTML element and the SVG
            // in string form
            canvg(canvas.exportCanvas, svgString);
            // the exportCanvas is a <canvas/> element, which possesses a method
            // to export its data as a PNG data URL
            var pngDataURI = canvas.exportCanvas.toDataURL("image/png");
            return pngDataURI;
        };
        /**
         * Compresses the given SVG element into a compressed string
         * @param  {HTMLElement} svg SVG element to handle
         * @return {string}          the compressed SVG string
         */
        Utilities.compressSVG = function (svg) {
            var serialized = Common.Utilities.serializeXMLToString(svg);
            var encoded = Common.Utilities.toBase64(serialized);
            // TODO: NEED TO FIX COMPRESSION ISSUE. USING THIS METHOD CAUSES 
            // THE COMPRESSED CHARACTERS (NON UTF-8) TO BE CONVERTED TO '?'
            // WHICH BREAKS PARSING
            //return Common.Utilities.compress(encoded);
            return encoded;
        };
        /**
         * Compresses the given string
         * @param  {string} svg String to compress
         * @return {any}        a compressed svg string
         */
        Utilities.compress = function (str) {
            return LZString.compress(str);
        };
        /**
         * Takes a compressed SVG data and decompresses it
         * @param  {string} compressed The compressed SVG data to decompress
         * @return {string}            The decompressed string of SVG
         */
        Utilities.decompressSVG = function (compressed) {
            // TO-DO: COMPRESSION BROKEN; SEE COMPRESSSVG ABOVE FOR NOTES
            //let decompressed = Common.Utilities.decompress(compressed);
            //return Common.Utilities.fromBase64(decompressed); 
            return Common.Utilities.fromBase64(compressed);
        };
        /**
         * Decompresses the given string
         * @param  {string} compressed The (compressed) string to decompress
         * @return {string}            the decompressed string
         */
        Utilities.decompress = function (compressed) {
            return LZString.decompress(compressed);
        };
        /**
         * Encodes the given string of SVG into base64
         * @param  {string} svgString svg string
         * @return {string}           base64 encoded svg string
         */
        Utilities.toBase64 = function (str) {
            return window.btoa(str);
        };
        /**
         * Decodes the given base64 encoded svg string
         * @param  {string} base64Svg base64 encoded svg string
         * @return {string}           decoded svg string
         */
        Utilities.fromBase64 = function (str) {
            return window.atob(str);
        };
        /**
         * Converts the given SVG HTML element into a string
         * @param  {HTMLElement} svg Element to convert to string
         * @return {string}          returns the stringified SVG element
         */
        Utilities.serializeXMLToString = function (xml) {
            return (new XMLSerializer()).serializeToString(xml);
        };
        Utilities.parseData = function (data) {
            for (var i = 0; i < data.length; i++) {
                try {
                    data[i].data = JSON.parse(data[i].data);
                }
                catch (error) {
                    console.log(error);
                }
            }
            return data;
        };
        Utilities.guid = function () {
            var d = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
            return uuid;
        };
        /**
         * Returns a random number between min (inclusive) and max (inclusive)
         * @param  {number} min [description]
         * @param  {number} max [description]
         * @return {number}     [description]
         */
        Utilities.randomInt = function (min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        };
        Utilities.randomId = function () {
            return (Math.floor(Math.random() * (9999999999 - 1000000000)) + 999999999);
        };
        Utilities.camelCaseToSpace = function (string, capitalizeFirst) {
            var result = string.replace(/([A-Z])/g, " $1");
            // capitalize the first letter - as an example.
            if (capitalizeFirst)
                result = Common.Utilities.sentenceCase(result);
            return result;
        };
        Utilities.sentenceCase = function (str) {
            return (str.charAt(0).toUpperCase() + str.slice(1)).trim();
        };
        Utilities.convertEnumToList = function (obj) {
            var list = {};
            for (var key in obj) {
                if (!isNaN(key)) {
                    list[parseInt(key)] = Common.Utilities.camelCaseToSpace(obj[key], true);
                }
            }
            return list;
        };
        Utilities.getEnumerationsOnly = function (obj) {
            var enums = {};
            for (var key in obj) {
                if (!!isNaN(key)) {
                    enums[key] = obj[key];
                }
            }
            return enums;
        };
        Utilities.getEnumerationsAsArray = function (obj) {
            var enums = [];
            for (var key in obj) {
                if (!isNaN(key)) {
                    enums.push(parseInt(key));
                }
            }
            return enums;
        };
        Utilities.isArray = function (obj) {
            return Object.prototype.toString.call(obj) == '[object Array]';
        };
        Utilities.isObject = function (obj) {
            return typeof obj === 'object';
        };
        Utilities.isFunction = function (obj) {
            typeof obj === 'function';
        };
        Utilities.toJson = function (obj) {
            var results = null;
            if (Common.Utilities.isObject(obj)) {
                results = Common.Utilities.toJsonRecursive(obj, {});
            }
            else if (Common.Utilities.isArray(obj)) {
                results = Common.Utilities.toJsonArrayRecursive(obj);
            }
            else {
                results = obj;
            }
            return results;
        };
        Utilities.toJsonArrayRecursive = function (arr) {
            var jsonArr = [];
            for (var i = 0; i < arr.length; i++) {
                var raw = arr[i];
                var results = null;
                if (Common.Utilities.isArray(raw)) {
                    results = Common.Utilities.toJsonArrayRecursive(raw);
                }
                else if (Common.Utilities.isObject(raw)) {
                    results = Common.Utilities.toJson(raw);
                }
                else {
                    results = raw;
                }
                jsonArr.push(results);
            }
            return jsonArr;
        };
        Utilities.toJsonRecursive = function (obj, results) {
            var keys = Object.keys(obj);
            if (!keys)
                return null;
            if (obj.toJson) {
                results = obj.toJson();
            }
            else {
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (!Common.Utilities.isFunction(obj[key])) {
                        if (Common.Utilities.isObject(obj[key])) {
                            if (obj[key].toJson) {
                                // recurse
                                results[key] = Common.Utilities.toJsonRecursive(obj[key].toJson(), {});
                            }
                        }
                        else if (Common.Utilities.isArray(obj[key])) {
                            results[key] = Common.Utilities.toJsonArrayRecursive(obj[key]);
                        }
                        else {
                            results[key] = obj[key];
                        }
                    }
                }
            }
            return results;
        };
        /**
         * Generates and returns a hashed string from the given JSON object
         * @param {any} json The object to be hashed
         */
        Utilities.generateChecksum = function (json) {
            return objectHash(json, {});
        };
        Utilities.prepareObjectForEncoding = function (obj) {
            var output = null;
            if (Array.isArray(obj)) {
                var arr = obj;
                for (var i_1 = 0; i_1 < arr.length; i_1++) {
                    var arrItem = arr[i_1];
                    output = Common.Utilities.prepareObjectForEncoding(arrItem);
                }
            }
            else {
                var keys = Object.keys(obj).sort();
                output = [];
                var prop;
                for (var i = 0; i < keys.length; i++) {
                    prop = keys[i];
                    output.push(prop);
                    output.push(obj[prop]);
                }
            }
            return output;
        };
        Utilities.isNotNullOrUndefined = function (obj) {
            return !Common.Utilities.isNullOrUndefined(obj);
        };
        Utilities.isNullOrUndefined = function (obj) {
            return Common.Utilities.isNull(obj) || Common.Utilities.isUndefined(obj);
        };
        Utilities.isNull = function (obj) {
            return obj === null;
        };
        Utilities.isUndefined = function (obj) {
            return obj === undefined || obj === 'undefined';
        };
        Utilities.isEmptyString = function (str) {
            return Common.Utilities.isNullOrUndefined(str) || str === '';
        };
        Utilities.isNotEmptyString = function (str) {
            return !Common.Utilities.isEmptyString(str);
        };
        /**
         * Iterates over the given array and removes any
         * duplicate entries
         *
         * @param  {any[]} array [description]
         * @return {any[]}       [description]
         */
        Utilities.uniqueArray = function (array) {
            if (Common.Utilities.isNullOrUndefined(array))
                throw new Error('Utilities uniqueArray(): array is null or undefined');
            var unique = [];
            for (var i = 0; i < array.length; i++) {
                var element = array[i];
                if (unique.indexOf(element) < 0)
                    unique.push(element);
            }
            return unique;
        };
        return Utilities;
    })();
    Common.Utilities = Utilities;
})(Common || (Common = {}));
var Common;
(function (Common) {
    var UI;
    (function (UI) {
        UI.SCROLL_BAR_SIZE = 12;
    })(UI = Common.UI || (Common.UI = {}));
})(Common || (Common = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var Tool = (function () {
            function Tool(title, action, glyphiconIcon, tooltip, cursor, mode, selected) {
                this.title = 'Generic tool';
                this.guid = Common.Utilities.guid();
                this.tooltip = 'Generic tool';
                this.glyphicon = new Common.Icons.Glyphicon();
                this.action = Playbook.Enums.ToolActions.Nothing;
                this.title = title || this.title;
                this.action = action || this.action;
                this.tooltip = tooltip || this.tooltip;
                this.glyphicon.icon = glyphiconIcon || this.glyphicon.icon;
                this.cursor = cursor || Common.Enums.CursorTypes.pointer;
                this.mode = mode || Playbook.Enums.ToolModes.Select;
                this.selected = selected || false;
            }
            return Tool;
        })();
        Models.Tool = Tool;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorEndzone = (function (_super) {
            __extends(EditorEndzone, _super);
            function EditorEndzone(offsetY) {
                _super.call(this, offsetY);
            }
            EditorEndzone.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
            };
            return EditorEndzone;
        })(Common.Models.Endzone);
        Models.EditorEndzone = EditorEndzone;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewEndzone = (function (_super) {
            __extends(PreviewEndzone, _super);
            function PreviewEndzone(offsetY) {
                _super.call(this, offsetY);
            }
            PreviewEndzone.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
            };
            return PreviewEndzone;
        })(Common.Models.Endzone);
        Models.PreviewEndzone = PreviewEndzone;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorBall = (function (_super) {
            __extends(EditorBall, _super);
            function EditorBall() {
                _super.call(this);
            }
            EditorBall.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
            };
            EditorBall.prototype.draw = function () {
                _super.prototype.draw.call(this);
                // Attach event handlers
                this.graphics.onclick(this.click, this);
                this.graphics.ondrag(this.dragMove, this.dragStart, this.dragEnd, this);
            };
            EditorBall.prototype.dragMove = function (dx, dy, posx, posy, e) {
                // NOTE: moveByDelta methods are called separately in the x and y
                // directions to ensure that even if the ball is moved to the
                // peripherals of its containment in either x or y direction,
                // it is still able to move in the other direction, provided
                // that it is still within its containment area
                this.graphics.moveByDeltaX(dx);
                this.graphics.moveByDeltaY(dy);
                // update line of scrimmage - do not track difference in x movement,
                // only track y movement up and down the field
                this.field.ball.graphics.moveByDeltaY(dy);
            };
            EditorBall.prototype.dragStart = function (x, y, e) {
                // drag not implemented in preview
            };
            EditorBall.prototype.dragEnd = function (e) {
                this.graphics.drop();
                this.field.ball.graphics.drop();
            };
            return EditorBall;
        })(Common.Models.Ball);
        Models.EditorBall = EditorBall;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewBall = (function (_super) {
            __extends(PreviewBall, _super);
            function PreviewBall() {
                _super.call(this);
            }
            PreviewBall.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
            };
            PreviewBall.prototype.dragMove = function (dx, dy, posx, posy, e) {
                // Not implemented - preview ball does not have drag functionality
            };
            PreviewBall.prototype.dragStart = function (x, y, e) {
                // Not implemented - preview ball does not have drag functionality
            };
            PreviewBall.prototype.dragEnd = function (e) {
                // Not implemented - preview ball does not have drag functionality
            };
            return PreviewBall;
        })(Common.Models.Ball);
        Models.PreviewBall = PreviewBall;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorField = (function (_super) {
            __extends(EditorField, _super);
            function EditorField(paper, scenario) {
                _super.call(this, paper, scenario);
                this.zoom = 1;
                this.editorType = this.scenario.editorType;
                var self = this;
                this.onModified(function () {
                    //console.log('field modified');
                });
            }
            EditorField.prototype.initialize = function () {
                this.ball = new Playbook.Models.EditorBall();
                this.ball.initialize(this, null);
                this.ground = new Playbook.Models.EditorGround();
                this.ground.initialize(this, null);
                this.los = new Playbook.Models.EditorLineOfScrimmage();
                this.los.initialize(this, null);
                this.endzone_top = new Playbook.Models.EditorEndzone(0);
                this.endzone_top.initialize(this, null);
                this.endzone_bottom = new Playbook.Models.EditorEndzone(110);
                this.endzone_bottom.initialize(this, null);
                this.sideline_left = new Playbook.Models.EditorSideline(0);
                this.sideline_left.initialize(this, null);
                this.sideline_right = new Playbook.Models.EditorSideline(51);
                this.sideline_right.initialize(this, null);
                this.hashmark_left = new Playbook.Models.EditorHashmark(22);
                this.hashmark_left.initialize(this, null);
                this.hashmark_right = new Playbook.Models.EditorHashmark(28);
                this.hashmark_right.initialize(this, null);
                this.hashmark_sideline_left = new Playbook.Models.EditorHashmark(2);
                this.hashmark_sideline_left.initialize(this, null);
                this.hashmark_sideline_right = new Playbook.Models.EditorHashmark(50);
                this.hashmark_sideline_right.initialize(this, null);
                // Set containment around the ball to restrict its drag area
                this.ball.graphics.setContainment(this.hashmark_left.graphics.placement.coordinates.x, this.hashmark_right.graphics.placement.coordinates.x, this.endzone_top.graphics.dimensions.getHeight(), this.endzone_top.graphics.placement.coordinates.y);
                this.layers.add(this.ball.layer);
                this.layers.add(this.ground.layer);
                this.layers.add(this.los.layer);
                this.layers.add(this.endzone_top.layer);
                this.layers.add(this.endzone_bottom.layer);
                this.layers.add(this.sideline_left.layer);
                this.layers.add(this.sideline_right.layer);
                this.layers.add(this.hashmark_left.layer);
                this.layers.add(this.hashmark_right.layer);
                this.layers.add(this.hashmark_sideline_left.layer);
                this.layers.add(this.hashmark_sideline_right.layer);
                if (!this.scenario.playPrimary.formation) {
                    this.scenario.playPrimary.formation = new Common.Models.Formation(this.scenario.playPrimary.unitType);
                    this.scenario.playPrimary.formation.setDefault(this.ball);
                }
                this.draw();
            };
            EditorField.prototype.draw = function () {
                this.ground.draw();
                this.grid.draw();
                this.endzone_top.draw();
                this.endzone_bottom.draw();
                this.sideline_left.draw();
                this.sideline_right.draw();
                this.hashmark_left.draw();
                this.hashmark_right.draw();
                this.hashmark_sideline_left.draw();
                this.hashmark_sideline_right.draw();
                this.los.draw();
                this.ball.draw();
                this.drawScenario();
            };
            EditorField.prototype.useAssignmentTool = function (coords) {
                if (!this.selected.hasElements()) {
                    console.error('Select a player first');
                    return;
                }
                var selectedPlayers = this.getSelectedByLayerType(Common.Enums.LayerTypes.Player);
                var self = this;
                var relativeCoords = null;
                if (selectedPlayers.size() > 1) {
                    selectedPlayers.forEach(function (player, index) {
                        if (index == 0) {
                            relativeCoords = player.graphics.placement.coordinates.getRelativeTo(coords, player);
                        }
                        else {
                            relativeCoords.relativeElement = player;
                        }
                        self._addAssignmentToPlayer.call(self, player, relativeCoords);
                    });
                }
                else if (selectedPlayers.size() == 1) {
                    var player = selectedPlayers.first();
                    this._addAssignmentToPlayer(player, player.graphics.placement.coordinates.getRelativeTo(coords, player));
                }
            };
            EditorField.prototype._addAssignmentToPlayer = function (player, relativeCoords) {
                if (player.assignment &&
                    player.assignment.routes &&
                    player.assignment.routes.size() == 0) {
                    var route = new Playbook.Models.EditorRoute();
                    route.setPlayer(player);
                    route.flipped = player.flipped;
                    player.assignment.addRoute(route);
                }
                // TODO: this will only get the first route, implement
                // route switching
                var playerRoute = player.assignment.routes.getOne();
                if (playerRoute.dragInitialized)
                    return;
                var newNode = new Playbook.Models.EditorRouteNode(relativeCoords, Common.Enums.RouteNodeTypes.Normal);
                newNode.initialize(this, player);
                // route exists, append the node
                playerRoute.addNode(newNode);
                player.assignment.updateRouteArray();
                this.scenario.playPrimary.assignmentGroup.assignments.addAtIndex(player.assignment, player.position.index);
            };
            EditorField.prototype.export = function () {
                return null;
            };
            EditorField.prototype.placeAtYardline = function (element, yardline) {
            };
            EditorField.prototype.remove = function () { };
            EditorField.prototype.getBBoxCoordinates = function () { };
            EditorField.prototype.addPrimaryPlayer = function (placement, position, assignment) {
                var player = new Playbook.Models.EditorPlayer(placement, position, assignment);
                player.initialize(this);
                player.draw();
                var self = this;
                player.onModified(function () {
                    self.setModified(true);
                    if (self.scenario.playPrimary) {
                        self.scenario.playPrimary.setModified(true);
                    }
                    if (self.scenario.playOpponent) {
                        self.scenario.playOpponent.setModified(true);
                    }
                });
                this.primaryPlayers.add(player);
                return player;
            };
            EditorField.prototype.addOpponentPlayer = function (placement, position, assignment) {
                var player = new Playbook.Models.EditorPlayer(placement, position, assignment);
                player.initialize(this);
                player.draw();
                var self = this;
                player.onModified(function () {
                    self.setModified(true);
                    if (self.scenario.playPrimary) {
                        self.scenario.playPrimary.setModified(true);
                    }
                    if (self.scenario.playOpponent) {
                        self.scenario.playOpponent.setModified(true);
                    }
                });
                this.opponentPlayers.add(player);
                return player;
            };
            return EditorField;
        })(Common.Models.Field);
        Models.EditorField = EditorField;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorCanvas = (function (_super) {
            __extends(EditorCanvas, _super);
            function EditorCanvas(scenario, width, height) {
                _super.call(this, scenario);
                /**
                 * Note that paper is created during the initialize() method;
                 * canvas is dependent on angular directive / dynamic HTML include
                 * of the canvas, before the $container/container properties are
                 * available; these containers are required by the paper, which
                 * implements a Raphael object, that requires a container HTML element.
                 */
                //this.unitType = this.playPrimary.unitType;
                //this.editorType = this.playPrimary.editorType;
                this.toolMode = Playbook.Enums.ToolModes.Select;
                // need to set tab explicitly if it's within an editor
                this.tab = null;
                this.listener = new Common.Models.CanvasListener(this);
                this.readyCallbacks = [function () {
                        console.log('CANVAS READY: default canvas ready callback');
                    }];
            }
            EditorCanvas.prototype.initialize = function ($container) {
                var self = this;
                this.container = $container[0]; // jquery lite converted to raw html
                this.$container = $container; // jquery lite object
                this.setDimensions();
                this.paper = new Playbook.Models.EditorPaper(this);
                this.paper.draw();
                // TODO @theBull - stop / pause this timer if the canvas is not
                // visible...
                // this.widthChangeInterval = setInterval(function() {
                // 	if(self.width != self.$container.width()) {
                // 		// width has changed; update the canvas dimensions and
                // 		// resize.
                // 		self.width = self.$container.width();
                // 		self.height = self.$container.height();
                // 		self.resize();
                // 	}
                // }, 1);
                this._ready();
            };
            EditorCanvas.prototype.setDimensions = function () {
                this.dimensions.width = this.$container.width();
                this.dimensions.height = this.$container.height();
            };
            EditorCanvas.prototype.resetHeight = function () {
                //this.height = this.$container.height(this.$container.height());
            };
            EditorCanvas.prototype.zoomIn = function () {
                throw new Error('canvas zoomIn() not implemented');
            };
            EditorCanvas.prototype.zoomOut = function () {
                throw new Error('canvas zoomOut() not implemented');
            };
            EditorCanvas.prototype.getToolMode = function () {
                return this.toolMode;
            };
            EditorCanvas.prototype.getToolModeName = function () {
                return Playbook.Enums.ToolModes[this.toolMode];
            };
            return EditorCanvas;
        })(Common.Models.Canvas);
        Models.EditorCanvas = EditorCanvas;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPaper = (function (_super) {
            __extends(EditorPaper, _super);
            function EditorPaper(canvas) {
                _super.call(this, canvas);
                this.initialize();
            }
            EditorPaper.prototype.initialize = function () {
                // Grid will help the paper determine its sizing
                // and will be the basis for drawing objects' lengths and
                // dimensions.
                this.grid = this.grid || new Common.Models.Grid(this, Playbook.Constants.FIELD_COLS_FULL, Playbook.Constants.FIELD_ROWS_FULL);
                this.drawing = new Common.Drawing.Utilities(this.canvas, this.grid);
                // Paper methods within field are dependent on 
                // this.Raphael
                this.field = this.field || new Playbook.Models.EditorField(this, this.canvas.scenario);
            };
            return EditorPaper;
        })(Common.Models.Paper);
        Models.EditorPaper = EditorPaper;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewField = (function (_super) {
            __extends(PreviewField, _super);
            function PreviewField(paper, scenario) {
                _super.call(this, paper, scenario);
            }
            PreviewField.prototype.initialize = function () {
                this.ball = new Playbook.Models.PreviewBall();
                this.ball.initialize(this, null);
                this.ground = new Playbook.Models.PreviewGround();
                this.ground.initialize(this, null);
                this.los = new Playbook.Models.PreviewLineOfScrimmage();
                this.los.initialize(this, null);
                this.endzone_top = new Playbook.Models.PreviewEndzone(0);
                this.endzone_top.initialize(this, null);
                this.endzone_bottom = new Playbook.Models.PreviewEndzone(110);
                this.endzone_bottom.initialize(this, null);
                this.sideline_left = new Playbook.Models.PreviewSideline(0);
                this.sideline_left.initialize(this, null);
                this.sideline_right = new Playbook.Models.PreviewSideline(51);
                this.sideline_right.initialize(this, null);
                this.hashmark_left = new Playbook.Models.PreviewHashmark(22);
                this.hashmark_left.initialize(this, null);
                this.hashmark_right = new Playbook.Models.PreviewHashmark(28);
                this.hashmark_right.initialize(this, null);
                this.hashmark_sideline_left = new Playbook.Models.PreviewHashmark(2);
                this.hashmark_sideline_left.initialize(this, null);
                this.hashmark_sideline_right = new Playbook.Models.PreviewHashmark(50);
                this.hashmark_sideline_right.initialize(this, null);
                this.layers.add(this.ball.layer);
                this.layers.add(this.ground.layer);
                this.layers.add(this.los.layer);
                this.layers.add(this.endzone_top.layer);
                this.layers.add(this.endzone_bottom.layer);
                this.layers.add(this.sideline_left.layer);
                this.layers.add(this.sideline_right.layer);
                this.layers.add(this.hashmark_left.layer);
                this.layers.add(this.hashmark_right.layer);
                this.layers.add(this.hashmark_sideline_left.layer);
                this.layers.add(this.hashmark_sideline_right.layer);
                if (Common.Utilities.isNotNullOrUndefined(this.scenario)) {
                    if (Common.Utilities.isNotNullOrUndefined(this.scenario.playPrimary) && Common.Utilities.isNullOrUndefined(this.scenario.playPrimary.formation)) {
                        this.scenario.playPrimary.formation = new Common.Models.Formation(this.scenario.playPrimary.unitType);
                        this.scenario.playPrimary.formation.setDefault(this.ball);
                    }
                    if (Common.Utilities.isNotNullOrUndefined(this.scenario.playOpponent) && Common.Utilities.isNullOrUndefined(this.scenario.playOpponent.formation)) {
                        this.scenario.playOpponent.formation = new Common.Models.Formation(this.scenario.playOpponent.unitType);
                        this.scenario.playOpponent.formation.setDefault(this.ball);
                    }
                }
                this.draw();
            };
            PreviewField.prototype.draw = function () {
                this.ground.draw();
                this.hashmark_left.draw();
                this.hashmark_right.draw();
                this.sideline_left.draw();
                this.sideline_right.draw();
                this.endzone_top.draw();
                this.endzone_bottom.draw();
                this.los.draw();
                this.ball.draw();
                this.drawScenario();
            };
            PreviewField.prototype.addPrimaryPlayer = function (placement, position, assignment) {
                // TODO @theBull - look into this
                // adjust for no sidelines...
                //placement.x -= 1;
                var player = new Playbook.Models.PreviewPlayer(placement, position, assignment);
                player.initialize(this);
                // TODO @theBull - add players to new layers
                player.draw();
                this.primaryPlayers.add(player);
                return player;
            };
            PreviewField.prototype.addOpponentPlayer = function (placement, position, assignment) {
                // TODO @theBull - look into this
                // adjust for no sidelines...
                //placement.x -= 1;
                var player = new Playbook.Models.PreviewPlayer(placement, position, assignment);
                player.initialize(this);
                // TODO @theBull - add players to new layers
                player.draw();
                this.opponentPlayers.add(player);
                return player;
            };
            PreviewField.prototype.useAssignmentTool = function (coords) {
                // do nothing
            };
            return PreviewField;
        })(Common.Models.Field);
        Models.PreviewField = PreviewField;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewCanvas = (function (_super) {
            __extends(PreviewCanvas, _super);
            function PreviewCanvas(scenario) {
                _super.call(this, scenario);
                this.dimensions.setMinWidth(250);
                this.dimensions.setMinHeight(200);
            }
            PreviewCanvas.prototype.initialize = function ($container) {
                this.container = $container[0]; // jquery lite converted to raw html
                this.$container = $container;
                this.setDimensions();
                this.paper = new Playbook.Models.PreviewPaper(this);
                this.paper.draw();
                this.$exportCanvas = $('<canvas/>', {
                    id: 'exportCanvas' + this.guid
                }).width(this.dimensions.width).height(this.dimensions.height);
                this.exportCanvas = this.$exportCanvas[0];
                this._ready();
            };
            PreviewCanvas.prototype.setDimensions = function () {
                this.dimensions.width = Math.min(500, this.$container.width());
                this.dimensions.height = Math.min(400, this.$container.height());
            };
            return PreviewCanvas;
        })(Common.Models.Canvas);
        Models.PreviewCanvas = PreviewCanvas;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPaper = (function (_super) {
            __extends(PreviewPaper, _super);
            function PreviewPaper(previewCanvas) {
                _super.call(this, previewCanvas);
                this.canvas = previewCanvas;
                this.sizingMode = Common.Enums.PaperSizingModes.PreviewWidth;
                this.showBorder = false;
                this.initialize();
            }
            PreviewPaper.prototype.initialize = function () {
                // NOTE: Grid size uses PREVIEW constants
                this.grid = new Common.Models.Grid(this, Playbook.Constants.FIELD_COLS_FULL, Playbook.Constants.FIELD_ROWS_FULL);
                this.drawing = new Common.Drawing.Utilities(this.canvas, this.grid);
                this.field = new Playbook.Models.PreviewField(this, this.canvas.scenario);
            };
            return PreviewPaper;
        })(Common.Models.Paper);
        Models.PreviewPaper = PreviewPaper;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewLineOfScrimmage = (function (_super) {
            __extends(PreviewLineOfScrimmage, _super);
            function PreviewLineOfScrimmage() {
                _super.call(this);
            }
            PreviewLineOfScrimmage.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
                this.graphics.setOffsetXY(0, 2);
                this.graphics.dimensions.setHeight(1);
                this.hoverable = false;
                this.selectable = false;
            };
            PreviewLineOfScrimmage.prototype.draw = function () {
                this.graphics.rect();
                //this.graphics.disable();
            };
            return PreviewLineOfScrimmage;
        })(Common.Models.LineOfScrimmage);
        Models.PreviewLineOfScrimmage = PreviewLineOfScrimmage;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorLineOfScrimmage = (function (_super) {
            __extends(EditorLineOfScrimmage, _super);
            function EditorLineOfScrimmage() {
                _super.call(this);
            }
            EditorLineOfScrimmage.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
                this.graphics.dimensions.setOffsetXY(0, 8);
                this.graphics.dimensions.setHeight(4);
                this.graphics.selectedFill = 'blue';
            };
            EditorLineOfScrimmage.prototype.draw = function () {
                this.graphics.rect();
                this.graphics.setAttribute('class', 'ns-resize');
                // this.graphics.onmousedown(
                //     this.mousedown,
                //     this
                // );
                // this.graphics.onmouseup(
                //     this.mouseup,
                //     this
                // );
                // this.graphics.onclick(
                //     this.click,
                //     this
                // );
                this.graphics.ondrag(this.dragMove, this.dragStart, this.dragEnd, this);
                this.onhover(this.hoverIn, this.hoverOut, this);
            };
            // public mousedown(e: any, context: Common.Interfaces.IFieldElement): void {
            //     if (e.keyCode == Common.Input.Which.RightClick) {
            //         context.contextmenu(e, context);
            //     }
            //     this.graphics.select();
            // }
            // public mouseup(e: any, context: Common.Interfaces.IFieldElement): void {
            //     this.graphics.deselect();
            // }
            EditorLineOfScrimmage.prototype.hoverIn = function (e) {
                this.graphics.setHeight(7);
            };
            EditorLineOfScrimmage.prototype.hoverOut = function (e) {
                this.graphics.setHeight(4);
            };
            EditorLineOfScrimmage.prototype.dragMove = function (dx, dy, posx, posy, e) {
                // Ignore drag motions under specified threshold to prevent
                // click/mousedown from triggering drag method
                if (!this.dragging && !this.isOverDragThreshold(dx, dy)) {
                    return;
                }
                else {
                    this.dragging = true;
                }
                this.layer.moveByDelta(0, dy);
                this.field.ball.dragging = true;
                this.field.ball.layer.moveByDelta(0, dy);
                this.field.primaryPlayers.forEach(function (player, index) {
                    player.layer.moveByDelta(0, dy);
                    player.moveAssignmentByDelta(0, dy);
                });
                this.field.opponentPlayers.forEach(function (player, index) {
                    player.layer.moveByDelta(0, dy);
                    player.moveAssignmentByDelta(0, dy);
                });
                this.setModified(true);
            };
            EditorLineOfScrimmage.prototype.dragStart = function (x, y, e) {
                _super.prototype.dragStart.call(this, x, y, e);
            };
            EditorLineOfScrimmage.prototype.dragEnd = function (e) {
                if (this.dragging) {
                    this.drop();
                    this.field.ball.drop();
                    this.field.primaryPlayers.forEach(function (player, index) {
                        player.drop();
                        player.dropAssignment();
                    });
                    this.field.opponentPlayers.forEach(function (player, index) {
                        player.drop();
                        player.dropAssignment();
                    });
                    this.dragging = false;
                }
            };
            return EditorLineOfScrimmage;
        })(Common.Models.LineOfScrimmage);
        Models.EditorLineOfScrimmage = EditorLineOfScrimmage;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewGround = (function (_super) {
            __extends(PreviewGround, _super);
            function PreviewGround() {
                _super.call(this);
            }
            PreviewGround.prototype.draw = function () {
                _super.prototype.draw.call(this);
            };
            PreviewGround.prototype.hoverIn = function (e) {
                // hover not implemented in preview
            };
            PreviewGround.prototype.hoverOut = function (e) {
                // hover not implemented in preview
            };
            PreviewGround.prototype.click = function (e) {
                // click not implemented in preview
            };
            PreviewGround.prototype.mousedown = function (e) {
                // mousedown not implemented in preview
            };
            PreviewGround.prototype.dragMove = function (dx, dy, posx, posy, e) {
                // drag not implemented in preview
            };
            PreviewGround.prototype.dragStart = function (x, y, e) {
                // drag not implemented in preview
            };
            PreviewGround.prototype.dragEnd = function (e) {
                // drag not implemented in preview
            };
            return PreviewGround;
        })(Common.Models.Ground);
        Models.PreviewGround = PreviewGround;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorGround = (function (_super) {
            __extends(EditorGround, _super);
            function EditorGround() {
                _super.call(this);
                this.selectionBox = new Common.Models.FieldSelectionBox();
            }
            EditorGround.prototype.initialize = function (field, relativeElement) {
                _super.prototype.initialize.call(this, field, null);
                this.selectionBox.initialize(field, null);
                this.layer.addLayer(this.selectionBox.layer);
            };
            EditorGround.prototype.draw = function () {
                this.graphics.rect();
                this.graphics.onclick(this.click, this);
                this.graphics.ondrag(this.dragMove, this.dragStart, this.dragEnd, this);
                this.graphics.onmousemove(this.mousemove, this);
            };
            EditorGround.prototype.mousemove = function (e) {
                // get current coordinates
                this.field.setCursorCoordinates(e.offsetX, e.offsetY);
                //console.log(context.field.cursorCoordinates);
            };
            EditorGround.prototype.click = function (e) {
                var coords = this.getClickCoordinates(e.offsetX, e.offsetY);
                console.log('ground clicked', coords);
                var toolMode = this.paper.canvas.toolMode;
                switch (toolMode) {
                    case Playbook.Enums.ToolModes.Select:
                        console.log('selection mode');
                        this.field.deselectAll();
                        break;
                    case Playbook.Enums.ToolModes.None:
                        console.log('no mode');
                        this.field.deselectAll();
                        break;
                    case Playbook.Enums.ToolModes.Assignment:
                        this.field.useAssignmentTool(coords);
                        break;
                }
            };
            EditorGround.prototype.dragMove = function (dx, dy, posx, posy, e) {
                if (!this.isOverDragThreshold(dx, dy))
                    return;
                else
                    this.dragging = true;
                var direction = '';
                var offsetX = 0;
                var offsetY = 0;
                if (dx < 0) {
                    offsetX = dx;
                    dx = -1 * dx;
                }
                if (dy < 0) {
                    offsetY = dy;
                    dy = -1 * dy;
                }
                this.selectionBox.graphics.dimensions.setWidth(dx);
                this.selectionBox.graphics.dimensions.setHeight(dy);
                this.selectionBox.draw();
                this.selectionBox.graphics.transform(offsetX, offsetY);
            };
            EditorGround.prototype.dragStart = function (x, y, e) {
                _super.prototype.dragStart.call(this, x, y, e);
                var coords = this.getClickAbsolute(e.offsetX, e.offsetY);
                // if(this.selectionBox.graphics.hasRaphael()) {
                //     this.selectionBox.layer.show();
                // } else {
                //     this.selectionBox.draw();
                // }
                this.selectionBox.graphics.location.ax = coords.x;
                this.selectionBox.graphics.location.ay = coords.y;
            };
            EditorGround.prototype.dragEnd = function (e) {
                if (this.dragging) {
                    this.selectionBox.graphics.dimensions.setHeight(0);
                    this.selectionBox.graphics.dimensions.setWidth(0);
                    //this.selectionBox.layer.hide();
                    var bounds = this.selectionBox.graphics.getBBox();
                    this.selectionBox.graphics.remove();
                    console.log(bounds);
                    this.field.primaryPlayers.forEach(function (player, index) {
                        // Here, we want to get the x,y vales of each object
                        // regardless of what sort of shape it is.
                        // But rect uses rx and ry, circle uses cx and cy, etc
                        // So we'll see if the bounding boxes intercept instead
                        var playerBounds = player.icon.graphics.getBBox();
                        //do bounding boxes overlap?
                        //is one of this object's x extremes between the selection's xe xtremes?
                        if (playerBounds.x >= bounds.x && playerBounds.x <= bounds.x + bounds.width ||
                            playerBounds.x + playerBounds.width >= bounds.x &&
                                playerBounds.x + playerBounds.width <= bounds.x + bounds.width) {
                            //same for y
                            if (playerBounds.y >= bounds.y && playerBounds.y <= bounds.y + bounds.height ||
                                playerBounds.y + playerBounds.height >= bounds.y &&
                                    playerBounds.y + playerBounds.height <= bounds.y + bounds.height) {
                                player.toggleSelect(true);
                            }
                        }
                    });
                }
                _super.prototype.dragEnd.call(this, e);
            };
            return EditorGround;
        })(Common.Models.Ground);
        Models.EditorGround = EditorGround;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewHashmark = (function (_super) {
            __extends(PreviewHashmark, _super);
            function PreviewHashmark(offsetX) {
                _super.call(this, offsetX);
            }
            return PreviewHashmark;
        })(Common.Models.Hashmark);
        Models.PreviewHashmark = PreviewHashmark;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorHashmark = (function (_super) {
            __extends(EditorHashmark, _super);
            function EditorHashmark(offsetX) {
                _super.call(this, offsetX);
            }
            return EditorHashmark;
        })(Common.Models.Hashmark);
        Models.EditorHashmark = EditorHashmark;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewSideline = (function (_super) {
            __extends(PreviewSideline, _super);
            function PreviewSideline(offsetX) {
                _super.call(this, offsetX);
            }
            PreviewSideline.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
                this.graphics.opacity = 0.35;
            };
            return PreviewSideline;
        })(Common.Models.Sideline);
        Models.PreviewSideline = PreviewSideline;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorSideline = (function (_super) {
            __extends(EditorSideline, _super);
            function EditorSideline(offsetX) {
                _super.call(this, offsetX);
            }
            return EditorSideline;
        })(Common.Models.Sideline);
        Models.EditorSideline = EditorSideline;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPlayer = (function (_super) {
            __extends(EditorPlayer, _super);
            function EditorPlayer(placement, position, assignment) {
                _super.call(this, placement, position, assignment);
            }
            EditorPlayer.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
                // the set acts as a group for the other graphical elements
                this.selectionBox = new Playbook.Models.EditorPlayerSelectionBox(this);
                this.icon = new Playbook.Models.EditorPlayerIcon(this);
                this.relativeCoordinatesLabel = new Playbook.Models.EditorPlayerRelativeCoordinatesLabel(this);
                this.personnelLabel = new Playbook.Models.EditorPlayerPersonnelLabel(this);
                this.indexLabel = new Playbook.Models.EditorPlayerIndexLabel(this);
                this.renderType = Common.Enums.RenderTypes.Editor;
                this.layer.addLayer(this.selectionBox.layer);
                this.layer.addLayer(this.icon.layer);
                this.layer.addLayer(this.relativeCoordinatesLabel.layer);
                this.layer.addLayer(this.personnelLabel.layer);
                this.layer.addLayer(this.indexLabel.layer);
                var self = this;
                this.icon.layer.onModified(function () {
                    console.log('editor player modified');
                    self.setModified(true);
                });
                // parse route json data 
                // don't render the assignments if the editor type is of type Formation
                if (Common.Utilities.isNotNullOrUndefined(this.assignment) &&
                    this.field.editorType != Playbook.Enums.EditorTypes.Formation) {
                    this.assignment.listen(false);
                    this.assignment.setRoutes(this, Common.Enums.RenderTypes.Editor);
                    this.assignment.listen(true);
                }
                this.contextmenuTemplateUrl = Common.Constants.PLAYER_CONTEXTMENU_TEMPLATE_URL;
            };
            EditorPlayer.prototype.draw = function () {
                /**
                 * Player selection box
                 */
                this.selectionBox.draw();
                /**
                 *	Player icon
                 */
                this.icon.draw();
                this.icon.graphics.ondrag(this.dragMove, this.dragStart, this.dragEnd, this);
                /**
                 * Relative Coordinates Text
                 */
                this.relativeCoordinatesLabel.draw();
                /**
                 * Personnel Label
                 */
                this.personnelLabel.draw();
                /**
                 * Index label
                 */
                this.indexLabel.draw();
                this.drawRoute();
            };
            EditorPlayer.prototype.remove = function () {
                this.layer.remove();
                this.assignment.remove();
            };
            EditorPlayer.prototype.mousedown = function (e) {
                // TODO: enumerate e.which (Event.SHIFT_)
                if (e.which == Common.Input.Which.RightClick) {
                    //console.log('right click');
                    this.canvas.listener.invoke(Playbook.Enums.Actions.PlayerContextmenu, this);
                }
            };
            EditorPlayer.prototype.click = function (e) {
                if (e.ctrlKey) {
                    e.preventDefault();
                    if (e.isDefaultPrevented()) {
                    }
                    else {
                        e.returnValue = false;
                    }
                }
                this.toggleSelect(e.metaKey);
                // determine the tool currently selected
                var toolMode = this.canvas.toolMode;
                switch (toolMode) {
                    case Playbook.Enums.ToolModes.Select:
                        //console.log('Select player');
                        break;
                    case Playbook.Enums.ToolModes.Assignment:
                        //console.log('Set player assignment');
                        break;
                }
                return e.returnValue;
            };
            EditorPlayer.prototype.toggleSelect = function (metaKey) {
                // Toggle the selection of this player
                this.icon.toggleSelect(metaKey);
                if (metaKey) {
                    this.field.toggleSelection(this);
                }
                else {
                    this.field.setSelection(this);
                }
            };
            EditorPlayer.prototype.deselect = function () {
                this.icon.deselect();
            };
            EditorPlayer.prototype.select = function () {
                this.icon.select();
            };
            EditorPlayer.prototype.dragMove = function (dx, dy, posx, posy, e) {
                // Ignore drag motions under specified threshold to prevent
                // click/mousedown from triggering drag method
                if (!this.dragging && !this.isOverDragThreshold(dx, dy)) {
                    return;
                }
                else {
                    this.dragging = true;
                    if (this.relativeCoordinatesLabel)
                        this.relativeCoordinatesLabel.layer.show();
                }
                // do not allow dragging while in route mode
                if (this.canvas.toolMode == Playbook.Enums.ToolModes.Assignment) {
                    if (!this.assignment) {
                        this.assignment = new Common.Models.Assignment(this.position.unitType);
                        this.assignment.positionIndex = this.position.index;
                    }
                    var route = this.assignment.routes.getOne();
                    // TODO: Implement route switching
                    if (!route) {
                        var newRoute = new Playbook.Models.EditorRoute(true);
                        this.assignment.routes.add(newRoute);
                        route = this.assignment.routes.get(newRoute.guid);
                    }
                    if (route.dragInitialized) {
                        var coords = new Common.Models.Coordinates(this.graphics.location.ax + dx, this.graphics.location.ay + dy);
                        route.initializeCurve(coords, e.shiftKey);
                    }
                    // prevent remaining logic from getting executed.
                    return;
                }
                else if (!e.shiftKey && e.which != Common.Input.Which.RightClick) {
                    this.layer.moveByDelta(dx, dy);
                    this.moveAssignmentByDelta(dx, dy);
                    // Update relative coordinates label, if it exists
                    if (this.relativeCoordinatesLabel) {
                        var updatedRelativeCoordinates = [
                            this.graphics.placement.relative.rx, ', ',
                            this.graphics.placement.relative.ry
                        ].join('');
                        this.relativeCoordinatesLabel.graphics.attrKeyValue('text', updatedRelativeCoordinates);
                    }
                }
                else if (this.canvas.toolMode == Playbook.Enums.ToolModes.Select) {
                }
                else if (e.shiftKey) {
                }
                else if (e.which == Common.Input.Which.RightClick) {
                }
            };
            EditorPlayer.prototype.dragStart = function (x, y, e) {
                _super.prototype.dragStart.call(this, x, y, e);
            };
            EditorPlayer.prototype.dragEnd = function (e) {
                if (this.dragging) {
                    this.drop();
                    this.dropAssignment();
                    if (this.relativeCoordinatesLabel)
                        this.relativeCoordinatesLabel.layer.hide();
                }
                _super.prototype.dragEnd.call(this, e);
            };
            EditorPlayer.prototype.clearRoute = function () {
            };
            EditorPlayer.prototype.setRouteFromDefaults = function (routeTitle) {
            };
            EditorPlayer.prototype.onkeypress = function () {
            };
            EditorPlayer.prototype.getPositionRelativeToBall = function () {
                return this.graphics.placement.relative;
            };
            EditorPlayer.prototype.getCoordinatesFromAbsolute = function () {
                return this.graphics.placement.coordinates;
            };
            EditorPlayer.prototype.hasPlacement = function () {
                return this.graphics.placement != null;
            };
            EditorPlayer.prototype.hasPosition = function () {
                return this.position != null;
            };
            return EditorPlayer;
        })(Common.Models.Player);
        Models.EditorPlayer = EditorPlayer;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPlayer = (function (_super) {
            __extends(PreviewPlayer, _super);
            function PreviewPlayer(placement, position, assignment) {
                _super.call(this, placement, position, assignment);
            }
            PreviewPlayer.prototype.initialize = function (field) {
                _super.prototype.initialize.call(this, field);
                // the set acts as a group for the other graphical elements
                this.icon = new Playbook.Models.PreviewPlayerIcon(this);
                this.personnelLabel = new Playbook.Models.PreviewPlayerPersonnelLabel(this);
                this.renderType = Common.Enums.RenderTypes.Preview;
                this.layer.addLayer(this.icon.layer);
                // parse route json data
                if (Common.Utilities.isNotNullOrUndefined(this.assignment)) {
                    this.assignment.listen(false);
                    this.assignment.setRoutes(this, Common.Enums.RenderTypes.Preview);
                    this.assignment.listen(true);
                }
            };
            PreviewPlayer.prototype.draw = function () {
                this.icon.draw();
                //this.personnelLabel.draw();
                this.drawRoute();
            };
            PreviewPlayer.prototype.dragMove = function (dx, dy, posx, posy, e) {
                // Not implemented - preview player does not have drag functionality
            };
            PreviewPlayer.prototype.dragStart = function (x, y, e) {
                // Not implemented - preview player does not have drag functionality
            };
            PreviewPlayer.prototype.dragEnd = function (e) {
                // Not implemented - preview player does not have drag functionality
            };
            return PreviewPlayer;
        })(Common.Models.Player);
        Models.PreviewPlayer = PreviewPlayer;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPlayerIcon = (function (_super) {
            __extends(EditorPlayerIcon, _super);
            function EditorPlayerIcon(player) {
                _super.call(this, player);
                this.graphics.setHoverOpacity(0.6);
            }
            EditorPlayerIcon.prototype.draw = function () {
                _super.prototype.draw.call(this);
                this.graphics.setAttribute('class', 'pointer');
                /**
                 *
                 * Attach event handlers to the player icon, but defer the functionality and
                 * scope to the actual player object itself, not to this icon.
                 *
                 */
                this.graphics.onclick(this.click, this);
                this.graphics.onhover(this.player.hoverIn, this.player.hoverOut, this.player);
                this.graphics.onmousedown(this.player.mousedown, this.player);
            };
            EditorPlayerIcon.prototype.click = function (e) {
                this.player.click(e);
            };
            return EditorPlayerIcon;
        })(Common.Models.PlayerIcon);
        Models.EditorPlayerIcon = EditorPlayerIcon;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPlayerIcon = (function (_super) {
            __extends(PreviewPlayerIcon, _super);
            function PreviewPlayerIcon(player) {
                _super.call(this, player);
                this.graphics.fill = 'black';
                this.graphics.setStrokeWidth(0);
            }
            return PreviewPlayerIcon;
        })(Common.Models.PlayerIcon);
        Models.PreviewPlayerIcon = PreviewPlayerIcon;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPlayerRelativeCoordinatesLabel = (function (_super) {
            __extends(PreviewPlayerRelativeCoordinatesLabel, _super);
            function PreviewPlayerRelativeCoordinatesLabel(player) {
                _super.call(this, player);
            }
            return PreviewPlayerRelativeCoordinatesLabel;
        })(Common.Models.PlayerRelativeCoordinatesLabel);
        Models.PreviewPlayerRelativeCoordinatesLabel = PreviewPlayerRelativeCoordinatesLabel;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPlayerRelativeCoordinatesLabel = (function (_super) {
            __extends(EditorPlayerRelativeCoordinatesLabel, _super);
            function EditorPlayerRelativeCoordinatesLabel(player) {
                _super.call(this, player);
            }
            return EditorPlayerRelativeCoordinatesLabel;
        })(Common.Models.PlayerRelativeCoordinatesLabel);
        Models.EditorPlayerRelativeCoordinatesLabel = EditorPlayerRelativeCoordinatesLabel;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPlayerPersonnelLabel = (function (_super) {
            __extends(EditorPlayerPersonnelLabel, _super);
            function EditorPlayerPersonnelLabel(player) {
                _super.call(this, player);
            }
            return EditorPlayerPersonnelLabel;
        })(Common.Models.PlayerPersonnelLabel);
        Models.EditorPlayerPersonnelLabel = EditorPlayerPersonnelLabel;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPlayerPersonnelLabel = (function (_super) {
            __extends(PreviewPlayerPersonnelLabel, _super);
            function PreviewPlayerPersonnelLabel(player) {
                _super.call(this, player);
            }
            return PreviewPlayerPersonnelLabel;
        })(Common.Models.PlayerPersonnelLabel);
        Models.PreviewPlayerPersonnelLabel = PreviewPlayerPersonnelLabel;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPlayerIndexLabel = (function (_super) {
            __extends(EditorPlayerIndexLabel, _super);
            function EditorPlayerIndexLabel(player) {
                _super.call(this, player);
            }
            return EditorPlayerIndexLabel;
        })(Common.Models.PlayerIndexLabel);
        Models.EditorPlayerIndexLabel = EditorPlayerIndexLabel;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPlayerIndexLabel = (function (_super) {
            __extends(PreviewPlayerIndexLabel, _super);
            function PreviewPlayerIndexLabel(player) {
                _super.call(this, player);
            }
            PreviewPlayerIndexLabel.prototype.draw = function () {
                // player index is not visible in preview mode
            };
            return PreviewPlayerIndexLabel;
        })(Common.Models.PlayerIndexLabel);
        Models.PreviewPlayerIndexLabel = PreviewPlayerIndexLabel;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorPlayerSelectionBox = (function (_super) {
            __extends(EditorPlayerSelectionBox, _super);
            function EditorPlayerSelectionBox(player) {
                _super.call(this, player);
            }
            return EditorPlayerSelectionBox;
        })(Common.Models.PlayerSelectionBox);
        Models.EditorPlayerSelectionBox = EditorPlayerSelectionBox;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewPlayerSelectionBox = (function (_super) {
            __extends(PreviewPlayerSelectionBox, _super);
            function PreviewPlayerSelectionBox(player) {
                _super.call(this, player);
            }
            PreviewPlayerSelectionBox.prototype.draw = function () {
                // preview selection box not visible
            };
            return PreviewPlayerSelectionBox;
        })(Common.Models.PlayerSelectionBox);
        Models.PreviewPlayerSelectionBox = PreviewPlayerSelectionBox;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewRoute = (function (_super) {
            __extends(PreviewRoute, _super);
            function PreviewRoute() {
                _super.call(this);
            }
            PreviewRoute.prototype.setPlayer = function (player) {
                _super.prototype.setPlayer.call(this, player);
                if (this.player) {
                }
                this.routePath = new Playbook.Models.PreviewRoutePath();
                this.routePath.initialize(this.field, this);
                this.graphics.disable();
                this.renderType = Common.Enums.RenderTypes.Preview;
            };
            PreviewRoute.prototype.addNode = function (routeNode, render) {
                // Ensure there is a root node before attempting to add the given node
                if (this.nodes.isEmpty() && routeNode.type != Common.Enums.RouteNodeTypes.Root) {
                    // add root node
                    var rootNode = new Playbook.Models.PreviewRouteNode(new Common.Models.RelativeCoordinates(0, 0, this.player), Common.Enums.RouteNodeTypes.Root);
                    rootNode.initialize(this.field, this.player);
                    // add first, since this step includes drawing the node
                    _super.prototype.addNode.call(this, rootNode, false);
                    this.disableRootNode(rootNode);
                }
                return _super.prototype.addNode.call(this, routeNode, false);
            };
            PreviewRoute.prototype.setContext = function (player) {
                // TODO @theBull
            };
            PreviewRoute.prototype.moveNodesByDelta = function (dx, dy) {
                // no movement available for preview route nodes
            };
            PreviewRoute.prototype.initializeCurve = function (coords, flip) {
                // initialize Curve not available for preview
            };
            return PreviewRoute;
        })(Common.Models.Route);
        Models.PreviewRoute = PreviewRoute;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorRoute = (function (_super) {
            __extends(EditorRoute, _super);
            function EditorRoute(dragInitialized) {
                _super.call(this, dragInitialized);
            }
            EditorRoute.prototype.setPlayer = function (player) {
                _super.prototype.setPlayer.call(this, player);
                this.routePath = new Playbook.Models.EditorRoutePath();
                this.routePath.initialize(this.field, this);
                this.renderType = Common.Enums.RenderTypes.Editor;
            };
            EditorRoute.prototype.setContext = function (player) {
                if (player) {
                    this.player = player;
                    this.grid = this.player.grid;
                    this.field = this.player.field;
                    this.paper = this.player.paper;
                    var self_4 = this;
                    this.nodes.forEach(function (node, index) {
                        node.setContext(self_4);
                        if (!self_4.layer.containsLayer(node.layer)) {
                            self_4.layer.addLayer(node.layer);
                        }
                    });
                    this.draw();
                }
            };
            EditorRoute.prototype.addNode = function (routeNode, render) {
                // Ensure there is a root node before attempting to add the given node
                if (this.nodes.isEmpty() && routeNode.type != Common.Enums.RouteNodeTypes.Root) {
                    // add root node
                    var rootNode = new Playbook.Models.EditorRouteNode(new Common.Models.RelativeCoordinates(0, 0, this.player), Common.Enums.RouteNodeTypes.Root);
                    rootNode.initialize(this.field, this.player);
                    // add first, since this step includes drawing the node
                    _super.prototype.addNode.call(this, rootNode, false);
                    this.disableRootNode(rootNode);
                }
                return _super.prototype.addNode.call(this, routeNode, false);
            };
            EditorRoute.prototype.initializeCurve = function (coords, flip) {
                /**
                 * TODO @theBull - add functionality for creating curves
                 * in subsequent segments of the route
                 */
                // pre-condition: we do not have < 1 nodes, since we
                // always create a node when we initialize the object.
                // TODO: if there are more than 3 nodes?
                if (this.nodes.size() == 0) {
                    // ignore this command if assignment node list is empty
                    // or if there are more than 3 nodes (TODO)
                    return;
                }
                var lastNode, controlNode, endNode;
                if (this.nodes.hasElements() && this.nodes.size() == 1) {
                    // last node is our start node
                    lastNode = this.nodes.getLast();
                    lastNode.type = Common.Enums.RouteNodeTypes.CurveStart;
                    // add control node and end node. They share the
                    // same relative coordinates as the root/last node to start
                    controlNode = new Playbook.Models.EditorRouteNode(new Common.Models.RelativeCoordinates(lastNode.graphics.placement.relative.rx, lastNode.graphics.placement.relative.ry, this.player), Common.Enums.RouteNodeTypes.CurveControl);
                    controlNode.initialize(this.field, this.player);
                    endNode = new Playbook.Models.EditorRouteNode(new Common.Models.RelativeCoordinates(lastNode.graphics.placement.relative.rx, lastNode.graphics.placement.relative.ry, this.player), Common.Enums.RouteNodeTypes.CurveEnd);
                    endNode.initialize(this.field, this.player);
                    // false: do not render nodes
                    this.addNode(controlNode, false);
                    this.addNode(endNode, true);
                }
                else {
                    lastNode = this.nodes.getRoot();
                    controlNode = this.nodes.getIndex(1);
                    endNode = this.nodes.getIndex(2);
                }
                if (flip === true) {
                    controlNode.graphics.updateFromAbsolute(coords.x, lastNode.graphics.location.ay);
                }
                else {
                    controlNode.graphics.updateFromAbsolute(lastNode.graphics.location.ax, coords.y);
                }
                endNode.graphics.updateFromAbsolute(coords.x, coords.y);
                this.drawCurve(controlNode);
            };
            EditorRoute.prototype.moveNodesByDelta = function (dx, dy) {
                this.nodes.forEach(function (node, index) {
                    if (node) {
                        node.moveByDelta(dx, dy);
                    }
                });
            };
            return EditorRoute;
        })(Common.Models.Route);
        Models.EditorRoute = EditorRoute;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewRouteNode = (function (_super) {
            __extends(PreviewRouteNode, _super);
            function PreviewRouteNode(relativeCoordinates, type) {
                _super.call(this, relativeCoordinates, type);
                this.routeAction = new Playbook.Models.PreviewRouteAction(Common.Enums.RouteNodeActions.None);
                this.routeControlPath = new Playbook.Models.PreviewRouteControlPath();
                this.renderType = Common.Enums.RenderTypes.Preview;
            }
            PreviewRouteNode.prototype.initialize = function (field, route) {
                _super.prototype.initialize.call(this, field, route);
                // preview route node does not have a contextmenu
                this.contextmenuTemplateUrl = null;
                // Related route node graphics
                this.routeAction.initialize(this.field, this);
                this.routeControlPath.initialize(this.field, this);
                this.layer.addLayer(this.routeAction.layer);
                this.layer.addLayer(this.routeControlPath.layer);
                this.route.layer.addLayer(this.layer);
                this.disable();
            };
            return PreviewRouteNode;
        })(Common.Models.RouteNode);
        Models.PreviewRouteNode = PreviewRouteNode;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorRouteNode = (function (_super) {
            __extends(EditorRouteNode, _super);
            function EditorRouteNode(relativeCoordinates, type) {
                _super.call(this, relativeCoordinates, type);
                this.routeAction = new Playbook.Models.EditorRouteAction(Common.Enums.RouteNodeActions.None);
                this.routeControlPath = new Playbook.Models.EditorRouteControlPath();
                this.renderType = Common.Enums.RenderTypes.Editor;
                this.contextmenuTemplateUrl = Common.Constants.EDITOR_ROUTENODE_CONTEXTMENU_TEMPLATE_URL;
            }
            EditorRouteNode.prototype.initialize = function (field, route) {
                _super.prototype.initialize.call(this, field, route);
                this.graphics.enable();
                this.graphics.setOriginalFill('#222222');
                this.graphics.setHoverOpacity(1);
                this.graphics.setOriginalOpacity(0.05);
                this.graphics.setSelectedFillOpacity(1);
                this.graphics.setSelectedFill('#222222');
                // Related route node graphics
                this.routeAction.initialize(this.field, this);
                this.routeControlPath.initialize(this.field, this);
                // Add layers
                this.layer.addLayer(this.routeAction.layer);
                this.layer.addLayer(this.routeControlPath.layer);
                this.route.layer.addLayer(this.layer);
            };
            EditorRouteNode.prototype.draw = function () {
                _super.prototype.draw.call(this);
                this.graphics.setAttribute('class', 'grab');
                this.graphics.onclick(this.click, this);
                this.graphics.ondrag(this.dragMove, this.dragStart, this.dragEnd, this // drag end context
                );
                this.graphics.onhover(this.hoverIn, this.hoverOut, this);
                this.graphics.oncontextmenu(this.contextmenu, this);
                if (this.type == Common.Enums.RouteNodeTypes.CurveControl) {
                }
            };
            EditorRouteNode.prototype.hoverIn = function (e) {
                this.graphics.toggleOpacity();
            };
            EditorRouteNode.prototype.hoverOut = function (e) {
                this.graphics.toggleOpacity();
            };
            EditorRouteNode.prototype.click = function (e) {
                // Toggle the selection of this routeNode
                this.field.toggleSelection(this);
            };
            EditorRouteNode.prototype.contextmenu = function (e) {
                this.paper.canvas.listener.invoke(Playbook.Enums.Actions.RouteNodeContextmenu, new Common.Models.ContextmenuData(this, e.pageX, e.pageY));
            };
            EditorRouteNode.prototype.dragMove = function (dx, dy, posx, posy, e) {
                if (this.disabled) {
                    return;
                }
                // Update RouteNode graphical position
                this.graphics.moveByDelta(dx, dy);
                // Update RouteAction graphical position (if applicable)
                if (this.routeAction) {
                    this.routeAction.layer.moveByDelta(dx, dy);
                    // Rotate the route action to stay perpendicular to the node/route orientation
                    var theta = Common.Drawing.Utilities.theta(this.prev.graphics.location.ax, this.prev.graphics.location.ay, this.graphics.location.ax, this.graphics.location.ay);
                    var thetaDegrees = Common.Drawing.Utilities.toDegrees(theta);
                    this.routeAction.graphics.rotate(90 - thetaDegrees);
                }
                // redraw the path
                if (this.isCurveNode()) {
                    console.log('dragging control:', this.type);
                }
                this.route.draw();
            };
            EditorRouteNode.prototype.dragStart = function (x, y, e) {
                _super.prototype.dragStart.call(this, x, y, e);
                this.listen(false);
            };
            EditorRouteNode.prototype.dragEnd = function (e) {
                _super.prototype.dragEnd.call(this, e);
                this.listen(true);
                this.drop();
                // re-draw the route again after dropping,
                // since .drop() will force the absolute
                // coordinates to snap to a grid point, which
                // doesn't happen during the onDrag method
                this.route.draw();
                this.setModified(true);
            };
            EditorRouteNode.prototype.drop = function () {
                _super.prototype.drop.call(this);
                if (this.routeAction)
                    this.routeAction.drop();
                // route node has been modified
                this.setModified();
            };
            return EditorRouteNode;
        })(Common.Models.RouteNode);
        Models.EditorRouteNode = EditorRouteNode;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewRoutePath = (function (_super) {
            __extends(PreviewRoutePath, _super);
            function PreviewRoutePath() {
                _super.call(this);
            }
            PreviewRoutePath.prototype.initialize = function (field, route) {
                _super.prototype.initialize.call(this, field, route);
                this.graphics.setOriginalStrokeWidth(2);
                this.route.layer.addLayer(this.layer);
            };
            return PreviewRoutePath;
        })(Common.Models.RoutePath);
        Models.PreviewRoutePath = PreviewRoutePath;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorRoutePath = (function (_super) {
            __extends(EditorRoutePath, _super);
            function EditorRoutePath() {
                _super.call(this);
            }
            EditorRoutePath.prototype.initialize = function (field, route) {
                _super.prototype.initialize.call(this, field, route);
                this.route.layer.addLayer(this.layer);
            };
            EditorRoutePath.prototype.draw = function () {
                _super.prototype.draw.call(this);
                this.graphics.setAttribute('class', 'painted-fill pointer');
                this.onhover(this.hoverIn, this.hoverOut, this);
            };
            EditorRoutePath.prototype.hoverIn = function (e) {
                this.graphics.setStrokeWidth(6);
            };
            EditorRoutePath.prototype.hoverOut = function (e) {
                this.graphics.setStrokeWidth(3);
            };
            return EditorRoutePath;
        })(Common.Models.RoutePath);
        Models.EditorRoutePath = EditorRoutePath;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewRouteAction = (function (_super) {
            __extends(PreviewRouteAction, _super);
            function PreviewRouteAction(action) {
                _super.call(this, action);
            }
            PreviewRouteAction.prototype.initialize = function (field, relativeElement) {
                _super.prototype.initialize.call(this, field, relativeElement);
            };
            PreviewRouteAction.prototype.draw = function () {
                // preview route action is not visible
            };
            return PreviewRouteAction;
        })(Common.Models.RouteAction);
        Models.PreviewRouteAction = PreviewRouteAction;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorRouteAction = (function (_super) {
            __extends(EditorRouteAction, _super);
            function EditorRouteAction(action) {
                _super.call(this, action);
            }
            EditorRouteAction.prototype.initialize = function (field, relativeElement) {
                _super.prototype.initialize.call(this, field, relativeElement);
            };
            return EditorRouteAction;
        })(Common.Models.RouteAction);
        Models.EditorRouteAction = EditorRouteAction;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var PreviewRouteControlPath = (function (_super) {
            __extends(PreviewRouteControlPath, _super);
            function PreviewRouteControlPath() {
                _super.call(this);
            }
            PreviewRouteControlPath.prototype.draw = function () {
                // preview route curves do not have visible control paths
            };
            return PreviewRouteControlPath;
        })(Common.Models.RouteControlPath);
        Models.PreviewRouteControlPath = PreviewRouteControlPath;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='./models.ts' />
var Playbook;
(function (Playbook) {
    var Models;
    (function (Models) {
        var EditorRouteControlPath = (function (_super) {
            __extends(EditorRouteControlPath, _super);
            function EditorRouteControlPath() {
                _super.call(this);
            }
            return EditorRouteControlPath;
        })(Common.Models.RouteControlPath);
        Models.EditorRouteControlPath = EditorRouteControlPath;
    })(Models = Playbook.Models || (Playbook.Models = {}));
})(Playbook || (Playbook = {}));
/// <reference path='../playbook.ts' />
/// <reference path='./Tool.ts' />
/// <reference path='./EditorEndzone.ts' />
/// <reference path='./PreviewEndzone.ts' />
/// <reference path='./EditorBall.ts' />
/// <reference path='./PreviewBall.ts' />
/// <reference path='./EditorField.ts' />
/// <reference path='./EditorCanvas.ts' />
/// <reference path='./EditorPaper.ts' />
/// <reference path='./PreviewField.ts' />
/// <reference path='./PreviewCanvas.ts' />
/// <reference path='./PreviewPaper.ts' />
/// <reference path='./PreviewLineOfScrimmage.ts' />
/// <reference path='./EditorLineOfScrimmage.ts' />
/// <reference path='./PreviewGround.ts' />
/// <reference path='./EditorGround.ts' />
/// <reference path='./PreviewHashmark.ts' />
/// <reference path='./EditorHashmark.ts' />
/// <reference path='./PreviewSideline.ts' /> 
/// <reference path='./EditorSideline.ts' /> 
/// <reference path='./EditorPlayer.ts' />
/// <reference path='./PreviewPlayer.ts' />
/// <reference path='./EditorPlayerIcon.ts' />
/// <reference path='./PreviewPlayerIcon.ts' />
/// <reference path='./PreviewPlayerRelativeCoordinatesLabel.ts' />
/// <reference path='./EditorPlayerRelativeCoordinatesLabel.ts' />
/// <reference path='./EditorPlayerPersonnelLabel.ts' />
/// <reference path='./PreviewPlayerPersonnelLabel.ts' />
/// <reference path='./EditorPlayerIndexLabel.ts' />
/// <reference path='./PreviewPlayerIndexLabel.ts' />
/// <reference path='./EditorPlayerSelectionBox.ts' />
/// <reference path='./PreviewPlayerSelectionBox.ts' />
/// <reference path='./PreviewRoute.ts' /> 
/// <reference path='./EditorRoute.ts' /> 
/// <reference path='./PreviewRouteNode.ts' /> 
/// <reference path='./EditorRouteNode.ts' /> 
/// <reference path='./PreviewRoutePath.ts' /> 
/// <reference path='./EditorRoutePath.ts' /> 
/// <reference path='./PreviewRouteAction.ts' /> 
/// <reference path='./EditorRouteAction.ts' /> 
/// <reference path='./PreviewRouteControlPath.ts' /> 
/// <reference path='./EditorRouteControlPath.ts' /> 
/// <reference path='../playbook.ts' />
var Playbook;
(function (Playbook) {
    var Enums;
    (function (Enums) {
        (function (Actions) {
            Actions[Actions["FieldElementContextmenu"] = 0] = "FieldElementContextmenu";
            Actions[Actions["PlayerContextmenu"] = 1] = "PlayerContextmenu";
            Actions[Actions["RouteNodeContextmenu"] = 2] = "RouteNodeContextmenu";
            Actions[Actions["RouteTreeSelection"] = 3] = "RouteTreeSelection";
        })(Enums.Actions || (Enums.Actions = {}));
        var Actions = Enums.Actions;
        (function (ToolModes) {
            ToolModes[ToolModes["None"] = 0] = "None";
            ToolModes[ToolModes["Select"] = 1] = "Select";
            ToolModes[ToolModes["Formation"] = 2] = "Formation";
            ToolModes[ToolModes["Assignment"] = 3] = "Assignment";
            ToolModes[ToolModes["Zoom"] = 4] = "Zoom";
        })(Enums.ToolModes || (Enums.ToolModes = {}));
        var ToolModes = Enums.ToolModes;
        (function (ToolActions) {
            ToolActions[ToolActions["Nothing"] = 0] = "Nothing";
            ToolActions[ToolActions["Select"] = 1] = "Select";
            ToolActions[ToolActions["ToggleMenu"] = 2] = "ToggleMenu";
            ToolActions[ToolActions["AddPlayer"] = 3] = "AddPlayer";
            ToolActions[ToolActions["Save"] = 4] = "Save";
            ToolActions[ToolActions["ZoomIn"] = 5] = "ZoomIn";
            ToolActions[ToolActions["ZoomOut"] = 6] = "ZoomOut";
            ToolActions[ToolActions["Assignment"] = 7] = "Assignment";
        })(Enums.ToolActions || (Enums.ToolActions = {}));
        var ToolActions = Enums.ToolActions;
        (function (EditorTypes) {
            EditorTypes[EditorTypes["Any"] = 0] = "Any";
            EditorTypes[EditorTypes["Formation"] = 1] = "Formation";
            EditorTypes[EditorTypes["Assignment"] = 2] = "Assignment";
            EditorTypes[EditorTypes["Play"] = 3] = "Play";
            EditorTypes[EditorTypes["Scenario"] = 4] = "Scenario";
        })(Enums.EditorTypes || (Enums.EditorTypes = {}));
        var EditorTypes = Enums.EditorTypes;
        (function (PlayTypes) {
            PlayTypes[PlayTypes["Any"] = 0] = "Any";
            PlayTypes[PlayTypes["Primary"] = 1] = "Primary";
            PlayTypes[PlayTypes["Opponent"] = 2] = "Opponent";
            PlayTypes[PlayTypes["Unknown"] = 3] = "Unknown";
        })(Enums.PlayTypes || (Enums.PlayTypes = {}));
        var PlayTypes = Enums.PlayTypes;
        (function (PlayerIconTypes) {
            PlayerIconTypes[PlayerIconTypes["CircleEditor"] = 0] = "CircleEditor";
            PlayerIconTypes[PlayerIconTypes["SquareEditor"] = 1] = "SquareEditor";
            PlayerIconTypes[PlayerIconTypes["TriangleEditor"] = 2] = "TriangleEditor";
            PlayerIconTypes[PlayerIconTypes["CirclePreview"] = 3] = "CirclePreview";
            PlayerIconTypes[PlayerIconTypes["SquarePreview"] = 4] = "SquarePreview";
            PlayerIconTypes[PlayerIconTypes["TrianglePreview"] = 5] = "TrianglePreview";
        })(Enums.PlayerIconTypes || (Enums.PlayerIconTypes = {}));
        var PlayerIconTypes = Enums.PlayerIconTypes;
    })(Enums = Playbook.Enums || (Playbook.Enums = {}));
})(Playbook || (Playbook = {}));
/// <reference path='../playbook.ts' />
var Playbook;
(function (Playbook) {
    var Constants;
    (function (Constants) {
        Constants.FIELD_COLS_FULL = 52;
        Constants.FIELD_ROWS_FULL = 120;
        Constants.FIELD_COLOR = '#638148';
        Constants.GRID_SIZE = 15;
        Constants.GRID_BASE = 10;
        Constants.BALL_DEFAULT_PLACEMENT_X = 25;
        Constants.BALL_DEFAULT_PLACEMENT_Y = 60;
        Constants.PREVIEW_PLAYER_ICON_RADIUS = 5;
        Constants.DRAG_THRESHOLD_X = 5;
        Constants.DRAG_THRESHOLD_Y = 5;
    })(Constants = Playbook.Constants || (Playbook.Constants = {}));
})(Playbook || (Playbook = {}));
/// <reference path='../modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='./interfaces/interfaces.ts' />
/// <reference path='./enums/enums.ts' />
/// <reference path='./constants/constants.ts' />
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var TeamModel = (function (_super) {
            __extends(TeamModel, _super);
            function TeamModel() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Team);
                _super.prototype.setContext.call(this, this);
                this.name = '';
                this.teamType = Team.Enums.TeamTypes.Mixed;
                this.records = new Team.Models.TeamRecordCollection();
                this.division = new League.Models.Division();
                this.divisionGuid = '';
                this.location = new League.Models.Location();
                this.locationGuid = '';
                var self = this;
                this.onModified(function (data) { });
                this.associable = [
                    'leagues',
                    'conferences',
                    'divisions',
                    'playbooks',
                    'locations'
                ];
            }
            TeamModel.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    teamType: this.teamType,
                    records: this.records.toJson(),
                    divisionGuid: this.divisionGuid,
                    locationGuid: this.locationGuid
                }, _super.prototype.toJson.call(this));
            };
            TeamModel.prototype.fromJson = function (json) {
                if (!json)
                    return null;
                this.teamType = json.teamType;
                this.name = json.name;
                this.records.fromJson(json.records);
                this.divisionGuid = json.divisionGuid;
                this.locationGuid = json.locationGuid;
                _super.prototype.fromJson.call(this, json);
            };
            TeamModel.prototype.setDivision = function (division) {
                this.division = division;
                this.divisionGuid = this.division ? this.division.guid : '';
            };
            TeamModel.prototype.setLocation = function (location) {
                this.location = location;
                this.locationGuid = this.location ? this.location.guid : '';
            };
            return TeamModel;
        })(Common.Models.AssociableEntity);
        Models.TeamModel = TeamModel;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var TeamModelCollection = (function (_super) {
            __extends(TeamModelCollection, _super);
            function TeamModelCollection() {
                _super.call(this);
                this.teamType = Team.Enums.TeamTypes.Mixed;
            }
            TeamModelCollection.prototype.toJson = function () {
                return {
                    teamType: this.teamType,
                    guid: this.guid,
                    teams: _super.prototype.toJson.call(this)
                };
            };
            TeamModelCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.teamType = json.teamType;
                this.guid = json.guid;
                var teamArray = json.teams || [];
                for (var i = 0; i < teamArray.length; i++) {
                    var rawTeamModel = teamArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawTeamModel)) {
                        continue;
                    }
                    rawTeamModel.teamType = Common.Utilities.isNullOrUndefined(rawTeamModel.teamType) &&
                        rawTeamModel.teamType >= 0 ? rawTeamModel.teamType : Team.Enums.TeamTypes.Other;
                    var teamModel = new Team.Models.TeamModel();
                    teamModel.fromJson(rawTeamModel);
                    this.add(teamModel);
                }
            };
            return TeamModelCollection;
        })(Common.Models.ActionableCollection);
        Models.TeamModelCollection = TeamModelCollection;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var TeamRecord = (function (_super) {
            __extends(TeamRecord, _super);
            function TeamRecord() {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.wins = 0;
                this.losses = 0;
                this.season = 2016; // @theBull - TODO - how to tie this with the season...association?
            }
            TeamRecord.prototype.toJson = function () {
                return {
                    wins: this.wins,
                    losses: this.losses,
                    season: this.season
                };
            };
            TeamRecord.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.wins = json.wins;
                this.losses = json.losses;
                this.season = json.season;
            };
            return TeamRecord;
        })(Common.Models.Modifiable);
        Models.TeamRecord = TeamRecord;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var TeamRecordCollection = (function (_super) {
            __extends(TeamRecordCollection, _super);
            function TeamRecordCollection() {
                _super.call(this);
            }
            TeamRecordCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            TeamRecordCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                var recordArray = json.records || [];
                for (var i = 0; i < recordArray.length; i++) {
                    var rawTeamRecordModel = recordArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawTeamRecordModel)) {
                        continue;
                    }
                    var teamRecordModel = new Team.Models.TeamRecord();
                    teamRecordModel.fromJson(rawTeamRecordModel);
                    this.add(teamRecordModel);
                }
            };
            return TeamRecordCollection;
        })(Common.Models.Collection);
        Models.TeamRecordCollection = TeamRecordCollection;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var PrimaryTeam = (function (_super) {
            __extends(PrimaryTeam, _super);
            function PrimaryTeam() {
                _super.call(this);
                this.teamType = Team.Enums.TeamTypes.Primary;
                this.onModified(function (data) { });
            }
            PrimaryTeam.prototype.toJson = function () {
                return {};
            };
            PrimaryTeam.prototype.fromJson = function (json) {
                if (!json)
                    return;
            };
            return PrimaryTeam;
        })(Team.Models.TeamModel);
        Models.PrimaryTeam = PrimaryTeam;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var OpponentTeam = (function (_super) {
            __extends(OpponentTeam, _super);
            function OpponentTeam() {
                _super.call(this);
                this.teamType = Team.Enums.TeamTypes.Opponent;
                this.onModified(function (data) { });
            }
            OpponentTeam.prototype.toJson = function () {
                return {};
            };
            OpponentTeam.prototype.fromJson = function (json) {
                if (!json)
                    return;
            };
            return OpponentTeam;
        })(Team.Models.TeamModel);
        Models.OpponentTeam = OpponentTeam;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var Personnel = (function (_super) {
            __extends(Personnel, _super);
            function Personnel(unitType) {
                _super.call(this, Common.Enums.ImpaktDataTypes.PersonnelGroup);
                _super.prototype.setContext.call(this, this);
                this.name = 'Untitled';
                this.unitType = unitType;
                this.positions = null;
                this.setType = Common.Enums.SetTypes.Personnel;
                this.onModified(function (data) { });
            }
            Personnel.prototype.copy = function (newPersonnel) {
                var copyPersonnel = newPersonnel || new Team.Models.Personnel(this.unitType);
                return _super.prototype.copy.call(this, copyPersonnel, this);
            };
            Personnel.prototype.hasPositions = function () {
                return this.positions && this.positions.size() > 0;
            };
            Personnel.prototype.update = function (personnel) {
                this.unitType = personnel.unitType;
                this.key = personnel.key;
                this.name = personnel.name;
                this.guid = personnel.guid;
            };
            Personnel.prototype.fromJson = function (json) {
                if (!json)
                    return null;
                this.unitType = json.unitType;
                if (!this.positions) {
                    this.positions = new Team.Models.PositionCollection(this.unitType);
                }
                else {
                    this.positions.removeAll();
                }
                this.positions.fromJson(json.positions);
                this.name = json.name;
                _super.prototype.fromJson.call(this, json);
            };
            Personnel.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    unitType: this.unitType,
                    positions: this.positions.toJson()
                }, _super.prototype.toJson.call(this));
            };
            Personnel.prototype.setDefault = function () {
                this.positions = Team.Models.PositionDefault.getBlank(this.unitType);
                this.positions.onModified(function (data) { });
            };
            Personnel.prototype.setUnitType = function (unitType) {
                this.unitType = unitType;
                this.setDefault();
            };
            return Personnel;
        })(Common.Models.AssociableEntity);
        Models.Personnel = Personnel;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var PersonnelCollection = (function (_super) {
            __extends(PersonnelCollection, _super);
            function PersonnelCollection(unitType) {
                _super.call(this);
                this.unitType = unitType;
                this.setType = Common.Enums.SetTypes.Personnel;
            }
            PersonnelCollection.prototype.toJson = function () {
                return {
                    unitType: this.unitType,
                    setType: this.setType,
                    personnel: _super.prototype.toJson.call(this)
                };
            };
            PersonnelCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.unitType = json.unitType;
                this.guid = json.guid;
                this.setType = json.setType;
                var personnelArray = json.personnel || [];
                for (var i = 0; i < personnelArray.length; i++) {
                    var rawPersonnel = personnelArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawPersonnel)) {
                        continue;
                    }
                    rawPersonnel.unitType = Common.Utilities.isNullOrUndefined(rawPersonnel.unitType) &&
                        rawPersonnel.unitType >= 0 ? rawPersonnel.unitType : Team.Enums.UnitTypes.Other;
                    var personnelModel = new Team.Models.Personnel(rawPersonnel.unitType);
                    personnelModel.fromJson(rawPersonnel);
                    this.add(personnelModel);
                }
            };
            return PersonnelCollection;
        })(Common.Models.Collection);
        Models.PersonnelCollection = PersonnelCollection;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var Position = (function (_super) {
            __extends(Position, _super);
            function Position(unitType, options) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                if (!options)
                    options = {};
                this.unitType = unitType;
                this.positionListValue = options.positionListValue || PositionList.Other;
                this.title = options.title || 'Untitled';
                this.label = options.label || '-';
                this.eligible = options.eligible || false;
                this.index = options.index >= 0 ? options.index : -1;
            }
            Position.prototype.toJson = function () {
                return {
                    positionListValue: this.positionListValue,
                    title: this.title,
                    label: this.label,
                    eligible: this.eligible,
                    index: this.index,
                    unitType: this.unitType,
                    guid: this.guid
                };
            };
            Position.prototype.fromJson = function (json) {
                this.positionListValue = json.positionListValue;
                this.label = json.label;
                this.eligible = json.eligible;
                this.title = json.title;
                this.unitType = json.unitType;
                this.index = json.index;
                this.guid = json.guid;
            };
            return Position;
        })(Common.Models.Modifiable);
        Models.Position = Position;
        (function (PositionList) {
            PositionList[PositionList["BlankOffense"] = 0] = "BlankOffense";
            PositionList[PositionList["BlankDefense"] = 1] = "BlankDefense";
            PositionList[PositionList["BlankSpecialTeams"] = 2] = "BlankSpecialTeams";
            PositionList[PositionList["BlankOther"] = 3] = "BlankOther";
            PositionList[PositionList["Quarterback"] = 4] = "Quarterback";
            PositionList[PositionList["RunningBack"] = 5] = "RunningBack";
            PositionList[PositionList["FullBack"] = 6] = "FullBack";
            PositionList[PositionList["TightEnd"] = 7] = "TightEnd";
            PositionList[PositionList["Center"] = 8] = "Center";
            PositionList[PositionList["Guard"] = 9] = "Guard";
            PositionList[PositionList["Tackle"] = 10] = "Tackle";
            PositionList[PositionList["WideReceiver"] = 11] = "WideReceiver";
            PositionList[PositionList["SlotReceiver"] = 12] = "SlotReceiver";
            PositionList[PositionList["NoseGuard"] = 13] = "NoseGuard";
            PositionList[PositionList["DefensiveTackle"] = 14] = "DefensiveTackle";
            PositionList[PositionList["DefensiveGuard"] = 15] = "DefensiveGuard";
            PositionList[PositionList["DefensiveEnd"] = 16] = "DefensiveEnd";
            PositionList[PositionList["Linebacker"] = 17] = "Linebacker";
            PositionList[PositionList["Safety"] = 18] = "Safety";
            PositionList[PositionList["FreeSafety"] = 19] = "FreeSafety";
            PositionList[PositionList["StrongSafety"] = 20] = "StrongSafety";
            PositionList[PositionList["DefensiveBack"] = 21] = "DefensiveBack";
            PositionList[PositionList["Cornerback"] = 22] = "Cornerback";
            PositionList[PositionList["Kicker"] = 23] = "Kicker";
            PositionList[PositionList["Holder"] = 24] = "Holder";
            PositionList[PositionList["Punter"] = 25] = "Punter";
            PositionList[PositionList["LongSnapper"] = 26] = "LongSnapper";
            PositionList[PositionList["KickoffSpecialist"] = 27] = "KickoffSpecialist";
            PositionList[PositionList["PuntReturner"] = 28] = "PuntReturner";
            PositionList[PositionList["KickReturner"] = 29] = "KickReturner";
            PositionList[PositionList["Upback"] = 30] = "Upback";
            PositionList[PositionList["Gunner"] = 31] = "Gunner";
            PositionList[PositionList["Jammer"] = 32] = "Jammer";
            PositionList[PositionList["Other"] = 33] = "Other";
        })(Models.PositionList || (Models.PositionList = {}));
        var PositionList = Models.PositionList;
        var PositionDefault = (function () {
            function PositionDefault() {
                Team.Models.PositionDefault.defaults = {
                    blankOffense: {
                        positionListValue: Team.Models.PositionList.BlankOffense,
                        title: 'Blank',
                        label: '',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: false
                    },
                    blankDefense: {
                        positionListValue: Team.Models.PositionList.BlankDefense,
                        title: 'Blank',
                        label: '',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    blankSpecialTeams: {
                        positionListValue: Team.Models.PositionList.BlankSpecialTeams,
                        title: 'Blank',
                        label: '',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: false
                    },
                    blankOther: {
                        positionListValue: Team.Models.PositionList.BlankOther,
                        title: 'Blank',
                        label: '',
                        unitType: Team.Enums.UnitTypes.Other,
                        eligible: false
                    },
                    quarterback: {
                        positionListValue: Team.Models.PositionList.Quarterback,
                        title: 'Quarterback',
                        label: 'QB',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: false
                    },
                    runningBack: {
                        positionListValue: Team.Models.PositionList.RunningBack,
                        title: 'Running Back',
                        label: 'RB',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: true
                    },
                    fullBack: {
                        positionListValue: Team.Models.PositionList.FullBack,
                        title: 'Full Back',
                        label: 'FB',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: true
                    },
                    tightEnd: {
                        positionListValue: Team.Models.PositionList.TightEnd,
                        title: 'Tight End',
                        label: 'TE',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: true
                    },
                    center: {
                        positionListValue: Team.Models.PositionList.Center,
                        title: 'Center',
                        label: 'C',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: false
                    },
                    guard: {
                        positionListValue: Team.Models.PositionList.Guard,
                        title: 'Guard',
                        label: 'G',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: false
                    },
                    tackle: {
                        positionListValue: Team.Models.PositionList.Tackle,
                        title: 'Tackle',
                        label: 'T',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: false
                    },
                    wideReceiver: {
                        positionListValue: Team.Models.PositionList.WideReceiver,
                        title: 'Wide Receiver',
                        label: 'WR',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: true
                    },
                    slotReceiver: {
                        positionListValue: Team.Models.PositionList.SlotReceiver,
                        title: 'Slot Receiver',
                        label: 'SL',
                        unitType: Team.Enums.UnitTypes.Offense,
                        eligible: true
                    },
                    noseGuard: {
                        positionListValue: Team.Models.PositionList.NoseGuard,
                        title: 'Nose Guard',
                        label: 'N',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    defensiveGuard: {
                        positionListValue: Team.Models.PositionList.DefensiveGuard,
                        title: 'Guard',
                        label: 'G',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    defensiveTackle: {
                        positionListValue: Team.Models.PositionList.DefensiveTackle,
                        title: 'Tackle',
                        label: 'T',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    defensiveEnd: {
                        positionListValue: Team.Models.PositionList.DefensiveEnd,
                        title: 'Defensive End',
                        label: 'DE',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    linebacker: {
                        positionListValue: Team.Models.PositionList.Linebacker,
                        title: 'Linebacker',
                        label: 'LB',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    safety: {
                        positionListValue: Team.Models.PositionList.Safety,
                        title: 'Safety',
                        label: 'S',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    freeSafety: {
                        positionListValue: Team.Models.PositionList.FreeSafety,
                        title: 'Free Safety',
                        label: 'FS',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    strongSafety: {
                        positionListValue: Team.Models.PositionList.StrongSafety,
                        title: 'Strong Safety',
                        label: 'SS',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    defensiveBack: {
                        positionListValue: Team.Models.PositionList.DefensiveBack,
                        title: 'Defensive Back',
                        label: 'DB',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    cornerback: {
                        positionListValue: Team.Models.PositionList.Cornerback,
                        title: 'Cornerback',
                        label: 'CB',
                        unitType: Team.Enums.UnitTypes.Defense,
                        eligible: false
                    },
                    kicker: {
                        positionListValue: Team.Models.PositionList.Kicker,
                        title: 'Kicker',
                        label: 'K',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: false
                    },
                    holder: {
                        positionListValue: Team.Models.PositionList.Holder,
                        title: 'Holder',
                        label: 'H',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: false
                    },
                    punter: {
                        positionListValue: Team.Models.PositionList.Punter,
                        title: 'Punter',
                        label: 'P',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: false
                    },
                    longSnapper: {
                        positionListValue: Team.Models.PositionList.LongSnapper,
                        title: 'Long Snapper',
                        label: 'LS',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: false
                    },
                    kickoffSpecialist: {
                        positionListValue: Team.Models.PositionList.KickoffSpecialist,
                        title: 'Kickoff Specialist',
                        label: 'KS',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: false
                    },
                    puntReturner: {
                        positionListValue: Team.Models.PositionList.PuntReturner,
                        title: 'Punt Returner',
                        label: 'PR',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: true
                    },
                    kickReturner: {
                        positionListValue: Team.Models.PositionList.KickReturner,
                        title: 'Kick Returner',
                        label: 'KR',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: true
                    },
                    upback: {
                        positionListValue: Team.Models.PositionList.Upback,
                        title: 'Upback',
                        label: 'U',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: true
                    },
                    gunner: {
                        positionListValue: Team.Models.PositionList.Gunner,
                        title: 'Gunner',
                        label: 'G',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: true
                    },
                    jammer: {
                        positionListValue: Team.Models.PositionList.Jammer,
                        title: 'Jammer',
                        label: 'J',
                        unitType: Team.Enums.UnitTypes.SpecialTeams,
                        eligible: true
                    },
                    other: {
                        positionListValue: Team.Models.PositionList.Other,
                        title: 'Other',
                        label: '-',
                        unitType: Team.Enums.UnitTypes.Other,
                        eligible: false
                    }
                };
            }
            PositionDefault.prototype.getPosition = function (positionListValue) {
                var results = null;
                for (var positionKey in Team.Models.PositionDefault.defaults) {
                    if (Team.Models.PositionDefault.defaults[positionKey].positionListValue == positionListValue) {
                        var positionSeedData = Team.Models.PositionDefault.defaults[positionKey];
                        results = new Team.Models.Position(positionSeedData.unitType, positionSeedData);
                    }
                }
                return results;
            };
            PositionDefault.prototype.switchPosition = function (fromPosition, toPositionEnum) {
                var newPosition = this.getPosition(toPositionEnum);
                newPosition.index = fromPosition.index;
                return newPosition;
            };
            PositionDefault.getBlank = function (type) {
                var collection = new Team.Models.PositionCollection(type);
                var positionSeedData = null;
                switch (type) {
                    case Team.Enums.UnitTypes.Offense:
                        positionSeedData = Team.Models.PositionDefault.defaults.blankOffense;
                        break;
                    case Team.Enums.UnitTypes.Defense:
                        positionSeedData = Team.Models.PositionDefault.defaults.blankDefense;
                        break;
                    case Team.Enums.UnitTypes.SpecialTeams:
                        positionSeedData = Team.Models.PositionDefault.defaults.blankSpecialTeams;
                        break;
                    case Team.Enums.UnitTypes.Other:
                        positionSeedData = Team.Models.PositionDefault.defaults.blankOther;
                        break;
                }
                if (!positionSeedData)
                    return null;
                for (var i = 0; i < 11; i++) {
                    var blank = new Team.Models.Position(positionSeedData.unitType, positionSeedData);
                    // add an index for the position :]
                    blank.index = i;
                    collection.add(blank);
                }
                return collection;
            };
            PositionDefault.prototype.getByUnitType = function (type) {
                var results = new Team.Models.PositionCollection(type);
                switch (type) {
                    case Team.Enums.UnitTypes.Offense:
                        results.fromJson([
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.blankOffense),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.quarterback),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.runningBack),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.fullBack),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.tightEnd),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.center),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.guard),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.tackle),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.wideReceiver),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.slotReceiver)
                        ]);
                        break;
                    case Team.Enums.UnitTypes.Defense:
                        results.fromJson([
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.blankDefense),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.noseGuard),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.defensiveTackle),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.defensiveGuard),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.defensiveEnd),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.linebacker),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.safety),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.freeSafety),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.strongSafety),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.defensiveBack),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.cornerback)
                        ]);
                        break;
                    case Team.Enums.UnitTypes.SpecialTeams:
                        results.fromJson([
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.blankSpecialTeams),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.kicker),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.holder),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.punter),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.longSnapper),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.kickoffSpecialist),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.puntReturner),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.kickReturner),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.upback),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.gunner),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.jamme)
                        ]);
                        break;
                    case Team.Enums.UnitTypes.Other:
                        results.fromJson([
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.blankOther),
                            new Team.Models.Position(type, Team.Models.PositionDefault.defaults.other)
                        ]);
                        break;
                    default:
                        results = null;
                        break;
                }
                return results;
            };
            ;
            return PositionDefault;
        })();
        Models.PositionDefault = PositionDefault;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var PositionCollection = (function (_super) {
            __extends(PositionCollection, _super);
            function PositionCollection(unitType) {
                _super.call(this);
                this.unitType = unitType;
                this.setDefault();
            }
            PositionCollection.prototype.listPositions = function () {
                var arr = [];
                this.forEach(function (position, index) {
                    arr.push(position.title);
                });
                return arr;
            };
            PositionCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            PositionCollection.prototype.fromJson = function (positions) {
                if (!positions)
                    return;
                for (var i = 0; i < positions.length; i++) {
                    var rawPosition = positions[i];
                    if (Common.Utilities.isNullOrUndefined(rawPosition))
                        continue;
                    rawPosition.unitType = Common.Utilities.isNotNullOrUndefined(rawPosition.unitType) &&
                        rawPosition.unitType >= 0 ? rawPosition.unitType : Team.Enums.UnitTypes.Other;
                    var positionModel = new Team.Models.Position(rawPosition.unitType);
                    positionModel.fromJson(rawPosition);
                    this.add(positionModel);
                }
            };
            PositionCollection.prototype.setDefault = function () {
            };
            return PositionCollection;
        })(Common.Models.Collection);
        Models.PositionCollection = PositionCollection;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var UnitType = (function (_super) {
            __extends(UnitType, _super);
            function UnitType(unitType, name) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.unitType = unitType;
                this.name = name;
            }
            UnitType.getUnitTypes = function () {
                return Common.Utilities.convertEnumToList(Team.Enums.UnitTypes);
            };
            UnitType.prototype.toJson = function () {
                var json = {
                    unitType: this.unitType,
                    name: this.name,
                    guid: this.guid
                };
                return json;
            };
            UnitType.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.unitType = json.unitType;
                this.name = json.name;
                this.guid = json.guid;
            };
            return UnitType;
        })(Common.Models.Modifiable);
        Models.UnitType = UnitType;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='./models.ts' />
var Team;
(function (Team) {
    var Models;
    (function (Models) {
        var UnitTypeCollection = (function (_super) {
            __extends(UnitTypeCollection, _super);
            function UnitTypeCollection() {
                _super.call(this);
                var offense = new Team.Models.UnitType(Team.Enums.UnitTypes.Offense, 'offense');
                this.add(offense);
                var defense = new Team.Models.UnitType(Team.Enums.UnitTypes.Defense, 'defense');
                this.add(defense);
                var specialTeams = new Team.Models.UnitType(Team.Enums.UnitTypes.SpecialTeams, 'special teams');
                this.add(specialTeams);
                var other = new Team.Models.UnitType(Team.Enums.UnitTypes.Other, 'other');
                this.add(other);
            }
            UnitTypeCollection.prototype.getByUnitType = function (unitTypeValue) {
                return this.filterFirst(function (unitType) {
                    return unitType.unitType == unitTypeValue;
                });
            };
            UnitTypeCollection.prototype.getAssociatedPlaybooks = function () {
                var collection = new Common.Models.PlaybookModelCollection(Team.Enums.UnitTypes.Mixed);
                this.forEach(function (unitType, index) {
                    if (unitType && unitType.associated &&
                        unitType.associated.playbooks &&
                        unitType.associated.playbooks.hasElements()) {
                        unitType.associated.playbooks.forEach(function (guid, i) {
                            var playbookModel = impakt.context.Playbook.playbooks.get(guid);
                            if (playbookModel) {
                                collection.add(playbookModel);
                            }
                        });
                    }
                });
                return collection;
            };
            UnitTypeCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            // takes an unprocessed arry of playbooks from the server
            // and adds them into the collection and sub collections
            UnitTypeCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid || this.guid;
            };
            return UnitTypeCollection;
        })(Common.Models.Collection);
        Models.UnitTypeCollection = UnitTypeCollection;
    })(Models = Team.Models || (Team.Models = {}));
})(Team || (Team = {}));
/// <reference path='../team.ts' />
/// <reference path='./TeamModel.ts' />
/// <reference path='./TeamModelCollection.ts' />
/// <reference path='./TeamRecord.ts' />
/// <reference path='./TeamRecordCollection.ts' />
/// <reference path='./PrimaryTeam.ts' />
/// <reference path='./OpponentTeam.ts' />
/// <reference path='./Personnel.ts' />
/// <reference path='./PersonnelCollection.ts' />
/// <reference path='./Position.ts' />
/// <reference path='./PositionCollection.ts' />
/// <reference path='./UnitType.ts' />
/// <reference path='./UnitTypeCollection.ts' /> 
/// <references path='../team.ts' />
/// <references path='./ITeam.ts' />
/// <reference path='../team.ts' />
var Team;
(function (Team) {
    var Enums;
    (function (Enums) {
        (function (UnitTypes) {
            UnitTypes[UnitTypes["Offense"] = 0] = "Offense";
            UnitTypes[UnitTypes["Defense"] = 1] = "Defense";
            UnitTypes[UnitTypes["SpecialTeams"] = 2] = "SpecialTeams";
            UnitTypes[UnitTypes["Other"] = 3] = "Other";
            UnitTypes[UnitTypes["Mixed"] = 4] = "Mixed";
        })(Enums.UnitTypes || (Enums.UnitTypes = {}));
        var UnitTypes = Enums.UnitTypes;
        (function (TeamTypes) {
            TeamTypes[TeamTypes["Primary"] = 0] = "Primary";
            TeamTypes[TeamTypes["Opponent"] = 1] = "Opponent";
            TeamTypes[TeamTypes["Other"] = 2] = "Other";
            TeamTypes[TeamTypes["Mixed"] = 3] = "Mixed";
        })(Enums.TeamTypes || (Enums.TeamTypes = {}));
        var TeamTypes = Enums.TeamTypes;
    })(Enums = Team.Enums || (Team.Enums = {}));
})(Team || (Team = {}));
/// <reference path='../modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='./interfaces/interfaces.ts' />
/// <reference path='./enums/enums.ts' />
/// <reference path='../modules.ts' />
/// <reference path='../modules.ts' />
/// <reference path='../modules.ts' />
/// <reference path='./models.ts' />
var Navigation;
(function (Navigation) {
    var Models;
    (function (Models) {
        var NavigationItem = (function (_super) {
            __extends(NavigationItem, _super);
            function NavigationItem(name, label, glyphicon, path, active, activationCallback) {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.name = name;
                this.label = label;
                this.glyphicon = glyphicon;
                this.path = path;
                this.active = active === true;
                this.activationCallback = activationCallback;
            }
            NavigationItem.prototype.activate = function () {
                this.active = true;
                this.activationCallback(this);
            };
            NavigationItem.prototype.deactivate = function () {
                this.active = false;
            };
            NavigationItem.prototype.toggleActivation = function () {
                this.active = !this.active;
                if (this.active === true)
                    this.activate();
            };
            return NavigationItem;
        })(Common.Models.Modifiable);
        Models.NavigationItem = NavigationItem;
    })(Models = Navigation.Models || (Navigation.Models = {}));
})(Navigation || (Navigation = {}));
/// <reference path='./models.ts' />
var Navigation;
(function (Navigation) {
    var Models;
    (function (Models) {
        var NavigationItemCollection = (function (_super) {
            __extends(NavigationItemCollection, _super);
            function NavigationItemCollection() {
                _super.call(this);
            }
            NavigationItemCollection.prototype.activate = function (navItem) {
                this.forEach(function (item, index) {
                    item.deactivate();
                });
                navItem.activate();
            };
            NavigationItemCollection.prototype.getActive = function () {
                return this.filterFirst(function (item, index) {
                    return item.active === true;
                });
            };
            return NavigationItemCollection;
        })(Common.Models.Collection);
        Models.NavigationItemCollection = NavigationItemCollection;
    })(Models = Navigation.Models || (Navigation.Models = {}));
})(Navigation || (Navigation = {}));
/// <reference path='../nav.ts' />
/// <reference path='./navigation.ts' />
/// <reference path='./NavigationItem.ts' />
/// <reference path='./NavigationItemCollection.ts' /> 
/// <reference path='../modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='../modules.ts' />
/// <reference path='./models.ts' />
var Season;
(function (Season) {
    var Models;
    (function (Models) {
        var SeasonModel = (function (_super) {
            __extends(SeasonModel, _super);
            function SeasonModel() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Season);
                this.year = (new Date()).getFullYear();
                this.start = new Common.Models.Datetime();
                this.weeks = new Season.Models.WeekCollection();
                this.associable = [
                    'leagues'
                ];
            }
            SeasonModel.prototype.copy = function (newSeason) {
                var copySeason = newSeason || new Season.Models.SeasonModel();
                return _super.prototype.copy.call(this, copySeason, this);
            };
            SeasonModel.prototype.toJson = function () {
                return $.extend({
                    weeks: this.weeks.toJson(),
                    year: this.year,
                    start: this.start.toJson()
                }, _super.prototype.toJson.call(this));
            };
            SeasonModel.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.year = json.year;
                this.weeks.fromJson(json.weeks);
                this.start.fromJson(json.start);
                _super.prototype.fromJson.call(this, json);
            };
            return SeasonModel;
        })(Common.Models.AssociableEntity);
        Models.SeasonModel = SeasonModel;
    })(Models = Season.Models || (Season.Models = {}));
})(Season || (Season = {}));
/// <reference path='./models.ts' />
var Season;
(function (Season) {
    var Models;
    (function (Models) {
        var SeasonModelCollection = (function (_super) {
            __extends(SeasonModelCollection, _super);
            function SeasonModelCollection() {
                _super.call(this);
            }
            SeasonModelCollection.prototype.toJson = function () {
                return null;
            };
            SeasonModelCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
                var seasonArray = json.seasons || [];
                for (var i = 0; i < seasonArray.length; i++) {
                    var rawSeasonModel = seasonArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawSeasonModel)) {
                        continue;
                    }
                    var seasonModel = new Season.Models.SeasonModel();
                    seasonModel.fromJson(rawSeasonModel);
                    this.add(seasonModel);
                }
            };
            return SeasonModelCollection;
        })(Common.Models.ActionableCollection);
        Models.SeasonModelCollection = SeasonModelCollection;
    })(Models = Season.Models || (Season.Models = {}));
})(Season || (Season = {}));
/// <reference path='./models.ts' />
var Season;
(function (Season) {
    var Models;
    (function (Models) {
        var Week = (function (_super) {
            __extends(Week, _super);
            function Week() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Unknown);
                this.name = null;
                this.number = 0;
                this.season = new Season.Models.SeasonModel();
                this.seasonGuid = '';
                this.start = new Common.Models.Datetime();
            }
            Week.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    number: this.number,
                    guid: this.guid,
                    seasonGuid: this.seasonGuid,
                    start: this.start.toJson()
                }, _super.prototype.toJson.call(this));
            };
            Week.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                this.number = json.number;
                this.seasonGuid = json.seasonGuid;
                this.start.fromJson(json.start);
                _super.prototype.fromJson.call(this, json);
            };
            Week.prototype.getFormattedName = function () {
                return this.name + ' ' + this.number;
            };
            Week.prototype.setSeason = function (season) {
                this.season = season;
                this.seasonGuid = this.season ? this.season.guid : '';
            };
            /**
             * Takes the given start Datetime and then increments the created
             * date with the given number of weeks (weekOffset)
             *
             * @param {Date}   start      [description]
             * @param {number} weekOffset [description]
             */
            Week.prototype.incrementWeek = function (start, addWeeks) {
                this.start.date = (moment(start.date).add(addWeeks, 'week'))._d;
            };
            /**
             * Takes the given start Datetime and subtracts the given number of
             * weeks from that date.
             *
             * @param {Common.Models.Datetime} start         [description]
             * @param {number}                 subtractWeeks [description]
             */
            Week.prototype.decrementWeek = function (start, subtractWeeks) {
                this.start.date = (moment(start.date).subtract(subtractWeeks, 'week'))._d;
            };
            Week.prototype.getFormattedDate = function () {
                return this.start.getFormatted();
            };
            return Week;
        })(Common.Models.Actionable);
        Models.Week = Week;
    })(Models = Season.Models || (Season.Models = {}));
})(Season || (Season = {}));
/// <reference path='./models.ts' />
var Season;
(function (Season) {
    var Models;
    (function (Models) {
        var WeekCollection = (function (_super) {
            __extends(WeekCollection, _super);
            function WeekCollection() {
                _super.call(this);
            }
            WeekCollection.prototype.toJson = function () {
                return {
                    guid: this.guid,
                    weeks: _super.prototype.toJson.call(this)
                };
            };
            WeekCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
                var weekArray = json.weeks || [];
                for (var i = 0; i < weekArray.length; i++) {
                    var rawWeekModel = weekArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawWeekModel)) {
                        continue;
                    }
                    var weekModel = new Season.Models.Week();
                    weekModel.fromJson(rawWeekModel);
                    this.add(weekModel);
                }
            };
            return WeekCollection;
        })(Common.Models.ActionableCollection);
        Models.WeekCollection = WeekCollection;
    })(Models = Season.Models || (Season.Models = {}));
})(Season || (Season = {}));
/// <reference path='./models.ts' />
var Season;
(function (Season) {
    var Models;
    (function (Models) {
        var Game = (function (_super) {
            __extends(Game, _super);
            function Game() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Game);
                this.start = new Common.Models.Datetime();
                this.location = new League.Models.Location();
                this.locationGuid = '';
                this.home = new Team.Models.TeamModel();
                this.homeGuid = '';
                this.away = new Team.Models.TeamModel();
                this.awayGuid = '';
                this.week = new Season.Models.Week();
                this.weekGuid = '';
                this.outcome = null;
                this.season = null;
                this.seasonGuid = '';
                this.associable = [
                    'seasons',
                    'teams',
                    'locations',
                    'playbooks'
                ];
            }
            Game.prototype.copy = function (newGame) {
                var copyGame = newGame || new Season.Models.Game();
                return _super.prototype.copy.call(this, copyGame, this);
            };
            Game.prototype.toJson = function () {
                return $.extend({
                    start: this.start.toJson(),
                    locationGuid: this.locationGuid,
                    homeGuid: this.homeGuid,
                    awayGuid: this.awayGuid,
                    seasonGuid: this.seasonGuid,
                    weekGuid: this.weekGuid
                }, _super.prototype.toJson.call(this));
            };
            Game.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.start.fromJson(json.start);
                this.locationGuid = json.locationGuid;
                this.homeGuid = json.homeGuid;
                this.awayGuid = json.awayGuid;
                this.seasonGuid = json.seasonGuid;
                this.weekGuid = json.weekGuid;
                _super.prototype.fromJson.call(this, json);
            };
            Game.prototype.getFormattedName = function () {
                return this.away && this.home ? [this.away.name, ' @ ', this.home.name].join('') : this.name;
            };
            Game.prototype.setSeason = function (season) {
                this.season = season;
                this.seasonGuid = this.season ? this.season.guid : '';
            };
            Game.prototype.setWeek = function (week) {
                this.week = week;
                this.weekGuid = this.week ? this.week.guid : '';
            };
            Game.prototype.setLocation = function (location) {
                this.location = location;
                this.locationGuid = this.location ? this.location.guid : '';
            };
            Game.prototype.setHome = function (home) {
                this.home = home;
                this.homeGuid = this.home ? this.home.guid : '';
                this.name = this.getFormattedName();
            };
            Game.prototype.setAway = function (away) {
                this.away = away;
                this.awayGuid = this.away ? this.away.guid : '';
                this.name = this.getFormattedName();
            };
            return Game;
        })(Common.Models.AssociableEntity);
        Models.Game = Game;
    })(Models = Season.Models || (Season.Models = {}));
})(Season || (Season = {}));
/// <reference path='./models.ts' />
var Season;
(function (Season) {
    var Models;
    (function (Models) {
        var GameCollection = (function (_super) {
            __extends(GameCollection, _super);
            function GameCollection() {
                _super.call(this);
            }
            GameCollection.prototype.toJson = function () {
                return {
                    guid: this.guid,
                    games: _super.prototype.toJson.call(this)
                };
            };
            GameCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
                var gameArray = json.games || [];
                for (var i = 0; i < gameArray.length; i++) {
                    var rawGameModel = gameArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawGameModel)) {
                        continue;
                    }
                    var gameModel = new Season.Models.Game();
                    gameModel.fromJson(rawGameModel);
                    this.add(gameModel);
                }
            };
            return GameCollection;
        })(Common.Models.ActionableCollection);
        Models.GameCollection = GameCollection;
    })(Models = Season.Models || (Season.Models = {}));
})(Season || (Season = {}));
/// <reference path='../season.ts' />
/// <reference path='./SeasonModel.ts' />
/// <reference path='./SeasonModelCollection.ts' />
/// <reference path='./Week.ts' />
/// <reference path='./WeekCollection.ts' />
/// <reference path='./Game.ts' />
/// <reference path='./GameCollection.ts' />
/// <reference path='../modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var LeagueModel = (function (_super) {
            __extends(LeagueModel, _super);
            function LeagueModel() {
                _super.call(this, Common.Enums.ImpaktDataTypes.League);
                this.associable = [
                    'conferences',
                    'divisions',
                    'teams'
                ];
            }
            LeagueModel.prototype.copy = function (newLeague) {
                var copyLeague = newLeague || new League.Models.LeagueModel();
                return _super.prototype.copy.call(this, copyLeague, this);
            };
            LeagueModel.prototype.toJson = function () {
                return $.extend({
                    name: this.name
                }, _super.prototype.toJson.call(this));
            };
            LeagueModel.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                _super.prototype.fromJson.call(this, json);
            };
            return LeagueModel;
        })(Common.Models.AssociableEntity);
        Models.LeagueModel = LeagueModel;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var LeagueModelCollection = (function (_super) {
            __extends(LeagueModelCollection, _super);
            function LeagueModelCollection() {
                _super.call(this);
            }
            return LeagueModelCollection;
        })(Common.Models.ActionableCollection);
        Models.LeagueModelCollection = LeagueModelCollection;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var Conference = (function (_super) {
            __extends(Conference, _super);
            function Conference() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Conference);
                this.name = null;
                this.league = null;
                this.leagueGuid = '';
                this.associable = [
                    'leagues',
                    'divisions',
                    'teams'
                ];
            }
            Conference.prototype.copy = function (newConference) {
                var copyConference = newConference || new League.Models.Conference();
                return _super.prototype.copy.call(this, copyConference, this);
            };
            Conference.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    png: this.png,
                    leagueGuid: this.leagueGuid
                }, _super.prototype.toJson.call(this));
            };
            Conference.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                this.png = json.png;
                this.leagueGuid = json.leagueGuid;
                _super.prototype.fromJson.call(this, json);
            };
            Conference.prototype.setLeague = function (league) {
                this.league = league;
                this.leagueGuid = this.league ? this.league.guid : '';
            };
            return Conference;
        })(Common.Models.AssociableEntity);
        Models.Conference = Conference;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var ConferenceCollection = (function (_super) {
            __extends(ConferenceCollection, _super);
            function ConferenceCollection() {
                _super.call(this);
            }
            ConferenceCollection.prototype.toJson = function () {
                return {
                    guid: this.guid,
                    conferences: _super.prototype.toJson.call(this)
                };
            };
            ConferenceCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
                var conferenceArray = json.conferences || [];
                for (var i = 0; i < conferenceArray.length; i++) {
                    var rawConferenceModel = conferenceArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawConferenceModel)) {
                        continue;
                    }
                    var conferenceModel = new League.Models.Conference();
                    conferenceModel.fromJson(rawConferenceModel);
                    this.add(conferenceModel);
                }
            };
            return ConferenceCollection;
        })(Common.Models.ActionableCollection);
        Models.ConferenceCollection = ConferenceCollection;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var Division = (function (_super) {
            __extends(Division, _super);
            function Division() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Division);
                this.name = '';
                this.conference = null;
                this.conferenceGuid = '';
                this.associable = [
                    'leagues',
                    'conferences',
                    'teams'
                ];
            }
            Division.prototype.copy = function (newDivision) {
                var copyDivision = newDivision || new League.Models.Division();
                return _super.prototype.copy.call(this, copyDivision, this);
            };
            Division.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                    png: this.png,
                    conferenceGuid: this.conferenceGuid
                }, _super.prototype.toJson.call(this));
            };
            Division.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                this.png = json.png;
                this.conferenceGuid = json.conferenceGuid;
                _super.prototype.fromJson.call(this, json);
            };
            Division.prototype.setConference = function (conference) {
                this.conference = conference;
                this.conferenceGuid = this.conference ? this.conference.guid : '';
            };
            return Division;
        })(Common.Models.AssociableEntity);
        Models.Division = Division;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var DivisionCollection = (function (_super) {
            __extends(DivisionCollection, _super);
            function DivisionCollection() {
                _super.call(this);
            }
            DivisionCollection.prototype.toJson = function () {
                return {
                    guid: this.guid,
                    divisions: _super.prototype.toJson.call(this)
                };
            };
            DivisionCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
                var divisionArray = json.divisions || [];
                for (var i = 0; i < divisionArray.length; i++) {
                    var rawDivisionModel = divisionArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawDivisionModel)) {
                        continue;
                    }
                    var divisionModel = new League.Models.Division();
                    divisionModel.fromJson(rawDivisionModel);
                    this.add(divisionModel);
                }
            };
            return DivisionCollection;
        })(Common.Models.ActionableCollection);
        Models.DivisionCollection = DivisionCollection;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='../league.ts' />
/// <reference path='./LeagueModel.ts' />
/// <reference path='./LeagueModelCollection.ts' />
/// <reference path='./Conference.ts' />
/// <reference path='./ConferenceCollection.ts' />
/// <reference path='./Division.ts' />
/// <reference path='./DivisionCollection.ts' />
/// <reference path='../modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='../modules.ts' />
/// <reference path='./models.ts' />
var User;
(function (User) {
    var Models;
    (function (Models) {
        var Organization = (function (_super) {
            __extends(Organization, _super);
            function Organization() {
                _super.call(this);
                _super.prototype.setContext.call(this, this);
                this.accountKey = 0;
                this.address1 = null;
                this.address2 = null;
                this.address3 = null;
                this.city = null;
                this.country = null;
                this.faxPrimary = null;
                this.inactive = false;
                this.name = null;
                this.notes = null;
                this.organizationKey = 0;
                this.otherDetails = null;
                this.phonePrimary = null;
                this.postalCode = null;
                this.primaryEmail = null;
                this.stateProvince = null;
            }
            Organization.prototype.toJson = function () {
                return {
                    accountKey: this.accountKey,
                    address1: this.address1,
                    address2: this.address2,
                    address3: this.address3,
                    city: this.city,
                    country: this.country,
                    faxPrimary: this.faxPrimary,
                    inactive: this.inactive,
                    name: this.name,
                    notes: this.notes,
                    organizationKey: this.organizationKey,
                    otherDetails: this.otherDetails,
                    phonePrimary: this.phonePrimary,
                    postalCode: this.postalCode,
                    primaryEmail: this.primaryEmail,
                    stateProvince: this.stateProvince
                };
            };
            Organization.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.accountKey = json.accountKey;
                this.address1 = json.address1;
                this.address2 = json.address2;
                this.address3 = json.address3;
                this.city = json.city;
                this.country = json.country;
                this.faxPrimary = json.faxPrimary;
                this.inactive = json.inactive;
                this.name = json.name;
                this.notes = json.notes;
                this.organizationKey = json.organizationKey;
                this.otherDetails = json.otherDetails;
                this.phonePrimary = json.phonePrimary;
                this.postalCode = json.postalCode;
                this.primaryEmail = json.primaryEmail;
                this.stateProvince = json.stateProvince;
            };
            return Organization;
        })(Common.Models.Modifiable);
        Models.Organization = Organization;
    })(Models = User.Models || (User.Models = {}));
})(User || (User = {}));
/// <reference path='./models.ts' />
var User;
(function (User) {
    var Models;
    (function (Models) {
        var OrganizationCollection = (function (_super) {
            __extends(OrganizationCollection, _super);
            function OrganizationCollection() {
                _super.call(this);
            }
            OrganizationCollection.prototype.toJson = function () {
                return _super.prototype.toJson.call(this);
            };
            OrganizationCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                throw new Error('OrganizationCollection fromJson(): not implemented');
            };
            return OrganizationCollection;
        })(Common.Models.Collection);
        Models.OrganizationCollection = OrganizationCollection;
    })(Models = User.Models || (User.Models = {}));
})(User || (User = {}));
/// <reference path='../user.ts' />
/// <reference path='./Organization.ts' />
/// <reference path='./OrganizationCollection.ts' />
/// <reference path='../modules.ts' />
/// <reference path='./models/models.ts' />
/// <reference path='../common/common.ts' />
/// <reference path='./playbook/playbook.ts' />
/// <reference path='./team/team.ts' />
/// <reference path='./analysis/analysis.ts' />
/// <reference path='./home/home.ts' />
/// <reference path='./planning/planning.ts' />
/// <reference path='./nav/nav.ts' />
/// <reference path='./search/search.ts' />
/// <reference path='./season/season.ts' />
/// <reference path='./league/league.ts' />
/// <reference path='./stats/stats.ts' />
/// <reference path='./user/user.ts' /> 
/// <reference path='../modules/modules.ts' />
// global impakt namespace
var impakt = {};
// global application context storage
impakt.context = {};
impakt.app = angular.module('impakt.app', [
    // module registration
    'ui.router',
    'ui.bootstrap',
    'impakt.common',
    'impakt.modules',
    'ngTagsInput'
])
    .config([
    '$stateProvider',
    '$urlRouterProvider',
    '$httpProvider',
    '$sceDelegateProvider',
    function ($stateProvider, $urlRouterProvider, $httpProvider, $sceDelegateProvider) {
        //Reset headers to avoid OPTIONS request (aka preflight)
        // $httpProvider.defaults.headers.common = {};
        // $httpProvider.defaults.headers.post = {};
        // $httpProvider.defaults.headers.put = {};
        // $httpProvider.defaults.headers.patch = {};
        $sceDelegateProvider.resourceUrlWhitelist([
            'self',
            'https://test-impakt.azurewebsites.net/**',
            'http://test.impaktathletics.com/**',
            '*'
        ]);
        //$urlRouterProvider.otherwise('/');
        // impakt module states - should these be module-specific?
        $stateProvider
            .state('home', {
            url: '/home',
            templateUrl: 'modules/home/home.tpl.html'
        })
            .state('team', {
            url: '/team',
            templateUrl: 'modules/team/team.tpl.html'
        })
            .state('planning', {
            url: '/planning',
            templateUrl: 'modules/planning/planning.tpl.html'
        })
            .state('analysis', {
            url: '/analysis',
            templateUrl: 'modules/analysis/analysis.tpl.html'
        })
            .state('profile', {
            url: '/profile',
            templateUrl: 'modules/user/user.tpl.html'
        });
        // TODO @theBull - implement
        // .state('film', {
        // 	url: '/film',
        // 	templateUrl: 'modules/film/film.tpl.html'
        // })
        // .state('stats', {
        // 	url: '/stats',
        // 	templateUrl: 'modules/stats/stats.tpl.html'
        // });
        console.debug('impakt.app - config');
    }])
    .run([
    '$http',
    '$window',
    '__auth',
    '__localStorage',
    '__context',
    '__notifications',
    '_user',
    function ($http, $window, __auth, __localStorage, __context, __notifications, _user) {
        console.debug('impakt - running');
        var accessToken = __localStorage.getAccessToken();
        if (accessToken) {
            $http.defaults.headers.common.Authorization = 'Bearer ' + accessToken;
            var notification = __notifications.pending('Initializing user...');
            _user.initialize().then(function () {
                notification.success('User successfully initialized');
            }, function (err) {
                notification.error('Failed to initialize user');
            });
        }
        else {
            $window.location.href = '/signin.html';
        }
    }]);
impakt.signin = angular.module('impakt.signin', [
    // module registration
    'ui.router',
    'ui.bootstrap',
    'impakt.common'
])
    .config([function () {
        console.debug('impakt.signin - config');
    }])
    .run([
    '$http',
    '$window',
    '$location',
    '$rootScope',
    '__signin',
    function ($http, $window, $location, $rootScope, __signin) {
        console.debug('impakt.signin - running');
        // TODO: Change to application/json?
        $http.defaults.headers.common =
            { 'Content-Type': 'application/json' };
        // attempt login
        //__signin.signin();
    }]);
/// <reference path='../js/impakt.ts' />
/// <reference path='./common.ts' />
impakt.common = angular.module('impakt.common', [
    'impakt.common.api',
    'impakt.common.auth',
    'impakt.common.contextmenu',
    'impakt.common.context',
    'impakt.common.associations',
    'impakt.common.base',
    'impakt.common.scrollable',
    'impakt.common.modals',
    'impakt.common.localStorage',
    'impakt.common.parser',
    'impakt.common.signin',
    'impakt.common.locale',
    'impakt.common.ui',
    'impakt.common.notifications'
])
    .config(function () {
    console.debug('impakt.common - config');
})
    .run(function () {
    console.debug('impakt.common - run');
});
/// <reference path='../common.mdl.ts' />
impakt.common.api = angular.module('impakt.common.api', [])
    .config([function () {
        console.debug('impakt.common.api - config');
    }])
    .run([function () {
        console.debug('impakt.common.api - run');
    }]);
/// <reference path='./api.mdl.ts' />
impakt.common.api.constant('API', {
    'VERSION': 0.01,
    'HOST_URL': 'https://test.impaktathletics.com',
    //'HOST_URL': 'https://test-impakt.azurewebsites.net',
    'ENDPOINT': '/api',
});
/// <reference path='./api.mdl.ts' />
impakt.common.api.factory('__api', [
    'API',
    'AUTH',
    '$http',
    '$q',
    '__localStorage',
    function (API, AUTH, $http, $q, __localStorage) {
        var self = {
            post: post,
            get: get,
            path: path
        };
        function post(endpointUrl, data) {
            if (!data.OrganizationKey)
                data.OrganizationKey = __localStorage.getOrganizationKey();
            var d = $q.defer();
            $http({
                method: 'POST',
                url: path(API.HOST_URL, API.ENDPOINT, endpointUrl),
                data: JSON.stringify(data),
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(function (data) {
                // TODO: handle statuses manually
                //console.log(data);
                d.resolve(data);
            }, function (err) {
                console.error(err);
                d.reject(err);
            });
            return d.promise;
        }
        function get(endpointUrl, data) {
            var d = $q.defer();
            $http({
                method: 'POST',
                url: path(API.HOST_URL, API.ENDPOINT, endpointUrl),
                headers: {
                    'X-HTTP-Method-Override': 'GET',
                    'Content-Type': 'application/json'
                },
                data: $.extend({
                    "OrganizationKey": __localStorage.getOrganizationKey()
                }, data)
            }).then(function (data) {
                // TODO: handle statuses manually
                //console.log(data);
                d.resolve(data);
            }, function (err) {
                console.error(err);
                d.reject(err);
            });
            return d.promise;
        }
        function path() {
            var segments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                segments[_i - 0] = arguments[_i];
            }
            return segments.join('');
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.auth = angular.module('impakt.common.auth', []);
/// <reference path='./auth.mdl.ts' />
impakt.common.auth.constant('AUTH', {
    'TOKEN_ENDPOINT': '/token',
    'HANDSHAKE_DUMMY': 'grant_type=password&username=fredf@imanufacture.com&Password=Abc123',
    'CREATE_ORGANIZATION': '/configuration/createOrganization',
});
/// <reference path='./auth.mdl.ts' />
(function () {
    var name = '__auth';
    impakt.common.auth.factory(name, [
        'AUTH', 'API', '$http', '$q', '__api',
        function (AUTH, API, $http, $q, __api) {
            var self = {
                getToken: getToken
            };
            function getToken(username, password) {
                var d = $q.defer();
                var data = [
                    'grant_type=password',
                    '&username=', encodeURIComponent(username),
                    '&Password=', password
                ].join('');
                $http({
                    method: 'POST',
                    url: __api.path(API.HOST_URL, AUTH.TOKEN_ENDPOINT),
                    data: data,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }).then(function (data) {
                    // TODO: handle statuses manually
                    console.log(data);
                    d.resolve(data);
                }, function (err) {
                    console.error(err);
                    d.reject(err);
                });
                return d.promise;
            }
            function createOrganization(organization) {
                var orgData = organization.toJson();
            }
            return self;
        }]);
})();
/// <reference path='../common.mdl.ts' />
/**
 * Defines a common base module for shared and inherited
 * components, such as base services and controllers.
 */
impakt.common.base = angular.module('impakt.common.base', [])
    .config(function () {
    console.debug('impakt.common.base - config');
})
    .run(function () {
    console.debug('impakt.common.base - run');
});
/// <reference path='./base.mdl.ts' />
/**
 * Defines a base service structure with methods that most
 * impakt module-level services will need.
 */
impakt.common.base.service('_base', ['$rootScope', function ($rootScope) {
        console.debug('service: impakt.common.base');
        /**
         * Register all components expected to be made ready.
         *
         * "Components" are other angular services, controllers,
         * or directives that need to have been loaded in order for
         * the editor to be truly ready for service.
         *
         * Components can notify to this service when they are
         * loading and when they have completely loaded. This
         * service can then in turn identify if it is
         * ready based on whether all of the components it is
         * expecting a 'componentLoaded' call from have been
         * called. Once all expected components have reported
         * that they are ready, we can use a ready event in the
         * service to initiate further commands.
         *
         * The name of each expected component should match the
         * string name given to angular to construct the given
         * component.
         */
        var components = new Common.Base.ComponentMap();
        this.loadComponent = function (component) {
            //console.log('component loaded', component);
            this.registerComponent(component);
            if (component.loaded)
                component.ready();
        };
        this.registerComponent = function (component) {
            components[component.guid] = component;
        };
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.associations = angular.module('impakt.common.associations', [])
    .config([function () {
        console.debug('impakt.common.associations - config');
    }])
    .run([function () {
        console.debug('impakt.common.associations - run');
    }]);
/// <reference path='./associations.mdl.ts' />
impakt.common.associations.constant('ASSOCIATIONS', {
    'ENDPOINT': '/general',
    // Methods
    GET_ASSOCIATIONS_FOR_CONTEXT: '/getAssociationsForContext',
    GET_ASSOCIATIONS_FOR_ENTITY: '/getAssociationsForEntity',
    UPDATE_ASSOCIATIONS: '/updateAssociations',
    DELETE_ASSOCIATIONS: '/deleteAssociations',
});
/// <reference path='./associations.mdl.ts' />
// Association service
impakt.common.associations.service('_associations', [
    'ASSOCIATIONS',
    '$rootScope',
    '$q',
    '__api',
    '__localStorage',
    '__notifications',
    function (ASSOCIATIONS, $rootScope, $q, __api, __localStorage, __notifications) {
        /**
         * Global associations model;
         *
         * Manages associations between all entities/entityTypes
         * as a bi-directional association.
         *
         */
        var organizationKey = __localStorage.getOrganizationKey();
        this.associations = new Common.Models.AssociationCollection(organizationKey);
        /**
         * Get associations by context (organization key)
         */
        this.getAssociationsByContextId = function () {
            var d = $q.defer();
            // Get organization key
            var organizationKey = __localStorage.getOrganizationKey();
            var notification = __notifications.pending('Retrieving Association data for Organization ', organizationKey, '...');
            if (Common.Utilities.isNullOrUndefined(organizationKey)) {
                notification.error('Failed to retrieve associations for Organization ', organizationKey, '');
                d.reject(['Organization Key is invalid when attempting\
				 to request all Associations: (', organizationKey, ')'].join(''));
            }
            // make request
            __api.get(__api.path(ASSOCIATIONS.ENDPOINT, ASSOCIATIONS.GET_ASSOCIATIONS_FOR_CONTEXT), {
                contextId: organizationKey + ''
            }).then(function (associations) {
                var collection = new Common.Models.AssociationCollection(organizationKey);
                if (associations && associations.data && associations.data.results) {
                    collection.fromJson(associations.data.results);
                }
                notification.success(collection.size(), ' Associations successfully retrieved');
                d.resolve(collection);
            }, function (err) {
                notification.error('Failed to retrieve Associations for Organization ', organizationKey, '');
                d.reject(err);
            });
            return d.promise;
        };
        /**
        * Get associations by entity key
        */
        this.getAssociationsByEntityKey = function () {
        };
        /**
        * Update assocations
        */
        this.updateAssociations = function () {
            var d = $q.defer();
            var organizationKey = __localStorage.getOrganizationKey();
            var notification = __notifications.pending('Updating data associations...');
            var associationsJson = impakt.context.Associations.associations.toJson();
            __api.post(__api.path(ASSOCIATIONS.ENDPOINT, ASSOCIATIONS.UPDATE_ASSOCIATIONS), {
                version: 1,
                contextID: organizationKey + '',
                associations: associationsJson
            }).then(function (updatedAssociations) {
                notification.success(impakt.context.Associations.associations.size(), ' Associations successfully updated');
                $rootScope.$broadcast('associations-updated');
                d.resolve();
            }, function (err) {
                notification.error('Failed to update Associations');
                d.reject(err);
            });
            return d.promise;
        };
        /**
        * Delete associations
        */
        this.deleteAssociations = function (internalKey) {
            var d = $q.defer();
            var organizationKey = __localStorage.getOrganizationKey();
            var notification = __notifications.pending('Deleting ', 'data associations...');
            var associations = impakt.context.Associations.associations.delete(internalKey);
            __api.post(__api.path(ASSOCIATIONS.ENDPOINT, ASSOCIATIONS.UPDATE_ASSOCIATIONS), {
                contextID: organizationKey,
                associations: associations.toJson()
            }).then(function () {
                notification.success(associations.size(), ' Associations successfully deleted');
                $rootScope.$broadcast('associations-updated');
                d.resolve();
            }, function (err) {
                notification.error('Failed to update Associations');
                d.reject(err);
            });
            return d.promise;
        };
        /**
        * Delete association
        */
        this.deleteAssociation = function (fromEntity, toEntity) {
            var d = $q.defer();
            impakt.context.Associations.associations.disassociate(fromEntity, toEntity);
            var organizationKey = __localStorage.getOrganizationKey();
            var notification = __notifications.pending('Deleting association between ', fromEntity.name, ' and ', toEntity.name, '...');
            // NOTE:
            // 
            // need to also specify the "inverse" association, since
            // a single *peer* association between two entities
            // are inserted into the database (via this client code)
            // two at a time, one is the normal from/from-to/to association
            // and the 'inverse' is the from/to-to/from association, which
            // simply flips the from/to values as a second.
            // 
            __api.post(__api.path(ASSOCIATIONS.ENDPOINT, ASSOCIATIONS.DELETE_ASSOCIATIONS), {
                contextID: organizationKey,
                associations: [
                    {
                        fromType: fromEntity.impaktDataType,
                        fromKey: fromEntity.key,
                        toType: toEntity.impaktDataType,
                        toKey: toEntity.key,
                        associationType: Common.Enums.AssociationTypes.Peer
                    },
                    {
                        fromType: toEntity.impaktDataType,
                        fromKey: toEntity.key,
                        toType: fromEntity.impaktDataType,
                        toKey: fromEntity.key,
                        associationType: Common.Enums.AssociationTypes.Peer
                    }
                ]
            }).then(function () {
                notification.success('Association between ', fromEntity.name, ' and ', toEntity.name, ' successfully deleted');
                $rootScope.$broadcast('associations-updated');
                d.resolve();
            }, function (err) {
                notification.error('Failed to update Associations');
                d.reject(err);
            });
            return d.promise;
        };
        /**
        * Create association
        */
        this.createAssociation = function (fromEntity, toEntity) {
            var d = $q.defer();
            impakt.context.Associations.associations.add(fromEntity, toEntity);
            this.updateAssociations()
                .then(function () {
                d.resolve();
            }, function (err) {
                d.reject(err);
            });
            return d.promise;
        };
        this.createAssociations = function (fromEntity, associatedEntities) {
            var d = $q.defer();
            impakt.context.Associations.associations.addAll(fromEntity, associatedEntities);
            this.updateAssociations()
                .then(function () {
                d.resolve();
            }, function (err) {
                d.reject(err);
            });
            return d.promise;
        };
        /**
         * Gets all associated entities for the given IAssociable.
         *
         * @param  {Common.Interfaces.IAssociable} entity The entity for which to find associated entities
         * @return {any}                                  returns an object literal which contains
         *                                                a key representing each type of entity collection
         *                                                (playbooks, plays, formations, etc.), and
         *                                                a corresponding collection of that entity type,
         *                                                which will be empty if no associations of that
         *                                                type are found, or will be populated with entities
         *                                                of the given type if associations are found
         */
        this.getAssociated = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity.associationKey))
                return;
            // 
            // Gets the associations for the given entity by its associationKey
            // 
            var associations = impakt.context.Associations.associations.getByInternalKey(entity.associationKey);
            // Instantiate the set of association collections for the given
            // entity.
            // NOTE: the return type of this function must mimic the typed contents
            // of this results object
            var results = new Common.Models.AssociationResults();
            //
            // Clients of this service should expect to receive back
            // a resulting set of associations, even if the collections
            // are empty. This should help prevent null pointer exceptions
            // when attempting to create ng-repeat bindings in the view logic
            // which rely on use of the .toArray() method on the given
            // collection.
            // 
            if (Common.Utilities.isNullOrUndefined(associations) ||
                associations.length == 0)
                return results;
            // Iterate over the entity's associations and parse each one
            // to:
            // 1. retrieve its guid
            // 2. determine its type
            // 3. make a query to the correct app. context collection
            for (var i = 0; i < associations.length; i++) {
                // each element in the associations array is in 'internalKey' structure
                // i.e. '<type>|<key>|<guid>''; parse(...) yields an
                // AssociationParts object with the corresponding and correctly typed values
                var associationParts = Common.Models.Association.parse(associations[i]);
                if (Common.Utilities.isNullOrUndefined(associationParts))
                    continue;
                var guid = associationParts.entityGuid;
                var type = associationParts.entityType;
                //
                // Gets the appropriate application context collection 
                // for the given entity's impakt data type enum value
                // 
                switch (type) {
                    case Common.Enums.ImpaktDataTypes.Playbook:
                        var playbook_1 = impakt.context.Playbook.playbooks.get(guid);
                        if (playbook_1)
                            results.playbooks.add(playbook_1);
                        break;
                    case Common.Enums.ImpaktDataTypes.Scenario:
                        var scenario = impakt.context.Playbook.scenarios.get(guid);
                        if (scenario)
                            results.scenarios.add(scenario);
                        break;
                    case Common.Enums.ImpaktDataTypes.Play:
                        var play = impakt.context.Playbook.plays.get(guid);
                        if (play)
                            results.plays.add(play);
                        break;
                    case Common.Enums.ImpaktDataTypes.Formation:
                        var formation = impakt.context.Playbook.formations.get(guid);
                        if (formation)
                            results.formations.add(formation);
                        break;
                    case Common.Enums.ImpaktDataTypes.PersonnelGroup:
                        var personnel = impakt.context.Team.personnel.get(guid);
                        if (personnel)
                            results.personnel.add(personnel);
                        break;
                    case Common.Enums.ImpaktDataTypes.AssignmentGroup:
                        var assignmentGroup = impakt.context.Playbook.assignmentGroups.get(guid);
                        if (assignmentGroup)
                            results.assignmentGroups.add(assignmentGroup);
                        break;
                    case Common.Enums.ImpaktDataTypes.League:
                        var league = impakt.context.League.leagues.get(guid);
                        if (league)
                            results.leagues.add(league);
                        break;
                    case Common.Enums.ImpaktDataTypes.Conference:
                        var conference = impakt.context.League.conferences.get(guid);
                        if (conference)
                            results.conferences.add(conference);
                        break;
                    case Common.Enums.ImpaktDataTypes.Division:
                        var division = impakt.context.League.divisions.get(guid);
                        if (division)
                            results.divisions.add(division);
                        break;
                    case Common.Enums.ImpaktDataTypes.Team:
                        var team = impakt.context.Team.teams.get(guid);
                        if (team)
                            results.teams.add(team);
                        break;
                    case Common.Enums.ImpaktDataTypes.Location:
                        var location_1 = impakt.context.League.locations.get(guid);
                        if (location_1)
                            results.locations.add(location_1);
                        break;
                    case Common.Enums.ImpaktDataTypes.Season:
                        var season = impakt.context.Season.seasons.get(guid);
                        if (season)
                            results.seasons.add(season);
                        break;
                    case Common.Enums.ImpaktDataTypes.Game:
                        var game = impakt.context.Season.games.get(guid);
                        if (game)
                            results.games.add(game);
                        break;
                }
            }
            return results;
        };
        this.associationExists = function (fromInternalKey, toInternalKey) {
            return this.associations.associationExists(fromInternalKey, toInternalKey);
        };
        this.getContextDataByKey = function (key) {
            if (Common.Utilities.isNullOrUndefined(key))
                throw new Error('_associations getContextDataByKey(): key is null or undefined');
            var collection;
            switch (key) {
                case 'playbooks':
                    collection = impakt.context.Playbook.playbooks;
                    break;
                case 'scenarios':
                    collection = impakt.context.Playbook.scenarios;
                    break;
                case 'plays':
                    collection = impakt.context.Playbook.plays;
                    break;
                case 'formations':
                    collection = impakt.context.Playbook.formations;
                    break;
                case 'personnel':
                    collection = impakt.context.Team.personnel;
                    break;
                case 'assignmentGroups':
                    collection = impakt.context.Playbook.assignmentGroups;
                    break;
                case 'leagues':
                    collection = impakt.context.League.leagues;
                    break;
                case 'conferences':
                    collection = impakt.context.League.conferences;
                    break;
                case 'divisions':
                    collection = impakt.context.League.divisions;
                    break;
                case 'locations':
                    collection = impakt.context.League.locations;
                    break;
                case 'teams':
                    collection = impakt.context.Team.teams;
                    break;
                case 'seasons':
                    collection = impakt.context.Season.seasons;
                    break;
                case 'games':
                    collection = impakt.context.Season.games;
                    break;
            }
            var parsedCollection = new Common.Models.ActionableCollection();
            if (Common.Utilities.isNotNullOrUndefined(collection)) {
                // create another reference of the entity into the parsed collection
                collection.forEach(function (element, index) {
                    parsedCollection.add(element, false);
                });
            }
            return parsedCollection;
        };
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.context = angular.module('impakt.common.context', [])
    .config([function () {
        console.debug('impakt.common.context - config');
    }])
    .run([function () {
        console.debug('impakt.common.context - run');
    }]);
/// <reference path='./context.mdl.ts' />
impakt.common.context.factory('__context', ['$q',
    '__api',
    '__localStorage',
    '__notifications',
    '_associations',
    '_playbook',
    '_league',
    '_season',
    '_team',
    function ($q, __api, __localStorage, __notifications, _associations, _playbook, _league, _season, _team) {
        var isReady = false;
        var readyCallbacks = [];
        var initializingCallbacks = [];
        function onReady(callback) {
            readyCallbacks.push(callback);
            if (isReady)
                ready();
        }
        function onInitializing(callback) {
            initializingCallbacks.push(callback);
        }
        function initializing() {
            for (var i = 0; i < initializingCallbacks.length; i++) {
                initializingCallbacks[i]();
            }
            initializingCallbacks = [];
        }
        function ready() {
            isReady = true;
            for (var i = 0; i < readyCallbacks.length; i++) {
                readyCallbacks[i]();
            }
            readyCallbacks = [];
        }
        var self = {
            initialize: initialize,
            onReady: onReady,
            onInitializing: onInitializing
        };
        if (!impakt.context.Actionable)
            impakt.context.Actionable = {};
        if (!impakt.context.Organization)
            impakt.context.Organization = {};
        if (!impakt.context.Associations) {
            impakt.context.Associations = {};
        }
        if (!impakt.context.Playbook)
            impakt.context.Playbook = {};
        if (!impakt.context.Team)
            impakt.context.Team = {};
        if (!impakt.context.League)
            impakt.context.League = {};
        if (!impakt.context.Season)
            impakt.context.Season = {};
        function initialize(context) {
            // notify listeners that context initialization
            // has begun
            initializing();
            var d = $q.defer();
            console.log('Making application context initialization requests');
            var organizationKey = __localStorage.getOrganizationKey();
            /**
             *
             *
             * Application-wide context data
             *
             *
             */
            /**
             * Organization context
             */
            // Set in user.srv
            // impakt.context.Organization.current = new User.Models.Organization();
            /**
             *
             *
             * Actionable context
             *
             *
             */
            impakt.context.Actionable.selected = new Common.Models.ActionableCollection();
            /**
             *
             *
             * Association context
             *
             *
             */
            impakt.context.Associations.associations = new Common.Models.AssociationCollection(organizationKey);
            impakt.context.Associations.creation = new Common.Models.AssociationCollection(organizationKey);
            /**
             *
             *
             * Playbook context
             *
             *
             */
            impakt.context.Playbook.playbooks = new Common.Models.PlaybookModelCollection(Team.Enums.UnitTypes.Mixed);
            impakt.context.Playbook.formations = new Common.Models.FormationCollection(Team.Enums.UnitTypes.Mixed);
            impakt.context.Playbook.assignmentGroups = new Common.Models.AssignmentGroupCollection(Team.Enums.UnitTypes.Mixed);
            impakt.context.Playbook.plays = new Common.Models.PlayCollection(Team.Enums.UnitTypes.Mixed);
            impakt.context.Playbook.scenarios = new Common.Models.ScenarioCollection(Team.Enums.UnitTypes.Other);
            /**
             * Module-specific context data; plays currently open in the editor
             */
            impakt.context.Playbook.editor = {
                plays: new Common.Models.PlayCollection(Team.Enums.UnitTypes.Mixed),
                tabs: new Common.Models.TabCollection(),
                scenarios: new Common.Models.ScenarioCollection(Team.Enums.UnitTypes.Other)
            };
            /**
             * A creation context for new plays and formations.
             */
            impakt.context.Playbook.creation = {
                plays: new Common.Models.PlayCollection(Team.Enums.UnitTypes.Mixed),
                formations: new Common.Models.FormationCollection(Team.Enums.UnitTypes.Mixed),
                scenarios: new Common.Models.ScenarioCollection(Team.Enums.UnitTypes.Other)
            };
            /**
             *
             *
             * Team context
             *
             *
             */
            impakt.context.Team.teams = new Team.Models.TeamModelCollection();
            impakt.context.Team.personnel = new Team.Models.PersonnelCollection(Team.Enums.UnitTypes.Mixed);
            impakt.context.Team.positionDefaults = new Team.Models.PositionDefault();
            impakt.context.Team.unitTypes = _playbook.getUnitTypes();
            impakt.context.Team.unitTypesEnum = _playbook.getUnitTypesEnum();
            impakt.context.Team.creation = {
                teams: new Team.Models.TeamModelCollection()
            };
            /**
             *
             *
             * League context
             *
             *
             */
            impakt.context.League.leagues = new League.Models.LeagueModelCollection();
            impakt.context.League.conferences = new League.Models.ConferenceCollection();
            impakt.context.League.divisions = new League.Models.DivisionCollection();
            impakt.context.League.locations = new League.Models.LocationCollection();
            /**
             * A creation context for new leagues, conferences, divisions, and teams
             */
            impakt.context.League.creation = {
                leagues: new League.Models.LeagueModelCollection(),
                conferences: new League.Models.ConferenceCollection(),
                team: new Team.Models.TeamModel(),
                divisions: new League.Models.DivisionCollection(),
                locations: new League.Models.LocationCollection()
            };
            /**
             *
             *
             * Season context
             *
             *
             */
            impakt.context.Season.seasons = new Season.Models.SeasonModelCollection();
            impakt.context.Season.games = new Season.Models.GameCollection();
            /**
             * A creation context for new seasons, games, and weeks
             */
            impakt.context.Season.creation = {
                seasons: new Season.Models.SeasonModelCollection(),
                games: new Season.Models.GameCollection()
            };
            async.parallel([
                // Retrieve associations
                // Retrieve associations
                function (callback) {
                    // make requests to get all associations
                    _associations.getAssociationsByContextId()
                        .then(function (associations) {
                        context.Associations.associations = associations;
                        callback(null, associations);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve leagues
                // Retrieve leagues
                function (callback) {
                    _league.getLeagues().then(function (leagues) {
                        context.League.leagues = leagues;
                        __notifications.success('Leagues successfully loaded');
                        callback(null, leagues);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve conferences
                // Retrieve conferences
                function (callback) {
                    _league.getConferences().then(function (conferences) {
                        context.League.conferences = conferences;
                        __notifications.success('Conferences successfully loaded');
                        callback(null, conferences);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve divisions
                // Retrieve divisions
                function (callback) {
                    _league.getDivisions().then(function (divisions) {
                        context.League.divisions = divisions;
                        __notifications.success('Divisions successfully loaded');
                        callback(null, divisions);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve teams
                // Retrieve teams
                function (callback) {
                    _team.getTeams().then(function (teams) {
                        context.Team.teams = teams;
                        __notifications.success('Teams successfully loaded');
                        callback(null, teams);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve locations
                // Retrieve locations
                function (callback) {
                    _league.getLocations().then(function (locations) {
                        context.League.locations = locations;
                        __notifications.success('Locations successfully loaded');
                        callback(null, locations);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve seasons
                // Retrieve seasons
                function (callback) {
                    _season.getSeasons().then(function (seasons) {
                        context.Season.seasons = seasons;
                        __notifications.success('Seasons successfully loaded');
                        callback(null, seasons);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve games
                // Retrieve games
                function (callback) {
                    _season.getGames().then(function (games) {
                        context.Season.games = games;
                        __notifications.success('Games successfully loaded');
                        callback(null, games);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve playbooks
                // Retrieve playbooks
                function (callback) {
                    _playbook.getPlaybooks().then(function (playbooks) {
                        context.Playbook.playbooks = playbooks;
                        __notifications.success('Playbooks successfully loaded');
                        callback(null, playbooks);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve formations
                // Retrieve formations
                function (callback) {
                    _playbook.getFormations().then(function (formations) {
                        context.Playbook.formations = formations;
                        __notifications.success('Formations successfully loaded');
                        callback(null, formations);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve assignment groups
                // Retrieve assignment groups
                function (callback) {
                    _playbook.getAssignmentGroups()
                        .then(function (assignmentGroupCollection) {
                        if (Common.Utilities.isNotNullOrUndefined(assignmentGroupCollection))
                            context.Playbook.assignmentGroups = assignmentGroupCollection;
                        __notifications.success('Assignments successfully loaded');
                        callback(null, assignmentGroupCollection);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve personnel groups
                // Retrieve personnel groups
                function (callback) {
                    _team.getPersonnel().then(function (personnelCollection) {
                        if (Common.Utilities.isNotNullOrUndefined(personnelCollection))
                            context.Team.personnel = personnelCollection;
                        __notifications.success('Personnel successfully loaded');
                        callback(null, personnelCollection);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve plays
                // Retrieve plays
                function (callback) {
                    _playbook.getPlays().then(function (plays) {
                        context.Playbook.plays = plays;
                        __notifications.success('Plays successfully loaded');
                        callback(null, plays);
                    }, function (err) {
                        callback(err);
                    });
                },
                // Retrieve scenarios
                // Retrieve scenarios
                function (callback) {
                    _playbook.getScenarios().then(function (scenarios) {
                        context.Playbook.scenarios = scenarios;
                        __notifications.success('Scenarios successfully loaded');
                        callback(null, scenarios);
                    }, function (err) {
                        callback(err);
                    });
                }], 
            // Final callback
            function (err, results) {
                if (err) {
                    d.reject(err);
                }
                else {
                    __notifications.success('Initial data loaded successfully');
                    ready();
                    d.resolve(context);
                }
            });
            return d.promise;
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.contextmenu = angular.module('impakt.common.contextmenu', []);
/// <reference path='./contextmenu.mdl.ts' />
impakt.common.contextmenu.controller('common.contextmenu.ctrl', [
    '$scope',
    '_contextmenu',
    function ($scope, _contextmenu) {
        $scope.$contextmenuElement;
        $scope.contextmenuData = _contextmenu.contextmenuData;
        $scope.left = 0;
        $scope.top = 0;
        $scope.width = 200;
        $scope.height = 200;
        $scope.guid = '';
        $scope.contextmenuVisible = false;
        _contextmenu.onopen(function (data) {
            $scope.contextmenuData = data;
            $scope.contextmenuVisible = true;
            if (!$scope.$$phase) {
                $scope.$apply();
            }
            $scope.$contextmenuElement.offset({ top: data.pageY, left: data.pageX });
        });
        _contextmenu.onclose(function () {
            $scope.contextmenuData = null;
            $scope.contextmenuVisible = false;
            if (!$scope.$$phase) {
                $scope.$apply();
            }
        });
        $scope.open = function (data) {
            _contextmenu.open(data);
        };
        $scope.close = function () {
            _contextmenu.close();
        };
    }]).directive('contextmenu', [
    '_contextmenu',
    function (_contextmenu) {
        console.debug('directive: contextmenu - register');
        return {
            controller: 'common.contextmenu.ctrl',
            restrict: 'E',
            templateUrl: 'common/contextmenu/contextmenu.tpl.html',
            transclude: true,
            replace: true,
            link: function ($scope, $element, attrs) {
                $scope.$contextmenuElement = $element;
                $(document).keyup(function (e) {
                    if (e.which == Common.Input.Which.Esc) {
                        $scope.close();
                    }
                });
            }
        };
    }])
    .directive('enableContextmenu', [
    '_contextmenu',
    function (_contextmenu) {
        return {
            restrict: 'A',
            scope: {
                entity: '='
            },
            link: function ($scope, $element, attrs) {
                $element.mousedown(function (e) {
                    if (e.which == Common.Input.Which.RightClick) {
                        _contextmenu.open(new Common.Models.ContextmenuData($scope.entity, e.pageX, e.pageY));
                    }
                });
            }
        };
    }]);
/// <reference path='./contextmenu.mdl.ts' />
impakt.common.contextmenu.service('_contextmenu', [
    function () {
        var closeCallback = function () { };
        var openCallback = function (data) { };
        this.contextmenuData = null;
        this.open = function (data) {
            this.contextmenuData = data;
            openCallback(data);
        };
        this.onopen = function (callback) {
            openCallback = callback;
        };
        this.close = function () {
            this.data = null;
            closeCallback();
        };
        this.onclose = function (callback) {
            closeCallback = callback;
        };
        this.calculatePosition = function () {
            // todo
        };
        this.getData = function () {
            return Common.Utilities.isNotNullOrUndefined(this.contextmenuData) ? this.contextmenuData.data : null;
        };
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.localStorage = angular.module('impakt.common.localStorage', [])
    .config(function () {
    console.debug('impakt.common.localStorage - config');
})
    .run(function () {
    console.debug('impakt.common.localStorage - run');
});
/// <reference path='./localStorage.mdl.ts' />
impakt.common.localStorage.constant('LOCAL_STORAGE', {
    'ACCESS_TOKEN': 'access_token',
    'ACCESS_TOKEN_EXPIRES': 'access_token_expires',
    'USER_NAME': 'user_name',
    'ORGANIZATION_KEY': 'organization_key',
    'DEFAULT_PLAYBOOK_KEY': 'default_playbook_key',
    'DEFAULT_PLAYBOOK_UNIT_TYPE': 'default_playbook_unit_type',
    'DEFAULT_EDITOR_TYPE': 'default_editor_type',
    'DEFAULT_EDITOR_ITEM_KEY': 'default_editor_item_key',
    'DEFAULT_EDITOR_ITEM_TYPE': 'default_editor_item_type',
    'DEFAULT_PATH': 'default_path'
});
/// <reference path='./localStorage.mdl.ts' />
impakt.common.localStorage.factory('__localStorage', [
    'LOCAL_STORAGE',
    function (LOCAL_STORAGE) {
        var self = {
            getItem: getItem,
            setItem: setItem,
            getAccessToken: getAccessToken,
            setAccessToken: setAccessToken,
            clearAccessToken: clearAccessToken,
            getAccessTokenExpiration: getAccessTokenExpiration,
            getUserName: getUserName,
            getOrganizationKey: getOrganizationKey,
            setOrganizationKey: setOrganizationKey,
            isDefaultEditorInfoSet: isDefaultEditorInfoSet,
            getDefaultEditorInfo: getDefaultEditorInfo,
            setDefaultEditorInfo: setDefaultEditorInfo,
            getDefaultPlaybookKey: getDefaultPlaybookKey,
            setDefaultPlaybookKey: setDefaultPlaybookKey,
            resetDefaultPlaybookKey: resetDefaultPlaybookKey,
            getDefaultPlaybookUnitType: getDefaultPlaybookUnitType,
            setDefaultPlaybookUnitType: setDefaultPlaybookUnitType,
            resetDefaultPlaybookUnitType: resetDefaultPlaybookUnitType,
            resetDefaultPlaybook: resetDefaultPlaybook,
            getDefaultEditorType: getDefaultEditorType,
            setDefaultEditorType: setDefaultEditorType,
            resetDefaultEditorType: resetDefaultEditorType,
            getDefaultEditorItemKey: getDefaultEditorItemKey,
            setDefaultEditorItemKey: setDefaultEditorItemKey,
            resetDefaultEditorItemKey: resetDefaultEditorItemKey,
            getDefaultEditorItemType: getDefaultEditorItemType,
            setDefaultEditorItemType: setDefaultEditorItemType,
            resetDefaultEditorItemType: resetDefaultEditorItemType,
            resetDefaultEditorItem: resetDefaultEditorItem,
            getDefaultPath: getDefaultPath,
            setDefaultPath: setDefaultPath,
            signout: signout
        };
        function signout() {
            self.clearAccessToken();
            self.resetDefaultEditorItem();
            self.resetDefaultPlaybook();
        }
        function getItem(key) {
            return localStorage.getItem(key);
        }
        function setItem(key, value) {
            localStorage.setItem(key, value);
        }
        /**
         *
         * App-specific settings
         *
         */
        // Access token
        function getAccessToken() {
            return localStorage.getItem(LOCAL_STORAGE.ACCESS_TOKEN);
        }
        function getAccessTokenExpiration() {
            return localStorage.getItem(LOCAL_STORAGE.ACCESS_TOKEN_EXPIRES);
        }
        /**
         * Returns the username stored in localStorage, if it exists, otherwise throws
         * an exception.
         *
         * @return {string} the username (email) stored in local storage
         */
        function getUserName() {
            var userName = localStorage.getItem(LOCAL_STORAGE.USER_NAME);
            if (!userName)
                throw new Error('__localStorage getUserName(): user name could not be found!');
            return userName;
        }
        /**
         * Retrieves the current logged in user's organization key from local storage,
         * throws an exception if it doesn't exist.
         *
         * @return {number} The organization key
         */
        function getOrganizationKey() {
            var orgKey = localStorage.getItem(LOCAL_STORAGE.ORGANIZATION_KEY);
            if (!orgKey)
                throw new Error('__localStorage getOrganizationKey(): organization key could not be found!');
            return parseInt(orgKey);
        }
        /**
         * Sets the current organization key
         * @param {number} organizationKey the organization key
         */
        function setOrganizationKey(organizationKey) {
            if (isNaN(organizationKey))
                throw new Error('__localStorage setOrganizationKey(): Failed to set organization key ' + organizationKey);
            localStorage.setItem(LOCAL_STORAGE.ORGANIZATION_KEY, organizationKey.toString());
        }
        function setAccessToken(data) {
            self.setItem(LOCAL_STORAGE.ACCESS_TOKEN, data['access_token']);
            self.setItem(LOCAL_STORAGE.ACCESS_TOKEN_EXPIRES, data['.expires']);
            self.setItem(LOCAL_STORAGE.USER_NAME, data['userName']);
            self.setItem(LOCAL_STORAGE.ORGANIZATION_KEY, data['organizationKey']);
        }
        function clearAccessToken() {
            self.setItem(LOCAL_STORAGE.ACCESS_TOKEN, null);
            self.setItem(LOCAL_STORAGE.ACCESS_TOKEN_EXPIRES, null);
            self.setItem(LOCAL_STORAGE.USER_NAME, null);
            self.setItem(LOCAL_STORAGE.ORGANIZATION_KEY, null);
        }
        // Default Playbook Key
        function getDefaultPlaybookKey() {
            return parseInt(localStorage.getItem(LOCAL_STORAGE.DEFAULT_PLAYBOOK_KEY));
        }
        function setDefaultPlaybookKey(key) {
            self.setItem(LOCAL_STORAGE.DEFAULT_PLAYBOOK_KEY, key);
        }
        function resetDefaultPlaybookKey() {
            self.setDefaultPlaybookKey(-1);
        }
        function getDefaultPlaybookUnitType() {
            return parseInt(localStorage.getItem(LOCAL_STORAGE.DEFAULT_PLAYBOOK_UNIT_TYPE));
        }
        function setDefaultPlaybookUnitType(type) {
            self.setItem(LOCAL_STORAGE.DEFAULT_PLAYBOOK_UNIT_TYPE, type);
        }
        function resetDefaultPlaybookUnitType() {
            self.setDefaultPlaybookUnitType(-1);
        }
        function resetDefaultPlaybook() {
            self.resetDefaultPlaybookKey();
            self.resetDefaultPlaybookUnitType();
        }
        function isDefaultEditorInfoSet() {
            var info = self.getDefaultEditorInfo();
            return info && info.playbookKey > 0 && info.editorType >= 0
                && info.editorItemKey > 0 && info.editorItemType >= 0;
        }
        function setDefaultEditorInfo(playbookKey, editorType, editorItemKey, editorItemType) {
            self.setDefaultPlaybookKey(playbookKey);
            self.setDefaultEditorType(editorType);
            self.setDefaultEditorItemKey(editorItemKey);
            self.setDefaultEditorItemType(editorItemType);
        }
        function getDefaultEditorInfo() {
            return {
                playbookKey: self.getDefaultPlaybookKey(),
                editorType: self.getDefaultEditorType(),
                editorItemKey: self.getDefaultEditorItemKey(),
                editorItemType: self.getDefaultEditorItemType()
            };
        }
        function getDefaultEditorType() {
            return parseInt(localStorage.getItem(LOCAL_STORAGE.DEFAULT_EDITOR_TYPE));
        }
        function setDefaultEditorType(type) {
            self.setItem(LOCAL_STORAGE.DEFAULT_EDITOR_TYPE, type);
        }
        function resetDefaultEditorType() {
            self.setDefaultEditorType(-1);
        }
        function getDefaultEditorItemKey() {
            return parseInt(localStorage.getItem(LOCAL_STORAGE.DEFAULT_EDITOR_ITEM_KEY));
        }
        function setDefaultEditorItemKey(key) {
            self.setItem(LOCAL_STORAGE.DEFAULT_EDITOR_ITEM_KEY, key);
        }
        function resetDefaultEditorItemKey() {
            self.setDefaultEditorItemKey(-1);
        }
        function getDefaultEditorItemType() {
            return parseInt(localStorage.getItem(LOCAL_STORAGE.DEFAULT_EDITOR_ITEM_TYPE));
        }
        function setDefaultEditorItemType(type) {
            self.setItem(LOCAL_STORAGE.DEFAULT_EDITOR_ITEM_TYPE, type);
        }
        function resetDefaultEditorItemType() {
            self.setDefaultEditorItemType(-1);
        }
        function resetDefaultEditorItem() {
            self.resetDefaultEditorType();
            self.resetDefaultEditorItemKey();
            self.resetDefaultEditorItemType();
        }
        function getDefaultPath() {
            return localStorage.getItem(LOCAL_STORAGE.DEFAULT_PATH);
        }
        function setDefaultPath(path) {
            self.setItem(LOCAL_STORAGE.DEFAULT_PATH, path);
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.locale = angular.module('impakt.common.locale', [])
    .config([function () {
        console.debug('impakt.common.locale - config');
    }])
    .run([function () {
        console.debug('impakt.common.locale - run');
    }]);
/// <reference path='./locale.mdl.ts' />
impakt.common.locale.factory('__locale', [
    function () {
        var self = {
            states: states()
        };
        function states() {
            return [
                {
                    "name": "Alabama",
                    "abbreviation": "AL"
                },
                {
                    "name": "Alaska",
                    "abbreviation": "AK"
                },
                {
                    "name": "American Samoa",
                    "abbreviation": "AS"
                },
                {
                    "name": "Arizona",
                    "abbreviation": "AZ"
                },
                {
                    "name": "Arkansas",
                    "abbreviation": "AR"
                },
                {
                    "name": "California",
                    "abbreviation": "CA"
                },
                {
                    "name": "Colorado",
                    "abbreviation": "CO"
                },
                {
                    "name": "Connecticut",
                    "abbreviation": "CT"
                },
                {
                    "name": "Delaware",
                    "abbreviation": "DE"
                },
                {
                    "name": "District Of Columbia",
                    "abbreviation": "DC"
                },
                {
                    "name": "Federated States Of Micronesia",
                    "abbreviation": "FM"
                },
                {
                    "name": "Florida",
                    "abbreviation": "FL"
                },
                {
                    "name": "Georgia",
                    "abbreviation": "GA"
                },
                {
                    "name": "Guam",
                    "abbreviation": "GU"
                },
                {
                    "name": "Hawaii",
                    "abbreviation": "HI"
                },
                {
                    "name": "Idaho",
                    "abbreviation": "ID"
                },
                {
                    "name": "Illinois",
                    "abbreviation": "IL"
                },
                {
                    "name": "Indiana",
                    "abbreviation": "IN"
                },
                {
                    "name": "Iowa",
                    "abbreviation": "IA"
                },
                {
                    "name": "Kansas",
                    "abbreviation": "KS"
                },
                {
                    "name": "Kentucky",
                    "abbreviation": "KY"
                },
                {
                    "name": "Louisiana",
                    "abbreviation": "LA"
                },
                {
                    "name": "Maine",
                    "abbreviation": "ME"
                },
                {
                    "name": "Marshall Islands",
                    "abbreviation": "MH"
                },
                {
                    "name": "Maryland",
                    "abbreviation": "MD"
                },
                {
                    "name": "Massachusetts",
                    "abbreviation": "MA"
                },
                {
                    "name": "Michigan",
                    "abbreviation": "MI"
                },
                {
                    "name": "Minnesota",
                    "abbreviation": "MN"
                },
                {
                    "name": "Mississippi",
                    "abbreviation": "MS"
                },
                {
                    "name": "Missouri",
                    "abbreviation": "MO"
                },
                {
                    "name": "Montana",
                    "abbreviation": "MT"
                },
                {
                    "name": "Nebraska",
                    "abbreviation": "NE"
                },
                {
                    "name": "Nevada",
                    "abbreviation": "NV"
                },
                {
                    "name": "New Hampshire",
                    "abbreviation": "NH"
                },
                {
                    "name": "New Jersey",
                    "abbreviation": "NJ"
                },
                {
                    "name": "New Mexico",
                    "abbreviation": "NM"
                },
                {
                    "name": "New York",
                    "abbreviation": "NY"
                },
                {
                    "name": "North Carolina",
                    "abbreviation": "NC"
                },
                {
                    "name": "North Dakota",
                    "abbreviation": "ND"
                },
                {
                    "name": "Northern Mariana Islands",
                    "abbreviation": "MP"
                },
                {
                    "name": "Ohio",
                    "abbreviation": "OH"
                },
                {
                    "name": "Oklahoma",
                    "abbreviation": "OK"
                },
                {
                    "name": "Oregon",
                    "abbreviation": "OR"
                },
                {
                    "name": "Palau",
                    "abbreviation": "PW"
                },
                {
                    "name": "Pennsylvania",
                    "abbreviation": "PA"
                },
                {
                    "name": "Puerto Rico",
                    "abbreviation": "PR"
                },
                {
                    "name": "Rhode Island",
                    "abbreviation": "RI"
                },
                {
                    "name": "South Carolina",
                    "abbreviation": "SC"
                },
                {
                    "name": "South Dakota",
                    "abbreviation": "SD"
                },
                {
                    "name": "Tennessee",
                    "abbreviation": "TN"
                },
                {
                    "name": "Texas",
                    "abbreviation": "TX"
                },
                {
                    "name": "Utah",
                    "abbreviation": "UT"
                },
                {
                    "name": "Vermont",
                    "abbreviation": "VT"
                },
                {
                    "name": "Virgin Islands",
                    "abbreviation": "VI"
                },
                {
                    "name": "Virginia",
                    "abbreviation": "VA"
                },
                {
                    "name": "Washington",
                    "abbreviation": "WA"
                },
                {
                    "name": "West Virginia",
                    "abbreviation": "WV"
                },
                {
                    "name": "Wisconsin",
                    "abbreviation": "WI"
                },
                {
                    "name": "Wyoming",
                    "abbreviation": "WY"
                }
            ];
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.modals = angular.module('impakt.common.modals', [])
    .config([function () {
        console.debug('impakt.common.modals - config');
    }])
    .run([function () {
        console.debug('impakt.common.modals - run');
    }]);
/// <reference path='./modals.mdl.ts' />
impakt.common.modals.factory('__modals', [
    '$uibModal',
    function ($uibModal) {
        var self = {
            open: open
        };
        function open(size, templateUrl, controllerName, resolveData) {
            console.log('open modal', resolveData);
            for (var key in resolveData) {
                if (typeof resolveData[key] != 'function') {
                    throw Error(['Modal resolve data must be given ',
                        'as an anonymous function which ',
                        'returns a value.',
                        ' | key: ', key,
                        ' | data: ', resolveData[key]
                    ].join(''));
                }
            }
            return $uibModal.open({
                animation: true,
                backdrop: true,
                size: size,
                templateUrl: templateUrl,
                controller: controllerName,
                resolve: resolveData
            });
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.notifications = angular.module('impakt.common.notifications', [])
    .config([function () {
        console.debug('impakt.common.notifications - config');
    }])
    .run([function () {
        console.debug('impakt.common.notifications - run');
    }]);
/// <reference path='./notifications.mdl.ts' />
impakt.common.notifications.controller('notifications.ctrl', [
    '$scope',
    '__notifications',
    function ($scope, __notifications) {
        $scope.notifications = __notifications.notifications;
        $scope.notificationTypes = __notifications.notificationTypes;
        $scope.test = function () {
            var index = Math.floor((Math.random() * $scope.notificationTypes.length));
            __notifications.notify('test notification!', index);
        };
        $scope.clearAll = function () {
            __notifications.removeAll();
        };
        $scope.remove = function (guid) {
            __notifications.remove(guid);
        };
    }]).directive('notifications', [
    '$compile', '__notifications',
    function ($compile, __notifications) {
        return {
            restrict: 'E',
            templateUrl: 'common/notifications/notifications.tpl.html',
            controller: 'notifications.ctrl',
            link: function ($scope, $element, attrs) {
            }
        };
    }])
    .directive('notificationItem', [function () {
        return {
            restrict: 'E',
            templateUrl: 'common/notifications/notification-item.tpl.html',
            controller: 'notifications.ctrl',
            link: function ($scope, $element, attrs) {
                var css = '';
                switch (attrs.type) {
                }
            }
        };
    }]);
/// <reference path='./notifications.mdl.ts' />
impakt.common.notifications.service('__notifications', [
    function () {
        this.notifications = new Common.Models.NotificationCollection();
        this.notificationTypes = Common.Utilities.getEnumerationsAsArray(Common.Models.NotificationType);
        /**
         * Removes ("Clears") all notifications
         */
        this.removeAll = function () {
            this.notifications.removeAll();
        };
        /**
         * Removes the given notification by guid
         * @param  {string}                     guid Guid of notification to remove
         * @return {Common.Models.Notification}      The removed notification
         */
        this.remove = function (guid) {
            return this.notifications.remove(guid);
        };
        /**
         * Creates a new notification with the given message and type
         * @param  {string}                         message The message to notify
         * @param  {Common.Models.NotificationType} type    The type of notification to display
         * @return {Common.Models.Notification}             The created notification
         */
        this.notify = function (message, type) {
            var notificationModel = new Common.Models.Notification(message, type);
            this.notifications.add(notificationModel);
            return notificationModel;
        };
        /**
         * Shorthand for creating a success notification
         * @param  {string}                     ...args Message strings to be concatenated
         * @return {Common.Models.Notification}         New notification created
         */
        this.success = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return this.notify(_concat(args), Common.Models.NotificationType.Success);
        };
        /**
         * Shorthand for creating an error notification
         * @param  {string}                     ...args Message strings to be concatenated
         * @return {Common.Models.Notification}         New notification created
         */
        this.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return this.notify(_concat(args), Common.Models.NotificationType.Error);
        };
        /**
         * Shorthand for creating a warning notification
         * @param  {string}                     ...args Message strings to be concatenated
         * @return {Common.Models.Notification}         New notification created
         */
        this.warning = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return this.notify(_concat(args), Common.Models.NotificationType.Warning);
        };
        /**
         * Shorthand for creating an info notification
         * @param  {string}                     ...args Message strings to be concatenated
         * @return {Common.Models.Notification}         New notification created
         */
        this.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return this.notify(_concat(args), Common.Models.NotificationType.Info);
        };
        /**
         * Shorthand for creating a pending notification; this will display a spinner
         * graphic to indicate that it is in progress (TO-DO).
         * @param  {string}                     ...args Message strings to be concatenated
         * @return {Common.Models.Notification}         New notification created
         */
        this.pending = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return this.notify(_concat(args), Common.Models.NotificationType.Pending);
        };
        function _concat(args) {
            return !args || !args.length || args.length <= 0 ? '' : args.join('');
        }
    }
]);
/// <reference path='../common.mdl.ts' />
impakt.common.parser = angular.module('impakt.common.parser', [])
    .config(function () {
    console.debug('impakt.common.parser - config');
})
    .run(function () {
    console.debug('impakt.common.parser - run');
});
/// <reference path='./parser.mdl.ts' />
impakt.common.parser.constant('PARSER', {});
/// <reference path='./parser.mdl.ts' />
impakt.common.parser.factory('__parser', [
    'PARSER',
    function (PARSER) {
        var self = {
            camelCaseToSpace: camelCaseToSpace,
            convertEnumToList: convertEnumToList,
            toJson: toJson
        };
        function camelCaseToSpace(str, capitalizeFirst) {
            return Common.Utilities.camelCaseToSpace(str, capitalizeFirst);
        }
        function convertEnumToList(obj) {
            return Common.Utilities.convertEnumToList(obj);
        }
        /**
         * takes a complex javascript object
         * (containing primitives, objects & functions)
         * and returns a json object containing entries
         * which are explicitly defined by the object's
         * implementation of a 'toJson()' method.
         *
         * If the object does not implement a 'toJson()' method,
         * the object returned by this method will be null.
         *
         * If the object contains child objects, each child object
         * will be recursively searched for a 'toJson()' method, and
         * the same logic is applied.
         *
         * Functions stored within the json object will be dropped.
         */
        function toJson(obj) {
            return Common.Utilities.toJson(obj);
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.scrollable = angular.module('impakt.common.scrollable', [])
    .config(function () {
    console.debug('impakt.common.scrollable - config');
})
    .run(function () {
    console.debug('impakt.common.scrollable - run');
});
///<reference path='./scrollable.mdl.ts' />
impakt.common.scrollable.directive('scrollable', ['_scrollable', function (_scrollable) {
        console.debug('directive: impakt.common.scrollable - register');
        return {
            restrict: 'A',
            link: function ($scope, $element, attrs) {
                console.log('scrollable element');
            }
        };
    }]);
/// <reference path='./scrollable.mdl.ts' />
impakt.common.scrollable.service('_scrollable', ['$rootScope', function ($rootScope) {
        console.debug('service: impakt.common.scrollable');
        var self = this;
        var down, up;
        this.$container;
        this.$head;
        this.headHeight;
        this.$well;
        this.content;
        this.contentHeight;
        this.HEIGHT_RATIO;
        this.deltaY;
        this.deltaX;
        this.offsetY;
        this.deltaRatioY;
        this.offsetX;
        this.deltaRatioX;
        this.speed;
        this.range;
        this.altKeyPressed;
        this.speed;
        this.thresholdX = 10;
        this.thresholdY = 10;
        this.readyCallback = function () {
            console.log('scrollable ready');
        };
        this.scrollCallback = function (x, y) {
            //console.log('scrolling...');
        };
        this.initialize = function ($container, content) {
            this.altKeyPressed = false;
            // main container window and inner content
            this.$container = $container;
            this.height = $container.height();
            this.content = content;
            this.contentHeight = content.getHeight();
            this.HEIGHT_RATIO = this.height / this.contentHeight;
            // console.log(
            // 	'container height: ', this.height, 
            // 	'content height: ', this.contentHeight, 
            // 	'ratio: ', this.HEIGHT_RATIO
            // );
            this.$head = $("<div class='scroll-head'></div>");
            this.$well = $("<div class='scroll'></div>").append(this.$head);
            this.$container.find('.scroll').remove();
            this.$container.addClass('scrollable-container').append(this.$well);
            this.offsetY = 0;
            this.offsetX = 0;
            this.deltaY = 0;
            this.deltaX = 0;
            this.speed = 0.25; // must be between 0 and 1!
            if (this.speed < 0 || this.speed > 1) {
                throw new Error('scroll speed must be between 0 and 1');
            }
            this.deltaRatioY = 0;
            this.deltaRatioX = 0;
            this.headHeight = Math.ceil(this.HEIGHT_RATIO * this.height);
            this.$head.height(this.headHeight);
            this.headOffsetY = 0;
            this.headOffsetX = 0;
            console.log('container height: ', this.height, 'head height: ', this.headHeight);
            this.range = this.contentHeight - this.height;
            this.headRange = this.height - this.headHeight;
            down = false;
            up = false;
            // set the event listener to the mousewheel event
            this.setListener();
            this.ready();
        };
        this.setListener = function () {
            this.$head.draggable({
                axis: 'y',
                containment: '.scrollable-container .scroll',
                drag: function (event, ui) {
                    // TODO implement
                }
            });
            this.$container[0].addEventListener('mousewheel', function (event) {
                self.scroll.call(self, event.wheelDeltaX, event.wheelDeltaY, event.altKey);
            }, false);
        };
        this.isDown = function () {
            return down && self.offsetY > -self.range;
        };
        this.isUp = function () {
            return up && self.offsetY < 0;
        };
        this.canScroll = function () {
            return this.isDown() || this.isUp();
        };
        this.setHead = function (x, y) {
            this.$head.css({ 'top': y + 'px' });
        };
        this.onready = function (callback) {
            this.readyCallback = callback;
        };
        this.ready = function () {
            this.readyCallback(this.content);
        };
        this.onscroll = function (callback) {
            this.scrollCallback = callback;
        };
        this.scrollToPercentY = function (percentY) {
            if (percentY < 0 || percentY > 1)
                throw new Error('Percent must be between 0 and 1');
            this.headOffsetY = percentY * this.headRange;
            this.offsetY = -percentY * this.range;
            this.setHead(0, this.headOffsetY);
            this.content.scroll(this.offsetX, -this.offsetY);
        };
        this.scrollToPercentX = function (percentX) {
            // TODO implement
        };
        this.scrollToPercent = function (percentX, percentY) {
            this.scrollToPercentX(percentX);
            this.scrollToPercentY(percentY);
        };
        this.scroll = function (deltaX, deltaY, altKeyPressed) {
            /**
             * Seeks to prevent micro-scroll events during clicks / drags
             * from causing glitchy field shifting
             */
            if (Math.abs(deltaX) < self.thresholdX &&
                Math.abs(deltaY) < self.thresholdY)
                return;
            self.deltaX = deltaX;
            self.deltaY = deltaY;
            self.altKeyPressed = altKeyPressed;
            self.deltaRatioX = new Number(self.deltaX * self.HEIGHT_RATIO).toFixed(1);
            self.deltaRatioY = new Number(self.deltaY * self.HEIGHT_RATIO).toFixed(1);
            down = self.deltaY < 0;
            up = !down;
            if (!self.altKeyPressed) {
                if (self.canScroll()) {
                    var scrollDistanceY = self.offsetY + (self.deltaY * self.speed);
                    var scrollableY = self.isDown() ?
                        Math.max(scrollDistanceY, -self.range) :
                        Math.min(scrollDistanceY, 0);
                    if (scrollableY < -self.range ||
                        scrollableY > 0)
                        return;
                    self.headOffsetY = -scrollableY * self.HEIGHT_RATIO;
                    self.offsetY = scrollableY;
                    self.setHead.call(self, 0, self.headOffsetY);
                    self.content.scroll(self.offsetX, -self.offsetY);
                }
                else {
                    console.log('STOP');
                }
            }
            else {
            }
            this.scrollCallback(deltaX, deltaY);
        };
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.signin = angular.module('impakt.common.signin', [])
    .config([function () {
        console.debug('impakt.common.signin - config');
    }])
    .run([function () {
        console.debug('impakt.common.signin - run');
    }]);
/// <reference path='./signin.mdl.ts' />
impakt.common.signin.constant('SIGNIN', {
    'ORG_ENDPOINT': '/configuration',
    'INVITE_ENDPOINT': '/invitations',
    'REGISTER_USER': '/registerUser',
    'CREATE_ORGANIZATION': '/createOrganization'
});
/// <reference path='./signin.mdl.ts' />
impakt.common.signin.controller('signin.ctrl', ['$scope', '__signin', '__locale',
    function ($scope, __signin, __locale) {
        $scope.showSignin = true;
        $scope.showRegister = false;
        $scope.states = __locale.states;
        $scope.signinData = {
            username: '',
            password: ''
        };
        // $scope.user = new User.Models.UserModel();
        // $scope.user.firstName = 'Danny';
        // $scope.user.lastName = 'Bullis';
        // $scope.user.email = 'daniel.p.bullis@gmail.com';
        // $scope.user.organizationName = 'Test organization';
        $scope.signinMessage = '';
        $scope.organization = new User.Models.Organization();
        $scope.account = new User.Models.Account();
        $scope.toggleSignin = function (show) {
            $scope.showSignin = show === true ? show : !$scope.showSignin;
            $scope.showRegister = !$scope.showSignin;
        };
        $scope.toggleRegister = function (show) {
            $scope.showRegister = show === true ? show : !$scope.showRegister;
            $scope.showSignin = !$scope.showRegister;
        };
        $scope.createUser = function (next) {
            console.log('creating user');
            __signin.registerUser($scope.user)
                .then(function (results) {
                console.log('user created', results);
            }, function (err) {
                console.error(err);
            });
        };
        $scope.createOrganization = function (next) {
            console.log('creating organization');
            __signin.createOrganization($scope.organization)
                .then(function (results) {
                console.log('organization created', results);
            }, function (err) {
                console.error(err);
            });
            next();
        };
        $scope.createAccount = function (next) {
            console.log('creating account');
            next();
        };
        $scope.signin = function () {
            __signin.signin($scope.signinData.username, $scope.signinData.password).then(function (results) {
                $scope.signinMessage = 'signin successful.';
            }, function (err) {
                $scope.signinMessage = err && err.data && err.data.error_description || err;
            });
        };
        $scope.register = function () {
        };
    }]);
/// <reference path='./signin.mdl.ts' />
impakt.common.signin.factory('__signin', [
    '$q',
    '$window',
    '__api',
    '__auth',
    '__localStorage',
    'SIGNIN',
    function ($q, $window, __api, __auth, __localStorage, SIGNIN) {
        var self = {
            signin: signin,
            logout: logout,
            registerUser: registerUser,
            createOrganization: createOrganization
        };
        function signin(username, password) {
            var d = $q.defer();
            // send a handshake
            __auth.getToken(username, password).then(function (data) {
                console.log(data);
                __localStorage.setAccessToken(data.data);
                $window.location.href = 'index.html';
                d.resolve(data);
            }, function (err) {
                console.error(err);
                d.reject(err);
            });
            return d.promise;
        }
        function logout() {
            __localStorage.signout();
            $window.location.href = 'signin.html';
        }
        /**
         * Takes the given user information (first, last, email, org name)
         * and sends an registration confirmation email (invite) to the user
         * @param {User.Models.UserModel} userModel user to register
         */
        function registerUser(userModel) {
            var d = $q.defer();
            var userModelJson = userModel.toJson();
            __api.post(__api.path(SIGNIN.INVITE_ENDPOINT, SIGNIN.REGISTER_USER), {
                version: 1,
                FirstName: userModel.firstName,
                LastName: userModel.lastName,
                OrganizationKey: 0,
                OrganizationName: userModel.organizationName,
                Email: userModel.email,
                data: {
                    version: 1,
                    FirstName: userModel.firstName,
                    LastName: userModel.lastName,
                    OrganizationKey: 0,
                    OrganizationName: userModel.organizationName,
                    Email: userModel.email,
                    user: userModelJson
                }
            }).then(function (results) {
                // TODO - @theBull handle register user results
                d.resolve(results);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        }
        function createOrganization(organization) {
            var d = $q.defer();
            var organizationJson = organization.toJson();
            __api.post(__api.path(SIGNIN.ORG_ENDPOINT, SIGNIN.CREATE_ORGANIZATION), {
                version: 1,
                data: {
                    version: 1,
                    organization: organizationJson
                }
            }).then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var createdOrganization = new User.Models.Organization();
                if (results) {
                    createdOrganization.fromJson(results);
                }
                else {
                    d.reject(null);
                }
                d.resolve(createdOrganization);
            }, function (err) {
                d.reject(err);
            });
            return d.promise;
        }
        return self;
    }]);
/// <reference path='../common.mdl.ts' />
impakt.common.ui = angular.module('impakt.common.ui', [
    'impakt.quotes'
])
    .config([function () {
        console.debug('impakt.common.ui - config');
    }])
    .run([function () {
        console.debug('impakt.common.ui - run');
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('appLoading.ctrl', [
    '$scope',
    '$timeout',
    '__context',
    '__notifications',
    function ($scope, $timeout, __context, __notifications) {
        $scope.$element;
        $scope.visible = false;
        $scope.notifications = __notifications.notifications;
        $scope.notification;
        $scope.notifications.onModified(function (collection) {
            $scope.notification = collection.getLast();
        });
        __context.onInitializing(function () {
            $scope.visible = true;
        });
        __context.onReady(function () {
            // simulate a slight delay to let the user
            // see that all of their data has been loaded
            // before removing the loading screen
            $timeout(function () {
                $scope.visible = false;
            }, 1000);
        });
    }])
    .directive('appLoading', [
    function () {
        return {
            restrict: 'E',
            templateUrl: 'common/ui/app-loading/app-loading.tpl.html',
            transclude: true,
            replace: true,
            controller: 'appLoading.ctrl',
            link: function ($scope, $element, attrs) {
                $scope.$element = $element;
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('assignmentGroupItem.ctrl', [
    '$scope',
    '_playbook',
    '_details',
    function ($scope, _playbook, _details) {
        $scope.assignmentGroup;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (assignmentGroup) {
            _details.toggleSelection(assignmentGroup);
        };
    }]).directive('assignmentGroupItem', [
    function () {
        /**
         * assignment-group-item directive
         */
        return {
            restrict: 'E',
            controller: 'assignmentGroupItem.ctrl',
            scope: {
                assignmentGroup: '=assignmentgroup'
            },
            templateUrl: 'common/ui/assignment-group-item/assignment-group-item.tpl.html',
            transclude: true,
            replace: true,
            link: function ($scope, $element, attrs) {
                $scope.$element = $element;
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('associationInput.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    function ($scope, $rootScope, _associations) {
        $scope.associations;
        $scope.key;
        $scope.possibleAssociations = new Common.Models.ActionableCollection();
        $scope.associatedEntities = new Common.Models.ActionableCollection();
        $scope.possibleAssociationsListVisible = false;
        $scope.selectedPossibleAssociationIndex = 0;
        $scope.selectedPossibleAssociation = null;
        $scope.search = {
            text: ''
        };
        var associationsUpdateListener = $rootScope.$on('associations-updated', function (e) {
            $scope.associations = _associations.getAssociated($scope.entity);
            $scope.initialize();
        });
        var createEntityListener = $rootScope.$on('create-entity', function (e, entity) {
            $scope.initialize();
        });
        $scope.$watch('search', function (newVal, oldVal) {
            $scope.possibleAssociationsListVisible = newVal.text.length > 0;
        }, true);
        $scope.$on('$destroy', function () {
            associationsUpdateListener();
            createEntityListener();
        });
        $scope.initialize = function () {
            $scope.possibleAssociations = _associations.getContextDataByKey($scope.key);
            // remove any possible associations from the list if they already exist in the
            // associations collection, to prevent adding a duplicate association and to
            // just not suck in general...
            if (Common.Utilities.isNotNullOrUndefined($scope.associations)) {
                $scope.associatedEntities = $scope.associations[$scope.key];
                if (Common.Utilities.isNotNullOrUndefined($scope.associatedEntities)) {
                    $scope.associatedEntities.forEach(function (associated, index) {
                        $scope.possibleAssociations.remove(associated.guid);
                    });
                }
            }
        };
        $scope.addAssociation = function (toEntity) {
            _checkEntities(toEntity);
            _associations.createAssociation($scope.entity, toEntity).then(function () {
                $scope.selectedPossibleAssociation = null;
                $scope.search.text = '';
            }, function (err) {
                $scope.search.text = '';
            });
        };
        $scope.removeAssociation = function (toEntity) {
            _checkEntities(toEntity);
            _associations.deleteAssociation($scope.entity, toEntity).then(function () {
                $scope.search.text = '';
            }, function (err) {
                $scope.search.text = '';
            });
        };
        $scope.addSelectedPossibleAssociation = function () {
            if (Common.Utilities.isNullOrUndefined($scope.selectedPossibleAssociation))
                return;
            $scope.addAssociation($scope.selectedPossibleAssociation);
            $scope.selectedPossibleAssociation = null;
            $scope.hidePossibleAssociationsList();
        };
        $scope.hidePossibleAssociationsList = function () {
            $scope.selectedPossibleAssociationIndex = 0;
            $scope.possibleAssociationsListVisible = false;
        };
        $scope.showPossibleAssociationsList = function () {
            $scope.possibleAssociationsListVisible = true;
            $scope.hoverInitialPossibleAssociation();
        };
        $scope.hoverInitialPossibleAssociation = function () {
            if (Common.Utilities.isNullOrUndefined($scope.possibleAssociations))
                return;
            $scope.selectedPossibleAssociationIndex = 0;
            var size = $scope.possibleAssociations.size();
            if (size > 0) {
                $scope.selectedPossibleAssociation = $scope.possibleAssociations.first();
                if (Common.Utilities.isNotNullOrUndefined($scope.selectedPossibleAssociation)) {
                    $scope.possibleAssociations.hoverIn($scope.selectedPossibleAssociation);
                }
            }
        };
        $scope.hoverNextPossibleAssociation = function () {
            if (Common.Utilities.isNullOrUndefined($scope.possibleAssociations))
                return;
            if (!$scope.possibleAssociationsListVisible) {
                $scope.showPossibleAssociationsList();
                return;
            }
            var size = $scope.possibleAssociations.size();
            if ($scope.selectedPossibleAssociationIndex < size - 1) {
                $scope.selectedPossibleAssociationIndex++;
                $scope.selectedPossibleAssociation = $scope.possibleAssociations.getIndex($scope.selectedPossibleAssociationIndex);
                if (Common.Utilities.isNotNullOrUndefined($scope.selectedPossibleAssociation)) {
                    $scope.possibleAssociations.hoverIn($scope.selectedPossibleAssociation);
                }
            }
        };
        $scope.hoverPreviousPossibleAssociation = function () {
            if (Common.Utilities.isNullOrUndefined($scope.possibleAssociations))
                return;
            if ($scope.selectedPossibleAssociationIndex > 0) {
                $scope.selectedPossibleAssociationIndex--;
                $scope.selectedPossibleAssociation = $scope.possibleAssociations.getIndex($scope.selectedPossibleAssociationIndex);
                if (Common.Utilities.isNotNullOrUndefined($scope.selectedPossibleAssociation)) {
                    $scope.possibleAssociations.hoverIn($scope.selectedPossibleAssociation);
                }
            }
            else {
                if ($scope.possibleAssociationsListVisible)
                    $scope.hidePossibleAssociationsList();
            }
        };
        $scope.getController = function () {
            return $scope;
        };
        function _checkEntities(toEntity) {
            if (Common.Utilities.isNullOrUndefined($scope.entity))
                throw new Error('association-input addAssociation(): entity is null or undefined');
            if (Common.Utilities.isNullOrUndefined(toEntity))
                throw new Error('association-input addAssociation(): toEntity is null or undefined');
        }
    }])
    .directive('associationInput', [
    '_associations',
    function (_associations) {
        return {
            restrict: 'E',
            controller: 'associationInput.ctrl',
            templateUrl: 'common/ui/association-input/association-input.tpl.html',
            transclude: true,
            replace: false,
            scope: {
                entity: '=',
                associations: '=',
                key: '@'
            },
            link: function ($scope, $element, attrs) {
                if (Common.Utilities.isNullOrUndefined($scope.key))
                    throw new Error('association-input link(): key is required and is null or undefined');
                $scope.initialize();
                var $input = $element.find('.associations-input-text');
                if (Common.Utilities.isNotNullOrUndefined($input)) {
                    $input.keyup(function (e) {
                        e.preventDefault();
                        if (e.keyCode == Common.Input.Which.Esc) {
                            $scope.possibleAssociationsListVisible = false;
                        }
                        else if (e.keyCode == Common.Input.Which.Up) {
                            $scope.hoverPreviousPossibleAssociation();
                        }
                        else if (e.keyCode == Common.Input.Which.Down) {
                            $scope.hoverNextPossibleAssociation();
                        }
                        else if (e.keyCode == Common.Input.Which.Enter) {
                            $scope.addSelectedPossibleAssociation();
                        }
                        $scope.$apply();
                    });
                    $scope.$on("$destroy", function () {
                        $input.off('focus').off('blur').off('keyup)');
                    });
                }
            }
        };
    }
])
    .directive('associationCandidateItem', [
    function () {
        return {
            restrict: 'E',
            controller: 'associationInput.ctrl',
            require: '^associationInput',
            templateUrl: 'common/ui/association-input/association-candidate-item.tpl.html',
            transclude: true,
            replace: false,
            link: function ($scope, $element, attrs, controller) {
            }
        };
    }
])
    .directive('associationTag', [
    function () {
        return {
            restrict: 'E',
            controller: 'associationInput.ctrl',
            require: '^associationInput',
            templateUrl: 'common/ui/association-input/association-tag.tpl.html',
            transclude: true,
            replace: false,
            link: function ($scope, $element, attrs) {
            }
        };
    }
]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('conferenceItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_league',
    '_associations',
    function ($scope, $state, _details, _league, _associations) {
        $scope.conference;
        $scope.element;
        $scope.getLeague = function (conference) {
            return Common.Utilities.isNotNullOrUndefined(conference) ?
                (Common.Utilities.isNotNullOrUndefined(conference.league) ?
                    conference.league.name : 'No league') :
                'No league';
        };
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (conference) {
            if (!$state.is('league.drilldown.conference')) {
                _details.selectedElements.deselectAll();
                _league.toConferenceDrilldown(conference);
            }
            else {
                _details.toggleSelection(conference);
            }
        };
    }]).directive('conferenceItem', [
    '_associations',
    function (_associations) {
        /**
         * conference-item directive
         */
        return {
            restrict: 'E',
            controller: 'conferenceItem.ctrl',
            scope: {
                conference: '='
            },
            templateUrl: 'common/ui/conference-item/conference-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        var associations = _associations.getAssociated($scope.conference);
                        if (Common.Utilities.isNotNullOrUndefined(associations) &&
                            associations.leagues.hasElements()) {
                            $scope.conference.setLeague(associations.leagues.first());
                        }
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.directive('details', [
    function () {
        return {
            restrict: 'E',
            compile: function ($element, attrs) {
                return {
                    pre: function ($scope, $element, attrs, controller, transcludeFn) {
                    },
                    post: function ($scope, $element, attrs, controller, transcludeFn) {
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('divisionItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_league',
    '_associations',
    function ($scope, $state, _details, _league, _associations) {
        $scope.division;
        $scope.element;
        $scope.getConference = function (division) {
            return Common.Utilities.isNotNullOrUndefined(division) ?
                (Common.Utilities.isNotNullOrUndefined(division.conference) ?
                    division.conference.name : 'No league') :
                'No league';
        };
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (division) {
            if (!$state.is('league.drilldown.division')) {
                _details.selectedElements.deselectAll();
                _league.toDivisionDrilldown(division);
            }
            else {
                _details.toggleSelection(division);
            }
        };
    }]).directive('divisionItem', [
    '_associations',
    function (_associations) {
        /**
         * division-item directive
         */
        return {
            restrict: 'E',
            controller: 'divisionItem.ctrl',
            scope: {
                division: '='
            },
            templateUrl: 'common/ui/division-item/division-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        var associations = _associations.getAssociated($scope.division);
                        if (Common.Utilities.isNotNullOrUndefined(associations) &&
                            associations.conferences.hasElements()) {
                            $scope.division.setConference(associations.conferences.first());
                        }
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('expandable.ctrl', [
    '$scope',
    '_expandable',
    function ($scope, _expandable) {
        $scope.expandable;
    }]).directive('expandable', [
    '$compile',
    function ($compile) {
        return {
            restrict: 'E',
            controller: 'expandable.ctrl',
            transclude: true,
            replace: true,
            templateUrl: 'common/ui/expandable/expandable.tpl.html',
            scope: {
                collapsed: '=?',
                direction: '@',
                url: '@'
            },
            compile: function ($element, attrs) {
                return {
                    pre: function ($scope, $element, attrs, controller, transcludeFn) {
                        $scope.expandable = new Common.Models.Expandable($element);
                        $scope.expandable.url = $scope.url;
                        $scope.expandable.direction = $scope.direction;
                        $scope.expandable.collapsed = Boolean($scope.collapsed) === false ? false : true;
                        /**
                         * Set initial class on the element for proper sizing
                         */
                        $scope.expandable.setInitialClass();
                        $scope.expandable.ready = true;
                    },
                    post: function ($scope, $element, attrs, controller, transcludeFn) {
                    }
                };
            }
        };
    }])
    .directive('expandableToggle', [
    function () {
        return {
            restrict: 'E',
            controller: 'expandable.ctrl',
            transclude: true,
            replace: true,
            require: '^expandable',
            template: "<div class='width3 pad {{expandable.handle.position}} \
			gray-bg-3-hover pointer font- white'\
			ng-click='expandable.toggle()'>\
				<div class='glyphicon {{expandable.handle.class}}'></div>\
			</div>'",
            compile: function ($element, attrs) {
                return {
                    pre: function ($scope, $element, attrs, controller, transcludeFn) {
                    },
                    post: function ($scope, $element, attrs, controller, transcludeFn) {
                        /**
                         * Initialize the toggle handle
                         */
                        $scope.expandable.initializeToggleHandle();
                    }
                };
            }
        };
    }
]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.service('_expandable', [
    function () {
        this.elements = new Common.Models.Collection();
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('formationItem.ctrl', [
    '$scope',
    '_playbook',
    '_details',
    function ($scope, _playbook, _details) {
        $scope.play;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (formation) {
            _details.toggleSelection(formation);
        };
        $scope.openInEditor = function (formation) {
            _playbook.editFormation(formation);
        };
    }]).directive('formationItem', [
    function () {
        /**
         * play-item directive
         */
        return {
            restrict: 'E',
            controller: 'formationItem.ctrl',
            scope: {
                formation: '='
            },
            templateUrl: 'common/ui/formation-item/formation-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('formationPreview.ctrl', [
    '$scope', '$timeout', function ($scope, $timeout) {
        $scope.previewCanvas;
        $scope.play;
        $scope.$element;
        $scope.isModified = true;
        $scope.modificationTimer;
        $scope.refresh = function () {
            if (!$scope.play)
                throw new Error('formation-preview refresh(): Play is null or undefined');
            if (!$scope.play.formation)
                throw new Error('formation-preview refresh(): Formation is null or undefined');
            if (!$scope.previewCanvas)
                throw new Error('formation-preview refresh(): PreviewCanvas is null or undefined');
            if (!$scope.$element)
                throw new Error('formation-preview refresh(): $element is null or undefined');
            $scope.$element.find('svg').show();
            $scope.previewCanvas.refresh();
            $scope.play.formation.png = $scope.previewCanvas.exportToPng();
            $scope.isModified = false;
            var scrollTop = $scope.previewCanvas.paper.field.getLOSAbsolute()
                - ($scope.$element.height() / 2);
            $scope.$element.scrollTop(scrollTop);
            if ($scope.modificationTimer)
                $timeout.cancel($scope.modificationTimer);
        };
    }]).directive('formationPreview', [
    '$timeout',
    function ($timeout) {
        /**
         * formation-preview directive renders an SVG preview canvas
         * with the given formation data.
         */
        return {
            restrict: 'E',
            controller: 'formationPreview.ctrl',
            scope: {
                play: '='
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        // create a previewCanvas to handle preview creation. Creating
                        // a previewCanvas will insert a SVG into the <play-preview/> element
                        // after the intialization phase.
                        if (Common.Utilities.isNotNullOrUndefined($scope.play)) {
                            // get associated assignment group
                            //let associations = _associations.getAssociated($scope.play);
                            //$scope.play.assignmentGroup = associations.assignmentGroups.first();
                            var scenario = new Common.Models.Scenario();
                            scenario.setPlayPrimary($scope.play);
                            scenario.setPlayOpponent(null);
                            $scope.previewCanvas = new Playbook.Models.PreviewCanvas(scenario);
                        }
                        else {
                            // if there's no play at this point, there's a problem
                            throw new Error('play-preview link(): Unable to find play');
                        }
                        $scope.play.onModified(function () {
                            $scope.isModified = true;
                            if ($scope.modificationTimer)
                                $timeout.cancel($scope.modificationTimer);
                            $scope.modificationTimer = $timeout(function () {
                                console.log('auto refresh based on user changes');
                                $scope.refresh();
                            }, 200);
                        });
                        /**
                         *
                         * NOTE: Due to the way angular renders directives,
                         * we have to wrap DOM-dependent code in a $timeout.
                         *
                         */
                        $timeout(function () {
                            if ($scope.previewCanvas) {
                                $scope.previewCanvas.onready(function () {
                                    var scrollTop = $scope.previewCanvas.paper.field.getLOSAbsolute()
                                        - ($scope.$element.height() / 2);
                                    $scope.$element.scrollTop(scrollTop);
                                });
                                $scope.previewCanvas.initialize($element);
                                $scope.play.formation.png = $scope.previewCanvas.exportToPng();
                            }
                        }, 0);
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('formationThumbnail.ctrl', [
    '$scope', function ($scope) {
        $scope.formation;
    }]).directive('formationThumbnail', [
    function () {
        return {
            restrict: 'E',
            controller: 'formationThumbnail.ctrl',
            scope: {
                formation: '='
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        // get height of $element
                        var elementHeight = $element.height();
                        var img = document.createElement('img');
                        img.src = $scope.formation.png;
                        var $img = $(img);
                        $scope.$element.append($img);
                        img.addEventListener('load', function () {
                            var imgHeight = $img.height();
                            var imgOffsetTop = (-(imgHeight * 0.5) + (elementHeight / 2)) + 'px';
                            $img.css({ 'top': imgOffsetTop });
                        }, false);
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
/**
 * DESCRIPTION:
 * will take the enumerated "value" and the
 * fully-namespaced path to the enumeration object aka "type"
 * and will format the enumerated value as a string label
 * mapped to that enumerated value.
 *
 * I.e.
 * type: Team.Enums.UnitTypes
 * value: 3
 * result: "Offense"
 *
 * REQUIRED:
 * type: Namespaced location of enum "Playbook.Enums.EditorTypes"
 * value: Actual enumerated value
 */
impakt.common.ui.controller('typeFormatter.ctrl', [
    '$scope', function ($scope) {
        $scope.parseValue = function ($element) {
            // i.e. "['Playbook', 'Editor', 'EditorTypes']"
            var namespaceComponents = $scope.type.split('.');
            // Drill down into namespace -> window['Playbook']['Editor']['EditorTypes']
            // returns enum object
            var namespaceRoot = window;
            for (var i = 0; i < namespaceComponents.length; i++) {
                if (namespaceComponents[i]) {
                    // Follow the namespace path down to the node object
                    // window['Playbook']...
                    // window['Playbook']['Editor']...
                    // window['Playbook']['Editor']['EditorTypes']
                    // node reached, namespaceRoot will finally point to the node object
                    namespaceRoot = namespaceRoot[namespaceComponents[i]];
                }
            }
            // Get the enumeration list {enum: "Label"} || {number: string}
            var enumList = Common.Utilities.convertEnumToList(namespaceRoot);
            if (enumList) {
                // if it has values, get the Label string for the enum
                // and append it inside of the directive element
                var enumLabel = enumList[$scope.value];
                if (enumLabel) {
                    $element.html(enumLabel);
                }
            }
        };
    }]).directive('typeFormatter', [function () {
        return {
            restrict: 'E',
            controller: 'typeFormatter.ctrl',
            scope: {
                'value': '=',
                'type': '@'
            },
            link: function ($scope, $element, attrs) {
                if (!attrs.type) {
                    throw new Error('type-formatter directive: \
					A valid "type" attribute must be present on the element, \
					which is the fully namespaced type of the enum to evaluate.');
                }
                if (!attrs.value) {
                    throw new Error('type-formatter directive: \
					A valid "value" attribute must be present on the element, \
					which is the enum value to retrieve the string for.');
                }
                $scope.parseValue($element);
                $scope.$watch('value', function (oldVal, newVal) {
                    $scope.parseValue($element);
                });
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('gameItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_season',
    '_associations',
    function ($scope, $state, _details, _season, _associations) {
        $scope.game;
        $scope.element;
        $scope.getSeason = function (game) {
            return Common.Utilities.isNotNullOrUndefined(game) ?
                (Common.Utilities.isNotNullOrUndefined(game.season) ?
                    game.season.name : 'No season') :
                'No season';
        };
        $scope.getWeek = function (game) {
            return Common.Utilities.isNotNullOrUndefined(game) ?
                (Common.Utilities.isNotNullOrUndefined(game.week) ?
                    game.week.name : 'No week') :
                'No week';
        };
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (game) {
            if (!$state.is('season.drilldown.game')) {
                _details.selectedElements.deselectAll();
                _season.toGameDrilldown(game);
            }
            else {
                _details.toggleSelection(game);
            }
        };
    }]).directive('gameItem', [
    '_associations',
    function (_associations) {
        /**
         * game-item directive
         */
        return {
            restrict: 'E',
            controller: 'gameItem.ctrl',
            scope: {
                game: '='
            },
            templateUrl: 'common/ui/game-item/game-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        var associations = _associations.getAssociated($scope.game);
                        if (Common.Utilities.isNotNullOrUndefined(associations) &&
                            associations.seasons.hasElements()) {
                            $scope.game.setSeason(associations.seasons.first());
                        }
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('grid.ctrl', [
    '$scope',
    '_details',
    function ($scope, _details) {
        $scope.play;
        $scope.element;
    }]).directive('grid', [
    function () {
        /**
         * play-item directive
         */
        return {
            restrict: 'E',
            controller: 'grid.ctrl',
            scope: {
                element: '='
            },
            templateUrl: '',
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('impaktDatepicker.ctrl', [
    '$scope',
    function ($scope) {
        $scope.datetime;
        $scope.popup;
        $scope.togglePopup = function (open) {
            $scope.popup.opened = open === true ? true : !$scope.popup.opened;
        };
        $scope.updateMethod = function () {
            $scope.update();
        };
    }]).directive('impaktDatepicker', [
    function () {
        return {
            restrict: 'E',
            controller: 'impaktDatepicker.ctrl',
            templateUrl: 'common/ui/impakt-datepicker/impakt-datepicker.tpl.html',
            transclude: true,
            replace: false,
            scope: {
                datetime: '=',
                update: '&?'
            },
            link: function ($scope, $element, attrs) {
                $scope.popup = $scope.datetime.popup;
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.directive('ngPlaceholder', [
    '$sce',
    function ($sce) {
        return {
            restrict: 'A',
            require: '?ngModel',
            scope: {
                ngPlaceholder: '@'
            },
            link: function ($scope, $element, attrs, ngModel) {
                if (!$scope.ngPlaceholder || !attrs)
                    return;
                $element.focus(function () {
                    if (!_isNgModelSet())
                        _clear();
                }).blur(function () {
                    if (!_isNgModelSet())
                        _setPlaceholder();
                }).keyup(function (e) {
                    if (e.keyCode == Common.Input.Which.Backspace) {
                        if (!_isNgModelSet()) {
                            _clear();
                        }
                    }
                });
                $scope.$on("$destroy", function () {
                    $element.off('focus').off('blur').off('keyup');
                });
                function _clear() {
                    $element.val('');
                    _setNgModel('');
                    $element.removeAttr('style');
                }
                function _setNgModel(val) {
                    ngModel.$setViewValue(val);
                }
                function _setPlaceholder() {
                    if (!_isNgModelSet()) {
                        $element.css({
                            color: 'rgba(181, 182, 183, 0.8)',
                            '-webkit-text-fill-color': 'rgba(181, 182, 183, 0.8)',
                            'font-style': 'italic'
                        });
                        $element.val($scope.ngPlaceholder);
                    }
                    else {
                        $element.removeAttr('style');
                    }
                }
                function _isNgModelSet() {
                    return !isNaN(parseInt(ngModel.$viewValue)) || (Common.Utilities.isNotNullOrUndefined(ngModel.$viewValue) &&
                        Common.Utilities.isNotEmptyString(ngModel.$viewValue));
                }
                if (Common.Utilities.isNotNullOrUndefined(ngModel) &&
                    Common.Utilities.isNotNullOrUndefined(attrs.ngModel)) {
                    var modelValue = ngModel.$viewValue || null;
                    $scope.$watch(attrs.ngModel, function (newVal, oldVal) {
                        _setPlaceholder();
                    }, true);
                    if (Common.Utilities.isNullOrUndefined(modelValue)) {
                        _setPlaceholder();
                    }
                    else {
                        $element.removeClass('font-gray').addClass('font-white');
                        // Specify how UI should be updated
                        ngModel.$render = function () {
                            $element.val($sce.getTrustedHtml(ngModel.$viewValue || ''));
                        };
                    }
                }
            }
        };
    }
]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('leagueItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_league',
    '_associations',
    function ($scope, $state, _details, _league, _associations) {
        $scope.league;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (league) {
            if (!$state.is('league.drilldown.league')) {
                _details.selectedElements.deselectAll();
                _league.toLeagueDrilldown(league);
            }
            else {
                _details.toggleSelection(league);
            }
        };
    }]).directive('leagueItem', [
    '_associations',
    function (_associations) {
        /**
         * league-item directive
         */
        return {
            restrict: 'E',
            controller: 'leagueItem.ctrl',
            scope: {
                league: '='
            },
            templateUrl: 'common/ui/league-item/league-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        var associations = _associations.getAssociated($scope.league);
                        if (Common.Utilities.isNotNullOrUndefined(associations)) {
                        }
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('playItem.ctrl', [
    '$scope',
    '_details',
    '_playbook',
    function ($scope, _details, _playbook) {
        $scope.play;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (play) {
            _details.toggleSelection(play);
        };
        $scope.openInEditor = function (play) {
            _playbook.editPlay(play);
        };
    }]).directive('playItem', [
    function () {
        /**
         * play-item directive
         */
        return {
            restrict: 'E',
            controller: 'playItem.ctrl',
            scope: {
                play: '='
            },
            templateUrl: 'common/ui/play-item/play-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('playPreview.ctrl', [
    '$scope', '$timeout', function ($scope, $timeout) {
        $scope.previewCanvas;
        $scope.play;
        $scope.$element;
        $scope.isModified = true;
        $scope.modificationTimer;
        $scope.refresh = function () {
            if (!$scope.play)
                throw new Error('play-preview refresh(): Play is null or undefined');
            if (!$scope.previewCanvas)
                throw new Error('play-preview refresh(): PreviewCanvas is null or undefined');
            if (!$scope.$element)
                throw new Error('play-preview refresh(): $element is null or undefined');
            if ($scope.$element.height() <= 0) {
                console.warn('play-preview refresh(): $element height is <= 0, skipping the refresh.');
                return;
            }
            $scope.$element.find('svg').show();
            $scope.previewCanvas.refresh();
            $scope.play.png = $scope.previewCanvas.exportToPng();
            $scope.isModified = false;
            var scrollTop = $scope.previewCanvas.paper.field.getLOSAbsolute() - ($scope.$element.height() / 2);
            $scope.$element.scrollTop(scrollTop);
            if ($scope.modificationTimer)
                $timeout.cancel($scope.modificationTimer);
        };
    }]).directive('playPreview', [
    '$timeout',
    '_associations',
    function ($timeout, _associations) {
        /**
         * play-preview directive renders an SVG preview canvas
         * with the given play data.
         */
        return {
            restrict: 'E',
            controller: 'playPreview.ctrl',
            scope: {
                play: '='
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        // create a previewCanvas to handle preview creation. Creating
                        // a previewCanvas will insert a SVG into the <play-preview/> element
                        // after the intialization phase.
                        if (Common.Utilities.isNotNullOrUndefined($scope.play)) {
                            // get associated assignment group
                            //let associations = _associations.getAssociated($scope.play);
                            //$scope.play.assignmentGroup = associations.assignmentGroups.first();
                            var scenario = new Common.Models.Scenario();
                            scenario.setPlayPrimary($scope.play);
                            scenario.setPlayOpponent(null);
                            $scope.previewCanvas = new Playbook.Models.PreviewCanvas(scenario);
                        }
                        else {
                            // if there's no play at this point, there's a problem
                            throw new Error('play-preview link(): Unable to find play');
                        }
                        $scope.play.onModified(function () {
                            $scope.isModified = true;
                            if ($scope.modificationTimer)
                                $timeout.cancel($scope.modificationTimer);
                            $scope.modificationTimer = $timeout(function () {
                                console.log('auto refresh based on user changes');
                                $scope.refresh();
                            }, 200);
                        });
                        /**
                         *
                         * NOTE: Due to the way angular renders directives,
                         * we have to wrap DOM-dependent code in a $timeout.
                         *
                         */
                        $timeout(function () {
                            if ($scope.previewCanvas) {
                                $scope.previewCanvas.onready(function () {
                                    var scrollTop = $scope.previewCanvas.paper.field.getLOSAbsolute()
                                        - ($scope.$element.height() / 2);
                                    $scope.$element.scrollTop(scrollTop);
                                });
                                $scope.previewCanvas.initialize($element);
                                $scope.play.png = $scope.previewCanvas.exportToPng();
                            }
                        }, 0);
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.service('_playPreview', [function () {
        var self = this;
        this.viewBox = '';
        this.setViewBox = function (x, y, width, height) {
            this.viewBox = [
                x, ' ',
                y, ' ',
                width, ' ',
                height
            ].join('');
        };
        /**
         * Compresses a SVG element into a string for storage.
         * The SVG element is encoded into a base64 string before
         * compression.
         * @param {HTMLElement} svg The element to compress
         */
        this.compress = function (svg) {
            return Common.Utilities.compressSVG(svg);
        };
        /**
         * Decompresses a compressed SVG element string; assumes
         * the decompressed string is base64 encoded, so it decodes
         * the decompressed string before returning the stringified SVG element.
         * @param  {string} compressed The string to decmopress
         * @return {string}            a stringified SVG element
         */
        this.decompress = function (compressed) {
            return Common.Utilities.decompressSVG(compressed);
        };
        function serialize(svg) {
            // take SVG HTML and convert into string
            return Common.Utilities.serializeXMLToString(svg);
        }
        function toBase64(svgString) {
            return Common.Utilities.toBase64(svgString);
        }
        function fromBase64(base64Svg) {
            return Common.Utilities.fromBase64(base64Svg);
        }
        function compress(svg) {
            return Common.Utilities.compress(svg);
        }
        function decompress(compressed) {
            return Common.Utilities.decompress(compressed);
        }
        /**
         * TO-DO: store in local db
         */
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('playThumbnail.ctrl', [
    '$scope', function ($scope) {
        $scope.play;
    }]).directive('playThumbnail', [
    function () {
        return {
            restrict: 'E',
            controller: 'playThumbnail.ctrl',
            scope: {
                play: '='
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        // get height of $element
                        var elementHeight = $element.height();
                        var img = document.createElement('img');
                        img.src = $scope.play.png;
                        var $img = $(img);
                        $scope.$element.append($img);
                        img.addEventListener('load', function () {
                            var imgHeight = $img.height();
                            var imgOffsetTop = (-(imgHeight * 0.5) + (elementHeight / 2)) + 'px';
                            $img.css({ 'top': imgOffsetTop });
                        }, false);
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.directive('popout', [
    '$compile',
    function ($compile) {
        // button to open with label
        // open / close icon
        // open direction (up / down / left / right)
        return {
            restrict: 'E',
            controller: function ($scope) {
                console.debug('controller: popout.ctrl');
                $scope.collapsed = true;
                $scope.data = {};
                $scope.label = 'label';
                $scope.open = 'down';
                $scope.classes = {
                    expand: '',
                    collapse: ''
                };
                $scope.toggleIconClass = 'glyphicon-chevron-down';
                function init() {
                    $scope.toggleIconClass = $scope.setToggleIconClass();
                    $scope.collapsed = true;
                }
                $scope.getCollapsed = function () {
                    return $scope.collapsed;
                };
                $scope.getData = function () {
                    return $scope.data;
                };
                $scope.getLabel = function () {
                    return $scope.label;
                };
                $scope.getToggleIconClass = function () {
                    return $scope.toggleIconClass;
                };
                $scope.toggle = function (close) {
                    $scope.collapsed = close === true ? true : !$scope.collapsed;
                    $scope.toggleIconClass = $scope.setToggleIconClass();
                    removeClickeater();
                    if (!$scope.collapsed) {
                        // add clikeater element when toggling
                        var $clickeater = angular.element($('<popout-clickeater></popout-clickeater>'));
                        $compile($clickeater)($scope);
                        $('body').append($clickeater);
                    }
                    console.log($scope.collapsed ? 'close' : 'open', 'popout');
                };
                $scope.setToggleIconClass = function () {
                    switch ($scope.open) {
                        case 'down':
                            $scope.classes.expand = 'glyphicon-chevron-down';
                            $scope.classes.collapse = 'glyphicon-chevron-up';
                            break;
                        case 'up':
                            $scope.classes.expand = 'glyphicon-chevron-up';
                            $scope.classes.collapse = 'glyphicon-chevron-down';
                            break;
                        case 'left':
                            $scope.classes.expand = 'glyphicon-chevron-left';
                            $scope.classes.collapse = 'glyphicon-chevron-right';
                            break;
                        case 'right':
                            $scope.classes.expand = 'glyphicon-chevron-right';
                            $scope.classes.collapse = 'glyphicon-chevron-left';
                            break;
                    }
                    return $scope.collapsed ? $scope.classes.expand : $scope.classes.collapse;
                };
                $scope.close = function () {
                    $scope.toggle(true);
                };
                function removeClickeater() {
                    // remove in case it already exists
                    console.log('remove popout clickeater');
                    $('.popout-clickeater').remove();
                }
                init();
            },
            // scope: {
            // 	data: '=',
            // 	open: '=',
            // 	collapsed: '=?',
            // 	label: '=',
            // },
            scope: true,
            link: function ($scope, $element, attrs) {
            }
        };
    }]).directive('popoutToggle', [
    function () {
        return {
            restrict: 'E',
            require: '^popout',
            replace: true,
            transclude: true,
            scope: true,
            template: '<div class="popout-toggle" ng-click="toggle()">\
			<span class="marginRight1">{{label}}</span>\
			<span class="glyphicon {{toggleIconClass}}"></span>\
		</div>',
            link: function ($scope, $element, attrs) {
                console.log($scope);
            }
        };
    }])
    .directive('popoutContents', [function () {
        return {
            restrict: 'E',
            require: '^popout',
            scope: true,
            replace: true,
            transclude: true,
            template: '<div class="popout-contents" ng-show="!collapsed"></div>',
            link: function ($scope, $element, attrs) {
            }
        };
    }])
    .directive('popoutClickeater', [function () {
        return {
            restrict: 'E',
            scope: true,
            replace: true,
            transclude: true,
            template: '<div class="popout-clickeater" ng-click="close()"></div>',
            link: function ($scope, $element, attrs) {
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('quotes.ctrl', [
    '$scope',
    '$interval',
    '_quotes',
    function ($scope, $interval, _quotes) {
        $scope.$element;
        $scope.quote = _quotes.getRandomQuote();
        $interval(function () {
            $scope.quote = _quotes.getRandomQuote();
        }, 10000);
    }])
    .directive('quotes', [
    function () {
        return {
            restrict: 'E',
            templateUrl: 'common/ui/quotes/quotes.tpl.html',
            transclude: true,
            replace: true,
            controller: 'quotes.ctrl',
            link: function ($scope, $element, attrs) {
                $scope.$element = $element;
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.quotes = angular.module('impakt.quotes', [])
    .config([function () {
        console.debug('impakt.quotes - config');
    }])
    .run([function () {
        console.debug('impakt.quotes - run');
    }]);
/// <reference path='./quotes.mdl.ts' />
impakt.common.ui.quotes.service('_quotes', [
    function () {
        var quotes = [
            new Common.Models.Quote("It's not whether you get knocked down; \
			it's whether you get back up.", "Vince Lombardi"),
            new Common.Models.Quote("Winning isn't everything...it's the only thing.", "Vince Lombardi"),
            new Common.Models.Quote("The essence of football was blocking, tackling, \
			and execution based on timing, rhythm and deception.", "Knute Rockne"),
            new Common.Models.Quote("It's not the will to win, but the will to prepare \
			to win that makes the difference.", "Bear Bryant"),
            new Common.Models.Quote("We love football.", "Impakt Athletics"),
            new Common.Models.Quote("Football doesn't build character. It eliminates weak ones.", "Darrell Royal"),
            new Common.Models.Quote("Football is like life. It requires perseverance, self denial \
			hard work, sacrifice, dedication, and respect for authority.", "Vince Lombardi"),
            new Common.Models.Quote("If tomorrow wasn't promised, what would you give for today?", "Ray Lewis"),
            new Common.Models.Quote("I'm just here so I don't get fined.", "Marshawn Lynch"),
            new Common.Models.Quote("I wish I knew about [Impakt] 10 years ago, I wouldn't have so much damn gray hair now!", "Coach, USC"),
            new Common.Models.Quote("To me, this is a no brainer.", "Oregon"),
            new Common.Models.Quote("People are going to love this", "Harvard"),
            new Common.Models.Quote("This is really damn cool. I know I want it.", "Arizona"),
            new Common.Models.Quote("This is awesome. It fits perfectly with what we're trying to do.", "Michigan"),
            new Common.Models.Quote("This is really slick. I think the way you guys approached this was brilliant.", "Dallas Cowboys")
        ];
        this.getRandomQuote = function () {
            var index = Common.Utilities.randomInt(0, quotes.length - 1);
            return quotes[index];
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.factory('__router', [function () {
        var self = {
            templates: {},
            size: 0,
            index: 0,
            current: function () {
                return self.hasTemplates() ? self.templates[self.index] : null;
            },
            get: function (parent, templateName) {
                return self.templates[parent].filterFirst(function (template, index) {
                    return templateName == template.name;
                });
            },
            add: function (parent, template) {
                if (!self.templates[parent]) {
                    self.templates[parent] = new Common.Models.TemplateCollection(parent);
                    self.size++;
                }
                self.templates[parent].add(template);
            },
            push: function (parent, templates) {
                for (var i = 0; i < templates.length; i++) {
                    self.add(parent, templates[i]);
                }
            },
            next: function () {
                var oldIndex = self.index;
                if (self.hasTemplates()) {
                    self.index = self.hasNextTemplate() ? self.index + 1 : 0;
                }
                console.log('next layer:', oldIndex, '->', self.index, self.templates);
            },
            prev: function () {
                if (self.hasTemplates()) {
                    self.index = self.hasPrevTemplate() ? self.index - 1 : self.size - 1;
                }
            },
            to: function (index) {
                if (self.hasTemplates() && index >= 0 && index < self.size - 1) {
                    self.index = index;
                }
            },
            hasTemplates: function () {
                return self.templates && self.size > 0;
            },
            hasNextTemplate: function () {
                return self.index < self.size - 1;
            },
            hasPrevTemplate: function () {
                return self.index > 0;
            }
        };
        return self;
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('scenarioItem.ctrl', [
    '$scope',
    '_details',
    '_playbook',
    function ($scope, _details, _playbook) {
        $scope.scenario;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (scenario) {
            _details.toggleSelection(scenario);
        };
        $scope.openInEditor = function (scenario) {
            _playbook.editScenario(scenario);
        };
    }]).directive('scenarioItem', [
    function () {
        /**
         * scenario-item directive
         */
        return {
            restrict: 'E',
            controller: 'scenarioItem.ctrl',
            scope: {
                scenario: '='
            },
            templateUrl: 'common/ui/scenario-item/scenario-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('scenarioPreview.ctrl', [
    '$scope', '$timeout', function ($scope, $timeout) {
        $scope.previewCanvas;
        $scope.scenario;
        $scope.$element;
        $scope.isModified = true;
        $scope.modificationTimer;
        $scope.refresh = function () {
            if (!$scope.scenario)
                throw new Error('scenario-preview refresh(): Play is null or undefined');
            if (!$scope.previewCanvas)
                throw new Error('scenario-preview refresh(): PreviewCanvas is null or undefined');
            if (!$scope.$element)
                throw new Error('scenario-preview refresh(): $element is null or undefined');
            $scope.$element.find('svg').show();
            $scope.previewCanvas.updateScenario($scope.scenario);
            $scope.scenario.png = $scope.previewCanvas.exportToPng();
            $scope.isModified = false;
            var scrollTop = $scope.previewCanvas.paper.field.getLOSAbsolute() - ($scope.$element.height() / 2);
            $scope.$element.scrollTop(scrollTop);
            if ($scope.modificationTimer)
                $timeout.cancel($scope.modificationTimer);
        };
    }]).directive('scenarioPreview', [
    '$timeout',
    '_associations',
    function ($timeout, _associations) {
        /**
         * scenario-preview directive renders an SVG preview canvas
         * with the given scenario data.
         */
        return {
            restrict: 'E',
            controller: 'scenarioPreview.ctrl',
            scope: {
                scenario: '='
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        // create a previewCanvas to handle preview creation. Creating
                        // a previewCanvas will insert a SVG into the <scenario-preview/> element
                        // after the intialization phase.
                        if (Common.Utilities.isNotNullOrUndefined($scope.scenario)) {
                            $scope.previewCanvas = new Playbook.Models.PreviewCanvas($scope.scenario);
                        }
                        else {
                            // if there's no scenario at this point, there's a problem
                            throw new Error('scenario-preview link(): Unable to find scenario');
                        }
                        $scope.scenario.onModified(function () {
                            $scope.isModified = true;
                            if ($scope.modificationTimer)
                                $timeout.cancel($scope.modificationTimer);
                            $scope.modificationTimer = $timeout(function () {
                                console.log('auto refresh based on user changes');
                                $scope.refresh();
                            }, 200);
                        });
                        /**
                         *
                         * NOTE: Due to the way angular renders directives,
                         * we have to wrap DOM-dependent code in a $timeout.
                         *
                         */
                        $timeout(function () {
                            if ($scope.previewCanvas) {
                                $scope.previewCanvas.onready(function () {
                                    var scrollTop = $scope.previewCanvas.paper.field.getLOSAbsolute()
                                        - ($scope.$element.height() / 2);
                                    $scope.$element.scrollTop(scrollTop);
                                });
                                $scope.previewCanvas.initialize($element);
                                $scope.scenario.png = $scope.previewCanvas.exportToPng();
                            }
                        }, 0);
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.service('_scenarioPreview', [function () {
        var self = this;
        this.viewBox = '';
        this.setViewBox = function (x, y, width, height) {
            this.viewBox = [
                x, ' ',
                y, ' ',
                width, ' ',
                height
            ].join('');
        };
        /**
         * Compresses a SVG element into a string for storage.
         * The SVG element is encoded into a base64 string before
         * compression.
         * @param {HTMLElement} svg The element to compress
         */
        this.compress = function (svg) {
            return Common.Utilities.compressSVG(svg);
        };
        /**
         * Decompresses a compressed SVG element string; assumes
         * the decompressed string is base64 encoded, so it decodes
         * the decompressed string before returning the stringified SVG element.
         * @param  {string} compressed The string to decmopress
         * @return {string}            a stringified SVG element
         */
        this.decompress = function (compressed) {
            return Common.Utilities.decompressSVG(compressed);
        };
        function serialize(svg) {
            // take SVG HTML and convert into string
            return Common.Utilities.serializeXMLToString(svg);
        }
        function toBase64(svgString) {
            return Common.Utilities.toBase64(svgString);
        }
        function fromBase64(base64Svg) {
            return Common.Utilities.fromBase64(base64Svg);
        }
        function compress(svg) {
            return Common.Utilities.compress(svg);
        }
        function decompress(compressed) {
            return Common.Utilities.decompress(compressed);
        }
        /**
         * TO-DO: store in local db
         */
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('scenarioThumbnail.ctrl', [
    '$scope', function ($scope) {
        $scope.scenario;
    }]).directive('scenarioThumbnail', [
    function () {
        return {
            restrict: 'E',
            controller: 'scenarioThumbnail.ctrl',
            scope: {
                scenario: '='
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        // get height of $element
                        var elementHeight = $element.height();
                        var img = document.createElement('img');
                        img.src = $scope.scenario.png;
                        var $img = $(img);
                        $scope.$element.append($img);
                        img.addEventListener('load', function () {
                            var imgHeight = $img.height();
                            var imgOffsetTop = (-(imgHeight * 0.5) + (elementHeight / 2)) + 'px';
                            $img.css({ 'top': imgOffsetTop });
                        }, false);
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.directive('search', [
    function () {
        return {
            restrict: 'E',
            templateUrl: 'common/ui/search/search.tpl.html',
            transclude: true,
            replace: true,
            link: function ($scope, $element, attrs) {
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('seasonItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_season',
    '_associations',
    function ($scope, $state, _details, _season, _associations) {
        $scope.season;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (season) {
            if (!$state.is('season.drilldown.season')) {
                _details.selectedElements.deselectAll();
                _season.toSeasonDrilldown(season);
            }
            else {
                _details.toggleSelection(season);
            }
        };
    }]).directive('seasonItem', [
    '_associations',
    function (_associations) {
        /**
         * season-item directive
         */
        return {
            restrict: 'E',
            controller: 'seasonItem.ctrl',
            scope: {
                season: '='
            },
            templateUrl: 'common/ui/season-item/season-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        var associations = _associations.getAssociated($scope.season);
                        if (Common.Utilities.isNotNullOrUndefined(associations)) {
                        }
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('stepper.ctrl', [
    '$scope',
    function ($scope) {
        console.info('stepper directive controller');
        $scope.index = 0;
        $scope.steps = [];
        $scope.$element = null;
        $scope.to = function (index) {
            $($scope.$element.find('step')[index]).show();
            $($scope.$element.find('step')[$scope.index]).hide();
            $scope.index = index;
        };
        $scope.prev = function () {
            if ($scope.index - 1 >= 0)
                $scope.to($scope.index - 1);
        };
        $scope.next = function () {
            if ($scope.index + 1 < $scope.steps.length)
                $scope.to($scope.index + 1);
        };
        $scope.isVisible = function () {
            return true;
        };
    }]).directive('stepper', [
    '$compile',
    function ($compile) {
        return {
            restrict: 'E',
            controller: 'stepper.ctrl',
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) {
                    },
                    post: function postLink($scope, $element, attrs, controller) {
                        var mode = attrs.mode;
                        var HTML = '<step-nav>\
									<step-nav-item ng-repeat="step in steps track by $index" \
										class="gray-bg-7-hover"\
										ng-click="to($index)">\
										{{$index + 1}}\
									</step-nav-item>\
								</step-nav>';
                        var el = angular.element($compile(HTML)($scope));
                        //$element.append(el);
                        $scope.$element = $element;
                    }
                };
            }
        };
    }]).directive('step', [
    '$compile',
    function ($compile) {
        return {
            restrict: 'E',
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) {
                        var guid = Common.Utilities.guid();
                        $element.attr('guid', guid);
                        var index = $scope.steps.length;
                        var step = {
                            guid: guid,
                            visible: false,
                            index: index
                        };
                        $scope.steps.push(step);
                        if (index != 0) {
                            $element.hide();
                        }
                        //console.log($scope.steps);
                    },
                    post: function postLink($scope, $element, attrs, controller) {
                    }
                };
            }
        };
    }])
    .directive('stepNav', [
    function () {
        return {
            restrict: 'E',
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) {
                    },
                    post: function postLink($scope, $element, attrs, controller) {
                    }
                };
            }
        };
    }
])
    .directive('stepNavItem', [
    function () {
        return {
            restrict: 'E',
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) {
                    },
                    post: function postLink($scope, $element, attrs, controller) {
                    }
                };
            }
        };
    }
]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.directive('camelCaseToSpace', [function () {
        return {
            restrict: 'A',
            scope: {
                string: '@',
                capitalize: '@'
            },
            link: function ($scope, $element, attrs) {
                if (!$scope.string)
                    return;
                $scope.capitalize = Boolean($scope.capitalize);
                $scope.string = Common.Utilities.camelCaseToSpace($scope.string, $scope.capitalize);
                $element.html($scope.string);
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('teamItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_league',
    '_associations',
    function ($scope, $state, _details, _league, _associations) {
        $scope.team;
        $scope.element;
        $scope.getConference = function (team) {
            return Common.Utilities.isNotNullOrUndefined(team) ?
                (Common.Utilities.isNotNullOrUndefined(team.division) ?
                    team.division.name : 'No division') :
                'No division';
        };
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (team) {
            if (!$state.is('league.drilldown.team')) {
                _details.selectedElements.deselectAll();
                _league.toTeamDrilldown(team);
            }
            else {
                _details.toggleSelection(team);
            }
        };
    }]).directive('teamItem', [
    '_associations',
    function (_associations) {
        /**
         * team-item directive
         */
        return {
            restrict: 'E',
            controller: 'teamItem.ctrl',
            scope: {
                team: '='
            },
            templateUrl: 'common/ui/team-item/team-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                        var associations = _associations.getAssociated($scope.team);
                        if (Common.Utilities.isNotNullOrUndefined(associations) &&
                            associations.divisions.hasElements()) {
                            $scope.team.setDivision(associations.divisions.first());
                        }
                    }
                };
            }
        };
    }]);
/// <reference path='../ui.mdl.ts' />
impakt.common.ui.controller('weekItem.ctrl', [
    '$scope',
    '$state',
    '_details',
    '_season',
    '_associations',
    function ($scope, $state, _details, _season, _associations) {
        $scope.week;
        $scope.season;
        $scope.element;
        /**
         *
         *	Item selection
         *
         */
        $scope.toggleSelection = function (week) {
            if (!$state.is('season.drilldown.week')) {
                _details.selectedElements.deselectAll();
                _season.toWeekDrilldown(week);
            }
            else {
                _details.toggleSelection(week);
            }
        };
    }]).directive('weekItem', [
    '_associations',
    function (_associations) {
        /**
         * week-item directive
         */
        return {
            restrict: 'E',
            controller: 'weekItem.ctrl',
            scope: {
                week: '='
            },
            templateUrl: 'common/ui/week-item/week-item.tpl.html',
            transclude: true,
            replace: true,
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink($scope, $element, attrs, controller) { },
                    post: function postLink($scope, $element, attrs, controller) {
                        $scope.$element = $element;
                    }
                };
            }
        };
    }]);
/// <reference path='../js/impakt.ts' />
impakt.modules = angular.module('impakt.modules', [
    'impakt.main',
    'impakt.home',
    'impakt.league',
    'impakt.season',
    'impakt.planning',
    'impakt.analysis',
    'impakt.playbook',
    'impakt.nav',
    'impakt.user',
    'impakt.search',
    'impakt.team',
    'impakt.sidebar',
    'impakt.details'
])
    .config(['$stateProvider', '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {
        console.debug('impakt.modules - config');
    }])
    .run(function () {
    console.debug('impakt.modules - run');
});
/// <reference path='../modules.mdl.ts' />
impakt.analysis = angular.module('impakt.analysis', [])
    .config([function () {
        console.debug('impakt.analysis - config');
    }]).run([function () {
        console.debug('impakt.analysis - run');
    }]);
/// <reference path='../modules.mdl.ts' />
impakt.details = angular.module('impakt.details', [])
    .config(function () {
    console.debug('impakt.details - config');
})
    .run(function () {
    console.debug('impakt.details - run');
});
/// <reference path='./details.mdl.ts' />
impakt.details.controller('details.ctrl', [
    '$scope',
    '$rootScope',
    '$q',
    '$timeout',
    '__context',
    '__modals',
    '_details',
    '_associations',
    function ($scope, $rootScope, $q, $timeout, __context, __modals, _details, _associations) {
        $scope.expandable = $scope.expandable;
        $scope.selectedElements = _details.selectedElements;
        $scope.selectedElement = null;
        $scope.associations = new Common.Models.AssociationResults();
        $scope.populatedAssociationKeys = [];
        $scope.playbooks;
        $scope._details = _details;
        $scope.collapsed = Common.Utilities.isNotNullOrUndefined($scope.expandable) ? $scope.expandable.collapsed : true;
        var modifiedListenerSet = false;
        __context.onReady(function () {
            $scope.playbooks = impakt.context.Playbook.playbooks;
        });
        var createEntityListener = $rootScope.$on('create-entity', function (e, entity) {
            modifiedListenerSet = false;
            init();
        });
        var associationsUpdateListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            $scope.selectedElements.clearListeners();
            createEntityListener();
            associationsUpdateListener();
        });
        function init() {
            if (!$scope.selectedElements.hasListeners()) {
                $scope.selectedElements.onModified(function (selectedElements) {
                    if (Common.Utilities.isNotNullOrUndefined($scope.expandable)) {
                        $scope.selectedElements.isEmpty() ?
                            !$scope.expandable.collapsed && $scope.expandable.close() :
                            $scope.expandable.collapsed && $scope.expandable.open();
                    }
                    _initAssociated();
                });
            }
            // Load initial associations, don't wait for the modification handler
            // for selected elements to fire.
            _initAssociated();
        }
        function _initAssociated() {
            if (Common.Utilities.isNullOrUndefined($scope.selectedElements) ||
                $scope.selectedElements.isEmpty())
                return;
            $scope.selectedElement = $scope.selectedElements.first();
            if (Common.Utilities.isNotNullOrUndefined($scope.selectedElement)) {
                $scope.associations = _associations.getAssociated($scope.selectedElement);
                if (Common.Utilities.isNotNullOrUndefined($scope.associations)) {
                    $scope.populatedAssociationKeys = $scope.associations.getPopulatedAssociationKeys();
                }
            }
        }
        $scope.delete = function (entity) {
            _details.delete(entity).then(function () {
                // entity has been successfully deleted...
                // grab the associations again to apply
                // changes
                _initAssociated();
                $scope.selectedElements.remove($scope.selectedElement.guid);
            });
        };
        $scope.update = function (entity) {
            _details.update(entity).then(function () {
            });
        };
        init();
    }]);
/// <reference path='./details.mdl.ts' />
impakt.details.service('_details', [
    '$q',
    '_league',
    '_playbook',
    '_team',
    '_season',
    function ($q, _league, _playbook, _team, _season) {
        this.selectedElements = impakt.context.Actionable.selected;
        this.state = {
            collapsed: true
        };
        var self = this;
        this.selectedElements.onModified(function (collection) {
            if (collection.hasElements())
                self.state.collapsed = false;
        });
        this.toggleSelection = function (element) {
            this.selectedElements.deselectAll();
            if (!this.selectedElements.contains(element.guid)) {
                element.select();
                this.selectedElements.only(element);
            }
            else {
                this.selectedElements.empty();
            }
        };
        this.updatePlay = function (play) {
            _playbook.updatePlay(play);
        };
        /**
         * NOTE: if the given entity's impaktDataType is not supported,
         * an exception will be thrown; this is because the function MUST
         * return a promise object (which is defined within the `deleteEntityByType` methods
         * below in their respecitve services). If no applicable case is met,
         * we have nothing left but to stop traffic and complain.
         *
         * @param {Common.Interfaces.IActionable} entity [description]
         */
        this.delete = function (entity) {
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Play:
                case Common.Enums.ImpaktDataTypes.Formation:
                case Common.Enums.ImpaktDataTypes.AssignmentGroup:
                case Common.Enums.ImpaktDataTypes.Scenario:
                case Common.Enums.ImpaktDataTypes.Playbook:
                    return _playbook.deleteEntityByType(entity);
                case Common.Enums.ImpaktDataTypes.Conference:
                case Common.Enums.ImpaktDataTypes.League:
                case Common.Enums.ImpaktDataTypes.Division:
                case Common.Enums.ImpaktDataTypes.Location:
                    return _league.deleteEntityByType(entity);
                case Common.Enums.ImpaktDataTypes.Team:
                case Common.Enums.ImpaktDataTypes.PersonnelGroup:
                    return _team.deleteEntityByType(entity);
                case Common.Enums.ImpaktDataTypes.Season:
                case Common.Enums.ImpaktDataTypes.Game:
                    return _season.deleteEntityByType(entity);
                default:
                    throw new Error('_details delete(): entity ImpaktDataType not supported ' + entity.impaktDataType);
            }
        };
        /**
         * NOTE: if the given entity's impaktDataType is not supported,
         * an exception will be thrown; this is because the function MUST
         * return a promise object (which is defined within the `updateEntityByType` methods
         * below in their respecitve services). If no applicable case is met,
         * we have nothing left but to stop traffic and complain.
         *
         * @param {Common.Interfaces.IActionable} entity [description]
         */
        this.update = function (entity) {
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Play:
                case Common.Enums.ImpaktDataTypes.Formation:
                case Common.Enums.ImpaktDataTypes.AssignmentGroup:
                case Common.Enums.ImpaktDataTypes.Scenario:
                case Common.Enums.ImpaktDataTypes.Playbook:
                    return _playbook.updateEntityByType(entity);
                case Common.Enums.ImpaktDataTypes.Conference:
                case Common.Enums.ImpaktDataTypes.League:
                case Common.Enums.ImpaktDataTypes.Division:
                case Common.Enums.ImpaktDataTypes.Location:
                    return _league.updateEntityByType(entity);
                case Common.Enums.ImpaktDataTypes.Team:
                case Common.Enums.ImpaktDataTypes.PersonnelGroup:
                    return _team.updateEntityByType(entity);
                case Common.Enums.ImpaktDataTypes.Season:
                case Common.Enums.ImpaktDataTypes.Game:
                    return _season.updateEntityByType(entity);
                default:
                    throw new Error('_details update(): entity ImpaktDataType not supported ' + entity.impaktDataType);
            }
        };
    }]);
/// <reference path='../modules.mdl.ts' />
impakt.home = angular.module('impakt.home', [])
    .config([function () {
        console.debug('impakt.home - config');
    }])
    .run(function () {
    console.debug('impakt.home - run');
});
/// <reference path='./home.mdl.ts' />
impakt.home.controller('home.ctrl', ['$scope', '$state', '__context', '_home',
    function ($scope, $state, __context, _home) {
        $scope.currentOrganization;
        $scope.menuItems = _home.menuItems;
        $scope.goTo = function (menuItem) {
            $scope.menuItems.activate(menuItem);
        };
        __context.onReady(function () {
            $scope.currentOrganization = impakt.context.Organization.current;
        });
    }]);
/// <reference path='./home.mdl.ts' />
// Home service
impakt.home.service('_home', [
    '$state', '__nav',
    function ($state, __nav) {
        this.menuItems = __nav.menuItems;
    }]);
/// <reference path='../modules.mdl.ts' />
/// <reference path='./league.ts' />
impakt.league = angular.module('impakt.league', [
    'impakt.league.browser',
    'impakt.league.drilldown',
    'impakt.league.modals'
])
    .config([
    '$stateProvider',
    '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {
        console.debug('impakt.league - config');
        // impakt module states
        $stateProvider.state('league', {
            url: '/league',
            templateUrl: 'modules/league/league.tpl.html',
            controller: 'league.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league - run');
});
/// <reference path='../league.mdl.ts' />
impakt.league.browser = angular.module('impakt.league.browser', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.league.browser - config');
        $stateProvider.state('league.browser', {
            url: '/browser',
            templateUrl: 'modules/league/browser/league-browser.tpl.html',
            controller: 'league.browser.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league.browser - run');
});
/// <reference path='./league-browser.mdl.ts' />
impakt.league.browser.controller('league.browser.ctrl', ['$scope', '_league', '_leagueModals', '_teamModals',
    function ($scope, _league, _leagueModals, _teamModals) {
        $scope.leagues = impakt.context.League.leagues;
        $scope.teams = impakt.context.Team.teams;
        $scope.conferences = impakt.context.League.conferences;
        $scope.createLeague = function () {
            _leagueModals.createLeague();
        };
        $scope.createTeam = function () {
            _teamModals.createTeam();
        };
        $scope.teamDrilldown = function (team) {
            _league.toTeamDrilldown(team);
        };
    }]);
/// <reference path='../league.mdl.ts' />
impakt.league.drilldown = angular.module('impakt.league.drilldown', [
    'impakt.league.drilldown.league',
    'impakt.league.drilldown.conference',
    'impakt.league.drilldown.division',
    'impakt.league.drilldown.team'
])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.league.drilldown - config');
        $stateProvider.state('league.drilldown', {
            url: '/drilldown',
            templateUrl: 'modules/league/drilldown/league-drilldown.tpl.html',
            controller: 'league.drilldown.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league.drilldown - run');
});
/// <reference path='../league-drilldown.mdl.ts' />
impakt.league.drilldown.conference = angular.module('impakt.league.drilldown.conference', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.league.drilldown.conference - config');
        $stateProvider.state('league.drilldown.conference', {
            url: '/conference',
            templateUrl: 'modules/league/drilldown/conference/league-drilldown-conference.tpl.html',
            controller: 'league.drilldown.conference.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league.drilldown.conference - run');
});
/// <reference path='./league-drilldown-conference.mdl.ts' />
impakt.league.drilldown.conference.controller('league.drilldown.conference.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    '_league',
    '_leagueModals',
    '_teamModals',
    function ($scope, $rootScope, _associations, _league, _leagueModals, _teamModals) {
        $scope.league = _league.drilldown.league;
        $scope.conference = _league.drilldown.conference;
        $scope.divisions = new League.Models.DivisionCollection();
        var deleteDivisionListener = $rootScope.$on('delete-division', function (e, division) {
            $scope.divisions.remove(division.guid);
        });
        var associationsUpdatedListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            deleteDivisionListener();
            associationsUpdatedListener();
        });
        function init() {
            var conferenceAssociations = _associations.getAssociated($scope.conference);
            $scope.conference.setLeague($scope.league);
            if (Common.Utilities.isNotNullOrUndefined(conferenceAssociations)) {
                $scope.divisions = conferenceAssociations.divisions;
                $scope.divisions.forEach(function (division, index) {
                    var divisionAssociations = _associations.getAssociated(division);
                    division.setConference($scope.conference);
                });
            }
        }
        $scope.createDivision = function (conference) {
            _leagueModals.createDivision(conference)
                .then(function () {
                init();
            });
        };
        $scope.toDivisionDrilldown = function (division) {
            _league.toDivisionDrilldown(division);
        };
        init();
    }]);
/// <reference path='../league-drilldown.mdl.ts' />
impakt.league.drilldown.division = angular.module('impakt.league.drilldown.division', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.league.drilldown.division - config');
        $stateProvider.state('league.drilldown.division', {
            url: '/division',
            templateUrl: 'modules/league/drilldown/division/league-drilldown-division.tpl.html',
            controller: 'league.drilldown.division.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league.drilldown.division - run');
});
/// <reference path='./league-drilldown-division.mdl.ts' />
impakt.league.drilldown.division.controller('league.drilldown.division.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    '_league',
    '_leagueModals',
    '_teamModals',
    function ($scope, $rootScope, _associations, _league, _leagueModals, _teamModals) {
        $scope.league = _league.drilldown.league;
        $scope.conference = _league.drilldown.conference;
        $scope.division = _league.drilldown.division;
        $scope.teams = new Team.Models.TeamModelCollection();
        var deleteTeamListener = $rootScope.$on('delete-team', function (e, team) {
            $scope.teams.remove(team.guid);
        });
        var associationsUpdatedListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            associationsUpdatedListener();
            deleteTeamListener();
        });
        function init() {
            var divisionAssociations = _associations.getAssociated($scope.division);
            $scope.division.setConference($scope.conference);
            if (Common.Utilities.isNotNullOrUndefined(divisionAssociations)) {
                $scope.teams = divisionAssociations.teams;
                $scope.teams.forEach(function (team, index) {
                    var teamAssociations = _associations.getAssociated(team);
                    team.setDivision($scope.division);
                });
            }
        }
        $scope.createTeam = function (division) {
            _teamModals.createTeam(division)
                .then(function () {
                init();
            });
        };
        init();
    }]);
/// <reference path='./league-drilldown.mdl.ts' />
impakt.league.drilldown.controller('league.drilldown.ctrl', [
    '$scope',
    '_details',
    '_league',
    function ($scope, _details, _league) {
        $scope.drilldown = _league.drilldown;
        $scope.toLeagueDrilldown = function (league) {
            _league.toLeagueDrilldown(league);
        };
        $scope.toConferenceDrilldown = function (conference) {
            _league.toConferenceDrilldown(conference);
        };
        $scope.toDivisionDrilldown = function (division) {
            _league.toDivisionDrilldown(division);
        };
        $scope.toTeamDrilldown = function (team) {
            _league.toTeamDrilldown(team);
        };
        $scope.toBrowser = function () {
            _details.selectedElements.deselectAll();
            _league.toBrowser();
        };
    }]);
/// <reference path='../league-drilldown.mdl.ts' />
impakt.league.drilldown.league = angular.module('impakt.league.drilldown.league', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.league.drilldown.league - config');
        $stateProvider.state('league.drilldown.league', {
            url: '/league',
            templateUrl: 'modules/league/drilldown/league/league-drilldown-league.tpl.html',
            controller: 'league.drilldown.league.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league.drilldown.league - run');
});
/// <reference path='./league-drilldown-league.mdl.ts' />
impakt.league.drilldown.league.controller('league.drilldown.league.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    '_league',
    '_leagueModals',
    function ($scope, $rootScope, _associations, _league, _leagueModals) {
        $scope.league = _league.drilldown.league;
        $scope.conferences = new League.Models.ConferenceCollection();
        var deleteConferenceListener = $rootScope.$on('delete-conference', function (e, conference) {
            $scope.conferences.remove(conference.guid);
        });
        var associationsUpdatedListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            deleteConferenceListener();
            associationsUpdatedListener();
        });
        function init() {
            var leagueAssociations = _associations.getAssociated($scope.league);
            if (Common.Utilities.isNotNullOrUndefined(leagueAssociations)) {
                $scope.conferences = leagueAssociations.conferences;
                $scope.conferences.forEach(function (conference, index) {
                    var conferenceAssociations = _associations.getAssociated(conference);
                    conference.setLeague($scope.league);
                });
            }
        }
        $scope.createConference = function () {
            _leagueModals.createConference($scope.league)
                .then(function () {
                init();
            });
        };
        init();
    }]);
/// <reference path='../league-drilldown.mdl.ts' />
impakt.league.drilldown.team = angular.module('impakt.league.drilldown.team', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.league.drilldown.team - config');
        $stateProvider.state('league.drilldown.team', {
            url: '/team',
            templateUrl: 'modules/league/drilldown/team/league-drilldown-team.tpl.html',
            controller: 'league.drilldown.team.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.league.drilldown.team - run');
});
/// <reference path='./league-drilldown-team.mdl.ts' />
impakt.league.drilldown.team.controller('league.drilldown.team.ctrl', [
    '$scope',
    '_league',
    '_teamModals',
    function ($scope, _league, _teamModals) {
        $scope.team = _league.drilldown.team;
        $scope.conferences = impakt.context.League.conferences;
        $scope.delete = function () {
            _teamModals.deleteTeam($scope.team);
        };
    }]);
/// <reference path='./league.mdl.ts' />
/**
 * League constants defined here
 */
impakt.league.constant('LEAGUE', {
    ENDPOINT: '/teamInfo',
    GENERAL_ENDPOINT: '/general',
    // League
    CREATE_LEAGUE: '/createLeague',
    GET_LEAGUES: '/getLeagues',
    GET_LEAGUE: '/getLeague',
    DELETE_LEAGUE: '/deleteLeague',
    // League Teams
    CREATE_TEAM: '/createTeam',
    GET_TEAMS: '/getTeams',
    GET_TEAM: '/getTeam',
    DELETE_TEAM: '/deleteTeam',
    // League Conferences
    CREATE_CONFERENCE: '/createConference',
    GET_CONFERENCES: '/getConferences',
    GET_CONFERENCE: '/getConference',
    DELETE_CONFERENCE: '/deleteConference',
    UPDATE_CONFERENCE: '/updateConference',
    // League Divisions
    CREATE_DIVISION: '/createDivision',
    GET_DIVISIONS: '/getDivisions',
    GET_DIVISION: '/getDivision',
    DELETE_DIVISION: '/deleteDivision',
    UPDATE_DIVISION: '/updateDivision',
    // League Locations
    CREATE_LOCATION: '/createLocation',
    GET_LOCATIONS: '/getLocations',
    GET_LOCATION: '/getLocation',
    DELETE_LOCATION: '/deleteLocation',
    UPDATE_LOCATION: '/updateLocation',
});
/// <reference path='./league.mdl.ts' />
impakt.league.controller('league.ctrl', ['$scope', '$state', '_league',
    function ($scope, $state, _league) {
        // load up the browser by default
        $state.go('league.browser');
    }]);
/// <reference path='./models/models.ts' />
/// <reference path='./league.ts' />
// League service
impakt.league.service('_league', [
    'LEAGUE',
    '$rootScope',
    '$q',
    '$state',
    '__api',
    '__localStorage',
    '__notifications',
    '_leagueModals',
    function (LEAGUE, $rootScope, $q, $state, __api, __localStorage, __notifications, _leagueModals) {
        var self = this;
        this.drilldown = {
            league: null,
            conference: null,
            division: null,
            team: null
        };
        /**
         * Retrieves all leagues
         */
        this.getLeagues = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting leagues...');
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_LEAGUES))
                .then(function (response) {
                var collection = new League.Models.LeagueModelCollection();
                if (response && response.data && response.data.results) {
                    var leagueResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < leagueResults.length; i++) {
                        var leagueResult = leagueResults[i];
                        if (leagueResult && leagueResult.data && leagueResult.data.model) {
                            var leagueModel = new League.Models.LeagueModel();
                            leagueResult.data.model.key = leagueResult.key;
                            leagueModel.fromJson(leagueResult.data.model);
                            collection.add(leagueModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Leagues successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Leagues');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single league with the given key
         * @param {number} key The key of the league to retrieve
         */
        this.getLeague = function (key) {
            var d = $q.defer();
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_LEAGUE, '/' + key))
                .then(function (response) {
                var league = Common.Utilities.parseData(response.data.results);
                d.resolve(league);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a league model to the server for storage
         * @param {Common.Models.LeagueModel} leagueModel The model to be created/saved
         */
        this.createLeague = function (newLeagueModel) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newLeagueModel)) {
                var nameExists = impakt.context.League.leagues.hasElementWhich(function (leagueModel, index) {
                    return leagueModel.name == newLeagueModel.name;
                });
                if (nameExists) {
                    var notification_1 = __notifications.warning('Failed to create league. League "', newLeagueModel.name, '" already exists.');
                    _leagueModals.createLeagueDuplicate(newLeagueModel);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newLeagueModel.key = -1;
            var leagueModelJson = newLeagueModel.toJson();
            var notification = __notifications.pending('Creating league "', newLeagueModel.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.CREATE_LEAGUE), {
                version: 1,
                name: newLeagueModel.name,
                data: {
                    version: 1,
                    model: leagueModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var leagueModel = new League.Models.LeagueModel();
                if (results && results.data && results.data.model) {
                    results.data.model.key = results.key;
                    leagueModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.League.leagues.add(leagueModel);
                }
                else {
                    throw new Error('CreateLeague did not return a valid league model');
                }
                notification.success('Successfully created league "', leagueModel.name, '"');
                $rootScope.$broadcast('create-entity', leagueModel);
                d.resolve(leagueModel);
            }, function (error) {
                notification.error('Failed to create league "', newLeagueModel.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given league for the current user
         * @param {League.Models.LeagueModel} league The league to be deleted
         */
        this.deleteLeague = function (league) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting league "', league.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.DELETE_LEAGUE), { key: league.key }).then(function (response) {
                // update the context
                impakt.context.League.leagues.remove(league.guid);
                notification.success('Deleted league "', league.name, '"');
                if ($state.is('league.drilldown.league'))
                    self.toBrowser();
                d.resolve(league);
            }, function (error) {
                notification.error('Failed to delete league "', league.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given league for the current user
         * @param {League.Models.LeagueModel} league The league to update
         */
        this.updateLeague = function (league) {
            var d = $q.defer();
            // update assignment collection to json object
            var leagueJson = league.toJson();
            var notification = __notifications.pending('Updating league "', league.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.UPDATE_LEAGUE), {
                version: 1,
                name: leagueJson.name,
                key: leagueJson.key,
                data: {
                    version: 1,
                    key: leagueJson.key,
                    model: leagueJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var leagueModel = new League.Models.LeagueModel();
                if (results && results.data && results.data.model) {
                    leagueModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.League.leagues.set(leagueModel.guid, leagueModel);
                }
                notification.success('Successfully updated league "', league.name, '"');
                d.resolve(leagueModel);
            }, function (error) {
                notification.error('Failed to update league "', league.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all conferences
         */
        this.getConferences = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting conferences...');
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_CONFERENCES))
                .then(function (response) {
                var collection = new League.Models.ConferenceCollection();
                if (response && response.data && response.data.results) {
                    var conferenceResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < conferenceResults.length; i++) {
                        var conferenceResult = conferenceResults[i];
                        if (conferenceResult && conferenceResult.data && conferenceResult.data.conference) {
                            var conferenceModel = new League.Models.Conference();
                            conferenceResult.data.conference.key = conferenceResult.key;
                            conferenceModel.fromJson(conferenceResult.data.conference);
                            collection.add(conferenceModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Conferences successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Conferences');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single conference with the given key
         * @param {number} key The key of the conference to retrieve
         */
        this.getConference = function (key) {
            var d = $q.defer();
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_CONFERENCE, '/' + key))
                .then(function (response) {
                var conference = Common.Utilities.parseData(response.data.results);
                d.resolve(conference);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a conference model to the server for storage
         * @param {Common.Models.Conference} newConference The conference to be created/saved
         */
        this.createConference = function (newConference) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newConference)) {
                var nameExists = impakt.context.League.conferences.hasElementWhich(function (conferenceModel, index) {
                    return conferenceModel.name == newConference.name;
                });
                if (nameExists) {
                    var notification_2 = __notifications.warning('Failed to create conference. Conference "', newConference.name, '" already exists.');
                    _leagueModals.createConferenceDuplicate(newConference);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newConference.key = -1;
            var conferenceModelJson = newConference.toJson();
            var notification = __notifications.pending('Creating conference "', newConference.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.CREATE_CONFERENCE), {
                version: 1,
                name: newConference.name,
                data: {
                    version: 1,
                    conference: conferenceModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var conferenceModel = new League.Models.Conference();
                if (results && results.data && results.data.conference) {
                    results.data.conference.key = results.key;
                    conferenceModel.fromJson(results.data.conference);
                    // update the context
                    impakt.context.League.conferences.add(conferenceModel);
                }
                else {
                    throw new Error('CreateConference did not return a valid conference');
                }
                notification.success('Successfully created conference "', conferenceModel.name, '"');
                $rootScope.$broadcast('create-entity', conferenceModel);
                d.resolve(conferenceModel);
            }, function (error) {
                notification.error('Failed to create conference "', newConference.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given conference for the current user
         * @param {League.Models.Conference} conference The conference to be deleted
         */
        this.deleteConference = function (conference) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting conference "', conference.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.DELETE_CONFERENCE), { key: conference.key }).then(function (response) {
                // update the context
                impakt.context.League.conferences.remove(conference.guid);
                notification.success('Deleted conference "', conference.name, '"');
                d.resolve(conference);
            }, function (error) {
                notification.error('Failed to delete conference "', conference.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given conference for the current user
         * @param {League.Models.Conference} conference The conference to update
         */
        this.updateConference = function (conference) {
            var d = $q.defer();
            // update assignment collection to json object
            var conferenceJson = conference.toJson();
            var notification = __notifications.pending('Updating conference "', conference.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.UPDATE_CONFERENCE), {
                version: 1,
                name: conferenceJson.name,
                key: conferenceJson.key,
                data: {
                    version: 1,
                    key: conferenceJson.key,
                    conference: conferenceJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var conferenceModel = new League.Models.Conference();
                if (results && results.data && results.data.conference) {
                    conferenceModel.fromJson(results.data.conference);
                    // update the context
                    impakt.context.League.conferences.set(conferenceModel.guid, conferenceModel);
                }
                notification.success('Successfully updated conference "', conference.name, '"');
                d.resolve(conferenceModel);
            }, function (error) {
                notification.error('Failed to update conference "', conference.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all divisions
         */
        this.getDivisions = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting divisions...');
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_DIVISIONS))
                .then(function (response) {
                var collection = new League.Models.DivisionCollection();
                if (response && response.data && response.data.results) {
                    var divisionResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < divisionResults.length; i++) {
                        var divisionResult = divisionResults[i];
                        if (divisionResult && divisionResult.data && divisionResult.data.division) {
                            var divisionModel = new League.Models.Division();
                            divisionResult.data.division.key = divisionResult.key;
                            divisionModel.fromJson(divisionResult.data.division);
                            collection.add(divisionModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Divisions successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Divisions');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single division with the given key
         * @param {number} key The key of the division to retrieve
         */
        this.getDivision = function (key) {
            var d = $q.defer();
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_DIVISION, '/' + key))
                .then(function (response) {
                var division = Common.Utilities.parseData(response.data.results);
                d.resolve(division);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a division model to the server for storage
         * @param {Common.Models.Division} newDivision The division to be created/saved
         */
        this.createDivision = function (newDivision) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newDivision)) {
                var nameExists = impakt.context.League.divisions.hasElementWhich(function (divisionModel, index) {
                    return divisionModel.name == newDivision.name;
                });
                if (nameExists) {
                    var notification_3 = __notifications.warning('Failed to create division. Division "', newDivision.name, '" already exists.');
                    _leagueModals.createDivisionDuplicate(newDivision);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newDivision.key = -1;
            var divisionModelJson = newDivision.toJson();
            var notification = __notifications.pending('Creating division "', newDivision.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.CREATE_DIVISION), {
                version: 1,
                name: newDivision.name,
                data: {
                    version: 1,
                    division: divisionModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var divisionModel = new League.Models.Division();
                if (results && results.data && results.data.division) {
                    results.data.division.key = results.key;
                    divisionModel.fromJson(results.data.division);
                    // update the context
                    impakt.context.League.divisions.add(divisionModel);
                }
                else {
                    throw new Error('CreateDivision did not return a valid division');
                }
                notification.success('Successfully created division "', divisionModel.name, '"');
                $rootScope.$broadcast('create-entity', divisionModel);
                d.resolve(divisionModel);
            }, function (error) {
                notification.error('Failed to create division "', newDivision.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given division for the current user
         * @param {League.Models.Division} division The division to be deleted
         */
        this.deleteDivision = function (division) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting division "', division.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.DELETE_DIVISION), { key: division.key }).then(function (response) {
                // update the context
                impakt.context.League.divisions.remove(division.guid);
                notification.success('Deleted division "', division.name, '"');
                d.resolve(division);
            }, function (error) {
                notification.error('Failed to delete division "', division.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given division for the current user
         * @param {League.Models.Division} division The division to update
         */
        this.updateDivision = function (division) {
            var d = $q.defer();
            // update assignment collection to json object
            var divisionJson = division.toJson();
            var notification = __notifications.pending('Updating division "', division.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.UPDATE_DIVISION), {
                version: 1,
                name: divisionJson.name,
                key: divisionJson.key,
                data: {
                    version: 1,
                    key: divisionJson.key,
                    division: divisionJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var divisionModel = new League.Models.Division();
                if (results && results.data && results.data.division) {
                    divisionModel.fromJson(results.data.division);
                    // update the context
                    impakt.context.League.divisions.set(divisionModel.guid, divisionModel);
                }
                notification.success('Successfully updated division "', division.name, '"');
                d.resolve(divisionModel);
            }, function (error) {
                notification.error('Failed to update division "', division.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all locations
         */
        this.getLocations = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting locations...');
            __api.get(__api.path(LEAGUE.GENERAL_ENDPOINT, LEAGUE.GET_LOCATIONS))
                .then(function (response) {
                var collection = new League.Models.LocationCollection();
                if (response && response.data && response.data.results) {
                    var locationResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < locationResults.length; i++) {
                        var locationResult = locationResults[i];
                        if (locationResult && locationResult.data && locationResult.data.location) {
                            var locationModel = new League.Models.Location();
                            locationResult.data.location.key = locationResult.key;
                            locationModel.fromJson(locationResult.data.location);
                            collection.add(locationModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Locations successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Locations');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single location with the given key
         * @param {number} key The key of the location to retrieve
         */
        this.getLocation = function (key) {
            var d = $q.defer();
            __api.get(__api.path(LEAGUE.GENERAL_ENDPOINT, LEAGUE.GET_LOCATION, '/' + key))
                .then(function (response) {
                var location = Common.Utilities.parseData(response.data.results);
                d.resolve(location);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a location model to the server for storage
         * @param {Common.Models.Location} newLocation The location to be created/saved
         */
        this.createLocation = function (newLocation) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newLocation)) {
                var nameExists = impakt.context.League.locations.hasElementWhich(function (locationModel, index) {
                    return locationModel.name == newLocation.name;
                });
                if (nameExists) {
                    var notification_4 = __notifications.warning('Failed to create location. Location "', newLocation.name, '" already exists.');
                    _leagueModals.createLocationDuplicate(newLocation);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newLocation.key = -1;
            var locationModelJson = newLocation.toJson();
            var notification = __notifications.pending('Creating location "', newLocation.name, '"...');
            __api.post(__api.path(LEAGUE.GENERAL_ENDPOINT, LEAGUE.CREATE_LOCATION), {
                version: 1,
                name: newLocation.name,
                data: {
                    version: 1,
                    location: locationModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var locationModel = new League.Models.Location();
                if (results && results.data && results.data.location) {
                    results.data.location.key = results.key;
                    locationModel.fromJson(results.data.location);
                    // update the context
                    impakt.context.League.locations.add(locationModel);
                }
                else {
                    throw new Error('CreateLocation did not return a valid location');
                }
                notification.success('Successfully created location "', locationModel.name, '"');
                $rootScope.$broadcast('create-entity', locationModel);
                d.resolve(locationModel);
            }, function (error) {
                notification.error('Failed to create location "', newLocation.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given location for the current user
         * @param {League.Models.Location} location The location to be deleted
         */
        this.deleteLocation = function (location) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting location "', location.name, '"...');
            __api.post(__api.path(LEAGUE.GENERAL_ENDPOINT, LEAGUE.DELETE_LOCATION), { key: location.key }).then(function (response) {
                // update the context
                impakt.context.League.locations.remove(location.guid);
                notification.success('Deleted location "', location.name, '"');
                d.resolve(location);
            }, function (error) {
                notification.error('Failed to delete location "', location.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given location for the current user
         * @param {League.Models.Location} location The location to update
         */
        this.updateLocation = function (location) {
            var d = $q.defer();
            // update assignment collection to json object
            var locationJson = location.toJson();
            var notification = __notifications.pending('Updating location "', location.name, '"...');
            __api.post(__api.path(LEAGUE.GENERAL_ENDPOINT, LEAGUE.UPDATE_LOCATION), {
                version: 1,
                name: locationJson.name,
                key: locationJson.key,
                data: {
                    version: 1,
                    key: locationJson.key,
                    location: locationJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var locationModel = new League.Models.Location();
                if (results && results.data && results.data.location) {
                    locationModel.fromJson(results.data.location);
                    // update the context
                    impakt.context.League.locations.set(locationModel.guid, locationModel);
                }
                notification.success('Successfully updated location "', location.name, '"');
                d.resolve(locationModel);
            }, function (error) {
                notification.error('Failed to update location "', location.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        this.deleteEntityByType = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity))
                return;
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.League:
                    return _leagueModals.deleteLeague(entity);
                case Common.Enums.ImpaktDataTypes.Conference:
                    return _leagueModals.deleteConference(entity);
                case Common.Enums.ImpaktDataTypes.Division:
                    return _leagueModals.deleteDivision(entity);
                default:
                    d.reject(new Error('_league deleteEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise;
        };
        this.updateEntityByType = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity))
                return;
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.League:
                    return _leagueModals.saveLeague(entity);
                case Common.Enums.ImpaktDataTypes.Conference:
                    return _leagueModals.saveConference(entity);
                case Common.Enums.ImpaktDataTypes.Division:
                    return _leagueModals.saveDivision(entity);
                default:
                    d.reject(new Error('_league saveEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise;
        };
        this.toBrowser = function () {
            this.drilldown.league = null;
            this.drilldown.team = null;
            $state.transitionTo('league.browser');
        };
        this.toLeagueDrilldown = function (league) {
            this.drilldown.league = league;
            this.drilldown.conference = null;
            this.drilldown.division = null;
            this.drilldown.team = null;
            impakt.context.League.leagues.select(league);
            _deselectEntities(false, true, true, true);
            impakt.context.Actionable.selected.only(league);
            $state.transitionTo('league.drilldown.league');
        };
        this.toConferenceDrilldown = function (conference) {
            this.drilldown.conference = conference;
            this.drilldown.division = null;
            this.drilldown.team = null;
            impakt.context.League.conferences.select(conference);
            _deselectEntities(true, false, true, true);
            impakt.context.Actionable.selected.only(conference);
            $state.transitionTo('league.drilldown.conference');
        };
        this.toDivisionDrilldown = function (division) {
            this.drilldown.division = division;
            this.drilldown.team = null;
            impakt.context.League.divisions.select(division);
            _deselectEntities(true, true, false, true);
            impakt.context.Actionable.selected.only(division);
            $state.transitionTo('league.drilldown.division');
        };
        this.toTeamDrilldown = function (team) {
            this.drilldown.team = team;
            impakt.context.Team.teams.select(team);
            _deselectEntities(true, true, true, false);
            impakt.context.Actionable.selected.only(team);
            $state.transitionTo('league.drilldown.team');
        };
        function _deselectEntities(deselectLeagues, deselectConferences, deselectDivisions, deselectTeam) {
            deselectLeagues && impakt.context.League.leagues.deselectAll();
            deselectConferences && impakt.context.League.conferences.deselectAll();
            deselectDivisions && impakt.context.League.divisions.deselectAll();
            deselectTeam && impakt.context.Team.teams.deselectAll();
        }
    }]);
/// <reference path='../league.mdl.ts' />
impakt.league.modals = angular.module('impakt.league.modals', [])
    .config(function () {
    console.debug('impakt.league.modals - config');
})
    .run(function () {
    console.debug('impakt.league.modals - run');
});
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createConferenceDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'conference',
    function ($scope, $uibModalInstance, _league, conference) {
        $scope.conference = conference;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createConference.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_league',
    'league',
    function ($scope, $uibModalInstance, _associations, _league, league) {
        $scope.leagues = impakt.context.League.leagues;
        $scope.newConference = new League.Models.Conference();
        $scope.selectedLeague = league ? league : $scope.leagues.first();
        $scope.ok = function () {
            _league.createConference($scope.newConference)
                .then(function (createdConference) {
                _associations.createAssociations(createdConference, [
                    $scope.selectedLeague
                ]);
                removeConferenceFromCreationContext();
                $uibModalInstance.close(createdConference);
            }, function (err) {
                removeConferenceFromCreationContext();
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            removeConferenceFromCreationContext();
            $uibModalInstance.dismiss();
        };
        function removeConferenceFromCreationContext() {
            // Remove the play from the creation context
            // after creating the new play or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.newConference))
                impakt.context.League.creation.conferences.remove($scope.newConference.guid);
        }
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createDivisionDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'division',
    function ($scope, $uibModalInstance, _league, division) {
        $scope.division = division;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createDivision.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_league',
    'conference',
    function ($scope, $uibModalInstance, _associations, _league, conference) {
        $scope.conferences = impakt.context.League.conferences;
        $scope.newDivision = new League.Models.Division();
        $scope.selectedConference = conference ? conference : $scope.conferences.first();
        function init() {
            if (Common.Utilities.isNotNullOrUndefined($scope.selectedConference))
                $scope.newDivision.setConference($scope.selectedConference);
        }
        $scope.selectConference = function () {
            $scope.newDivision.setConference($scope.selectedConference);
        };
        $scope.ok = function () {
            if (Common.Utilities.isNullOrUndefined($scope.selectedConference))
                return;
            _league.createDivision($scope.newDivision)
                .then(function (createdDivision) {
                var associationsToAdd = [
                    $scope.selectedConference
                ];
                if (Common.Utilities.isNotNullOrUndefined($scope.selectedConference.league)) {
                    associationsToAdd.push($scope.selectedConference.league);
                }
                _associations.createAssociations(createdDivision, associationsToAdd);
                removeDivisionFromCreationContext();
                $uibModalInstance.close(createdDivision);
            }, function (err) {
                removeDivisionFromCreationContext();
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            removeDivisionFromCreationContext();
            $uibModalInstance.dismiss();
        };
        function removeDivisionFromCreationContext() {
            // Remove the play from the creation context
            // after creating the new play or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.newDivision))
                impakt.context.League.creation.divisions.remove($scope.newDivision.guid);
        }
        init();
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createLeagueDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'league',
    function ($scope, $uibModalInstance, _league, league) {
        $scope.league = league;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createLeague.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    function ($scope, $uibModalInstance, _league) {
        $scope.newLeagueModel = new League.Models.LeagueModel();
        $scope.ok = function () {
            _league.createLeague($scope.newLeagueModel)
                .then(function (createdLeague) {
                $uibModalInstance.close(createdLeague);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createLocationDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'location',
    function ($scope, $uibModalInstance, _league, location) {
        $scope.location = location;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.createLocation.ctrl', [
    '$scope',
    '$rootScope',
    '$uibModalInstance',
    '_associations',
    '_league',
    'associatedEntity',
    function ($scope, $rootScope, $uibModalInstance, _associations, _league, associatedEntity) {
        $scope.newLocation = new League.Models.Location();
        $scope.associatedEntity = associatedEntity;
        $scope.ok = function () {
            _league.createLocation($scope.newLocation)
                .then(function (createdLocation) {
                // take in an optional associated entity, so that upon creation
                // of this location, we're able to also construct the association
                // between the two entities.
                if (Common.Utilities.isNotNullOrUndefined($scope.associatedEntity)) {
                    _associations.createAssociation(createdLocation, $scope.associatedEntity);
                }
                $uibModalInstance.close(createdLocation);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.deleteConference.ctrl', [
    '$scope',
    '$rootScope',
    '$uibModalInstance',
    '_league',
    'conference',
    function ($scope, $rootScope, $uibModalInstance, _league, conference) {
        $scope.conference = conference;
        $scope.ok = function () {
            _league.deleteConference($scope.conference)
                .then(function (results) {
                $rootScope.$broadcast('delete-conference', $scope.conference);
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.deleteDivision.ctrl', [
    '$scope',
    '$rootScope',
    '$uibModalInstance',
    '_league',
    'division',
    function ($scope, $rootScope, $uibModalInstance, _league, division) {
        $scope.division = division;
        $scope.ok = function () {
            _league.deleteDivision($scope.division)
                .then(function (results) {
                $rootScope.$broadcast('delete-division', $scope.division);
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.deleteLeague.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'league',
    function ($scope, $uibModalInstance, _league, league) {
        $scope.league = league;
        $scope.ok = function () {
            _league.deleteLeague($scope.league)
                .then(function (results) {
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.deleteLocation.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'location',
    function ($scope, $uibModalInstance, _league, location) {
        $scope.location = location;
        $scope.ok = function () {
            _league.deleteLocation($scope.location)
                .then(function (results) {
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='./league-modals.mdl.ts' />
impakt.league.modals.service('_leagueModals', [
    '$q',
    '__modals',
    function ($q, __modals) {
        /**
         *
         * LEAGUE
         *
         */
        this.createLeague = function () {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-league/create-league.tpl.html', 'league.modals.createLeague.ctrl', {});
            modalInstance.result.then(function (createdLeague) {
                console.log(createdLeague);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createLeagueDuplicate = function (leagueModel) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-league-duplicate-error/create-league-duplicate-error.tpl.html', 'league.modals.createLeagueDuplicateError.ctrl', {
                league: function () {
                    return leagueModel;
                }
            });
            modalInstance.result.then(function (createdLeague) {
                console.log(createdLeague);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteLeague = function (league) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/delete-league/delete-league.tpl.html', 'league.modals.deleteLeague.ctrl', {
                league: function () {
                    return league;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveLeague = function (league) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/save-league/save-league.tpl.html', 'league.modals.saveLeague.ctrl', {
                league: function () {
                    return league;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * CONFERENCE
         *
         */
        this.createConference = function (league) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-conference/create-conference.tpl.html', 'league.modals.createConference.ctrl', {
                league: function () {
                    return league;
                }
            });
            modalInstance.result.then(function (createdConference) {
                console.log(createdConference);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createConferenceDuplicate = function (conference) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-conference-duplicate-error/create-conference-duplicate-error.tpl.html', 'league.modals.createConferenceDuplicateError.ctrl', {
                conference: function () {
                    return conference;
                }
            });
            modalInstance.result.then(function (createdConference) {
                console.log(createdConference);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteConference = function (conference) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/delete-conference/delete-conference.tpl.html', 'league.modals.deleteConference.ctrl', {
                conference: function () {
                    return conference;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveConference = function (conference) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/save-conference/save-conference.tpl.html', 'league.modals.saveConference.ctrl', {
                conference: function () {
                    return conference;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * DIVISION
         *
         */
        this.createDivision = function (conference) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-division/create-division.tpl.html', 'league.modals.createDivision.ctrl', {
                conference: function () {
                    return conference;
                }
            });
            modalInstance.result.then(function (createdDivision) {
                console.log(createdDivision);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createDivisionDuplicate = function (division) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-division-duplicate-error/create-division-duplicate-error.tpl.html', 'league.modals.createDivisionDuplicateError.ctrl', {
                division: function () {
                    return division;
                }
            });
            modalInstance.result.then(function (createdDivision) {
                console.log(createdDivision);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteDivision = function (division) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/delete-division/delete-division.tpl.html', 'league.modals.deleteDivision.ctrl', {
                division: function () {
                    return division;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveDivision = function (division) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/save-division/save-division.tpl.html', 'league.modals.saveDivision.ctrl', {
                division: function () {
                    return division;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * LOCATION
         *
         */
        this.createLocation = function (associatedEntity) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-location/create-location.tpl.html', 'league.modals.createLocation.ctrl', {
                associatedEntity: function () {
                    return associatedEntity;
                }
            });
            modalInstance.result.then(function (createdLocation) {
                console.log(createdLocation);
                d.resolve(createdLocation);
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createLocationDuplicate = function (locationModel) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/create-location-duplicate-error/create-location-duplicate-error.tpl.html', 'league.modals.createLocationDuplicateError.ctrl', {
                location: function () {
                    return locationModel;
                }
            });
            modalInstance.result.then(function (createdLocation) {
                console.log(createdLocation);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteLocation = function (location) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/delete-location/delete-location.tpl.html', 'league.modals.deleteLocation.ctrl', {
                location: function () {
                    return location;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveLocation = function (location) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/league/modals/save-location/save-location.tpl.html', 'league.modals.saveLocation.ctrl', {
                location: function () {
                    return location;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.saveConference.ctrl', ['$scope',
    '$uibModalInstance',
    '_league',
    'conference',
    function ($scope, $uibModalInstance, _league, conference) {
        $scope.conference = conference;
        $scope.ok = function () {
            _league.updateConference($scope.conference)
                .then(function (savedConference) {
                $uibModalInstance.close(savedConference);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.saveDivision.ctrl', ['$scope',
    '$uibModalInstance',
    '_league',
    'division',
    function ($scope, $uibModalInstance, _league, division) {
        $scope.division = division;
        $scope.ok = function () {
            _league.updateDivision($scope.division)
                .then(function (savedDivision) {
                $uibModalInstance.close(savedDivision);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.saveLeague.ctrl', ['$scope',
    '$uibModalInstance',
    '_league',
    'league',
    function ($scope, $uibModalInstance, _league, league) {
        $scope.league = league;
        $scope.ok = function () {
            _league.updateLeague($scope.league)
                .then(function (savedLeague) {
                $uibModalInstance.close(savedLeague);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../league-modals.mdl.ts' />
impakt.league.modals.controller('league.modals.saveLocation.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_league',
    'location',
    function ($scope, $uibModalInstance, _league, location) {
        $scope.location = location;
        $scope.ok = function () {
            _league.updateLocation($scope.location)
                .then(function (savedLocation) {
                $uibModalInstance.close(savedLocation);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var Location = (function (_super) {
            __extends(Location, _super);
            function Location() {
                _super.call(this, Common.Enums.ImpaktDataTypes.Location);
                this.associable = [
                    'games',
                    'teams'
                ];
            }
            Location.prototype.copy = function (newLocation) {
                var copyLocation = newLocation || new League.Models.Location();
                return _super.prototype.copy.call(this, copyLocation, this);
            };
            Location.prototype.toJson = function () {
                return $.extend({
                    name: this.name,
                }, _super.prototype.toJson.call(this));
            };
            Location.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.name = json.name;
                _super.prototype.fromJson.call(this, json);
            };
            return Location;
        })(Common.Models.AssociableEntity);
        Models.Location = Location;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='./models.ts' />
var League;
(function (League) {
    var Models;
    (function (Models) {
        var LocationCollection = (function (_super) {
            __extends(LocationCollection, _super);
            function LocationCollection() {
                _super.call(this);
            }
            LocationCollection.prototype.toJson = function () {
                return {
                    guid: this.guid,
                    locations: _super.prototype.toJson.call(this)
                };
            };
            LocationCollection.prototype.fromJson = function (json) {
                if (!json)
                    return;
                this.guid = json.guid;
                var locationArray = json.locations || [];
                for (var i = 0; i < locationArray.length; i++) {
                    var rawLocationModel = locationArray[i];
                    if (Common.Utilities.isNullOrUndefined(rawLocationModel)) {
                        continue;
                    }
                    var locationModel = new League.Models.Location();
                    locationModel.fromJson(rawLocationModel);
                    this.add(locationModel);
                }
            };
            return LocationCollection;
        })(Common.Models.ActionableCollection);
        Models.LocationCollection = LocationCollection;
    })(Models = League.Models || (League.Models = {}));
})(League || (League = {}));
/// <reference path='../modules.mdl.ts' />
impakt.main = angular.module('impakt.main', [])
    .config([function () {
        console.debug('impakt.main - config');
    }])
    .run([function () {
        console.debug('impakt.main - run');
    }]);
/// <reference path='./main.mdl.ts' />
impakt.main.controller('main.ctrl', [
    '$scope',
    '__context',
    function ($scope, __context) {
        $scope.appVisible = false;
        __context.onReady(function () {
            $scope.appVisible = true;
            if (!$scope.$$phase) {
                $scope.$apply();
            }
        });
    }]);
/// <reference path='../modules.mdl.ts' />
impakt.nav = angular.module('impakt.nav', [
    'impakt.user',
    'impakt.playbook.nav'
])
    .config(function () {
    console.debug('impakt.nav - config');
})
    .run(function () {
    console.debug('impakt.nav - run');
});
/// <reference path='./nav.mdl.ts' />
impakt.nav.controller('nav.ctrl', [
    '$scope',
    '$location',
    '__nav',
    '__notifications',
    function ($scope, $location, __nav, __notifications) {
        // Default menu visiblity
        $scope.isMenuCollapsed = true;
        $scope.notifications = __notifications.notifications;
        $scope.currentYear = (new Date()).getFullYear();
        $scope.menuItems = __nav.menuItems;
        $scope.notificationsMenuItem = __nav.notificationsMenuItem;
        $scope.searchMenuItem = __nav.searchMenuItem;
        // set default view to the Home module
        $location.path('/home');
        $scope.navigatorNavSelection = getActiveNavItemLabel();
        $scope.searchItemClick = function () {
            $scope.searchMenuItem.toggleActivation();
        };
        $scope.notificationItemClick = function () {
            $scope.notificationsMenuItem.isActive = !$scope.notificationsMenuItem.isActive;
            $scope.menuVisibilityToggle($scope.notificationsMenuItem, false);
        };
        $scope.menuVisibilityToggle = function (navigationItem, propagate) {
            $scope.isMenuCollapsed = !$scope.isMenuCollapsed;
            propagate && $scope.menuItemClick(navigationItem);
        };
        $scope.menuItemClick = function (navigationItem) {
            $scope.menuItems.activate(navigationItem);
            $scope.navigatorNavSelection = navigationItem.label;
        };
        function getActiveNavItemLabel() {
            var activeNavItem = $scope.menuItems.getActive();
            return activeNavItem ? activeNavItem.label : null;
        }
    }]);
/// <reference path='./nav.mdl.ts' />
// Nav factory
impakt.nav.factory('__nav', [
    '$http',
    '$q',
    '$state',
    function ($http, $q, $state) {
        var menuItems = new Navigation.Models.NavigationItemCollection();
        // Home
        menuItems.add(new Navigation.Models.NavigationItem('home', 'Home', 'home', '/home', true, function (self) {
            $state.transitionTo('home');
        }));
        // League
        menuItems.add(new Navigation.Models.NavigationItem('league', 'League', 'globe', '/league', false, function (self) {
            $state.transitionTo('league.browser');
        }));
        // Season
        menuItems.add(new Navigation.Models.NavigationItem('season', 'Season', 'calendar', '/season', false, function (self) {
            $state.transitionTo('season');
        }));
        // Playbook
        menuItems.add(new Navigation.Models.NavigationItem('playbook', 'Playbook', 'book', '/playbook/browser', false, function (self) {
            $state.transitionTo('playbook.browser');
        }));
        // Planning
        menuItems.add(new Navigation.Models.NavigationItem('planning', 'Planning', 'blackboard', '/planning', false, function (self) {
            $state.transitionTo('planning');
        }));
        // Analysis
        menuItems.add(new Navigation.Models.NavigationItem('analysis', 'Analysis', 'facetime-video', '/analysis', false, function (self) {
            $state.transitionTo('analysis');
        }));
        // Team
        menuItems.add(new Navigation.Models.NavigationItem('team', 'Team', 'list-alt', '/team', false, function (self) {
            $state.transitionTo('team');
        }));
        // Profile
        menuItems.add(new Navigation.Models.NavigationItem('profile', 'Profile', 'user', '/profile', false, function (self) {
            $state.transitionTo('profile');
        }));
        // Search
        var searchMenuItem = new Navigation.Models.NavigationItem('search', 'Search', 'search', null, false, function (self) { });
        // Notifications
        var notificationsMenuItem = new Navigation.Models.NavigationItem('notifications', 'Notifications', 'bell', null, false, function (self) { });
        // TODO @theBull - implement
        // ,
        // film: {
        // 	label: 'Film',
        // 	glyphicon: 'film',
        // 	path: '/film',
        // 	isActive: false
        // },
        // stats: {
        // 	label: 'Stats',
        // 	glyphicon: 'signal',
        // 	path: '/stats',
        // 	isActive: false
        // }
        return {
            menuItems: menuItems,
            searchMenuItem: searchMenuItem,
            notificationsMenuItem: notificationsMenuItem
        };
    }]);
/// <reference path='../modules.mdl.ts' />
impakt.modules = angular.module('impakt.planning', [])
    .config([function () {
        console.debug('impakt.planning - config');
    }])
    .run(function () {
    console.debug('impakt.planning - run');
});
/// <reference path='./playbook.ts' />
/// <reference path='../modules.mdl.ts' />
impakt.playbook = angular.module('impakt.playbook', [
    'ui.router',
    'impakt.common',
    'impakt.playbook.contextmenus',
    'impakt.playbook.modals',
    'impakt.playbook.browser',
    'impakt.playbook.drilldown',
    'impakt.playbook.editor',
    'impakt.playbook.layout',
    'impakt.playbook.nav',
])
    .config([
    '$stateProvider',
    '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {
        console.debug('impakt.playbook - config');
        // impakt module states
        $stateProvider.state('playbook', {
            url: '/playbook',
            templateUrl: 'modules/playbook/playbook.tpl.html',
            controller: 'playbook.ctrl'
        });
    }])
    .run([function () {
        console.debug('impakt.playbook - run');
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.browser = angular.module('impakt.playbook.browser', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.playbook.browser - config');
        $stateProvider.state('playbook.browser', {
            url: '/browser',
            templateUrl: 'modules/playbook/browser/playbook-browser.tpl.html',
            controller: 'playbook.browser.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.playbook.browser - run');
});
/// <reference path='./playbook-browser.mdl.ts' />
impakt.playbook.browser.controller('playbook.browser.ctrl', [
    '$scope',
    '__context',
    '_details',
    '_associations',
    '_playbook',
    '_playbookModals',
    function ($scope, __context, _details, _associations, _playbook, _playbookModals) {
        $scope.editor;
        $scope.playbooks;
        $scope.formations;
        $scope.plays;
        $scope.assignmentGroups;
        $scope.scenarios;
        _details.selectedPlay = null;
        __context.onReady(function () {
            $scope.editor = impakt.context.Playbook.editor;
            $scope.playbooks = impakt.context.Playbook.playbooks;
            $scope.formations = impakt.context.Playbook.formations;
            $scope.plays = impakt.context.Playbook.plays;
            $scope.assignmentGroups = impakt.context.Playbook.assignmentGroups;
            $scope.scenarios = impakt.context.Playbook.scenarios;
        });
        $scope.getEditorTypeClass = function (editorType) {
            return _playbook.getEditorTypeClass(editorType);
        };
        $scope.openEditor = function () {
            _playbook.toEditor();
        };
        $scope.createPlaybook = function () {
            _playbookModals.createPlaybook();
        };
        $scope.deletePlaybook = function (playbook) {
            _playbookModals.deletePlaybook(playbook).then(function (data) {
                // navigate back to the main browser view
                $scope.goToAll();
            }, function (err) {
            });
        };
        $scope.createScenario = function () {
            _playbookModals.createScenario();
        };
        $scope.createPlay = function () {
            _playbookModals.createPlay();
        };
        $scope.alertDataRequired = function (dataType) {
            if ($scope.formations.isEmpty() && $scope.playbooks.hasElements()) {
                alert("Please create a base formation in order to begin creating " + dataType + ".");
            }
            else if ($scope.playbooks.isEmpty()) {
                alert("Please create a playbook in order to begin creating " + dataType + ".");
            }
        };
        $scope.deletePlay = function (play) {
            _playbookModals.deletePlay(play);
        };
        $scope.createFormation = function () {
            _playbookModals.createFormation();
        };
        $scope.deleteFormation = function (formation) {
            _playbookModals.deleteFormation(formation);
        };
        $scope.createAssignmentGroup = function () {
            // create default assignment group?
            //_playbookModals.createAssignmentGroup();
        };
        $scope.deleteAssignmentGroup = function (assignmentGroup) {
            _playbookModals.deleteAssignmentGroup(assignmentGroup);
        };
        $scope.getAssociationsCountForPlaybook = function (playbook) {
            var associations = _associations.getAssociated(playbook);
            return associations.count();
        };
        /**
         *
         * Item Drilldown
         *
         */
        $scope.toPlaybookDrilldown = function (playbookModel) {
            _playbook.toPlaybookDrilldown(playbookModel);
        };
    }]);
/// <reference path='./playbook-browser.mdl.ts' />
impakt.playbook.browser.service('_playbookBrowser', [function () {
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.contextmenus = angular.module('impakt.playbook.contextmenus', [
    'impakt.playbook.contextmenus.routeNode',
    'impakt.playbook.contextmenus.play'
])
    .config(function () {
    console.debug('impakt.playbook.contextmenus - config');
})
    .run(function () {
    console.debug('impakt.playbook.contextmenus - run');
});
/// <reference path='../playbook-contextmenus.mdl.ts' />
impakt.playbook.contextmenus.play =
    angular.module('impakt.playbook.contextmenus.play', [])
        .config(function () {
        console.debug('impakt.playbook.contextmenus.play - config');
    })
        .run(function () {
        console.debug('impakt.playbook.contextmenus.play - run');
    });
/// <reference path='./contextmenu-play.mdl.ts' />
impakt.playbook.contextmenus.play.controller('impakt.playbook.contextmenus.play.ctrl', [
    '$scope',
    function ($scope) {
    }]);
/// <reference path='../playbook-contextmenus.mdl.ts' />
impakt.playbook.contextmenus.player =
    angular.module('impakt.playbook.contextmenus.player', [])
        .config(function () {
        console.debug('impakt.playbook.contextmenus.player - config');
    })
        .run(function () {
        console.debug('impakt.playbook.contextmenus.player - run');
    });
/// <reference path='./contextmenu-player.mdl.ts' />
impakt.playbook.contextmenus.player.controller('impakt.playbook.contextmenus.player.ctrl', [
    '$scope',
    function ($scope) {
    }]);
/// <reference path='../playbook-contextmenus.mdl.ts' />
impakt.playbook.contextmenus.routeNode =
    angular.module('impakt.playbook.contextmenus.routeNode', [])
        .config(function () {
        console.debug('impakt.playbook.contextmenus.routeNode - config');
    })
        .run(function () {
        console.debug('impakt.playbook.contextmenus.routeNode - run');
    });
/// <reference path='./contextmenu-routeNode.mdl.ts' />
impakt.playbook.contextmenus.routeNode.controller('impakt.playbook.contextmenus.routeNode.ctrl', [
    '$scope',
    '_contextmenu',
    function ($scope, _contextmenu) {
        $scope.routeNode = _contextmenu.getData();
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.drilldown = angular.module('impakt.playbook.drilldown', [
    'impakt.playbook.drilldown.playbook'
]).config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.playbook.drilldown - config');
        $stateProvider.state('playbook.drilldown', {
            url: '/drilldown',
            templateUrl: 'modules/playbook/drilldown/playbook-drilldown.tpl.html',
            controller: 'playbook.drilldown.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.playbook.drilldown - run');
});
/// <reference path='./playbook-drilldown.mdl.ts' />
impakt.playbook.drilldown.controller('playbook.drilldown.ctrl', [
    '$scope',
    '_playbook',
    function ($scope, _playbook) {
        $scope.toBrowser = function () {
            _playbook.toBrowser();
        };
    }]);
/// <reference path='../playbook-drilldown.mdl.ts' />
impakt.playbook.drilldown.playbook = angular.module('impakt.playbook.drilldown.playbook', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.playbook.drilldown.playbook - config');
        $stateProvider.state('playbook.drilldown.playbook', {
            url: '/playbook',
            templateUrl: 'modules/playbook/drilldown/playbook/playbook-drilldown-playbook.tpl.html',
            controller: 'playbook.drilldown.playbook.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.playbook.drilldown.playbook - run');
});
/// <reference path='./playbook-drilldown-playbook.mdl.ts' />
impakt.playbook.drilldown.playbook.controller('playbook.drilldown.playbook.ctrl', [
    '$scope',
    '_associations',
    '_playbook',
    '_playbookModals',
    function ($scope, _associations, _playbook, _playbookModals) {
        $scope.playbook = _playbook.drilldown.playbook;
        $scope.plays;
        $scope.formations;
        $scope.scenarios;
        function init() {
            var associations = _associations.getAssociated($scope.playbook);
            if (Common.Utilities.isNotNullOrUndefined(associations)) {
                $scope.plays = associations.plays;
                $scope.formations = associations.formations;
                $scope.scenarios = associations.scenarios;
            }
        }
        $scope.delete = function () {
            _playbookModals.deletePlaybook($scope.playbook);
        };
        init();
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.editor = angular.module('impakt.playbook.editor', [
    'impakt.playbook.editor.tabs',
    'impakt.playbook.editor.tools',
    'impakt.playbook.editor.mode',
    'impakt.playbook.editor.canvas',
    'impakt.playbook.editor.details'
])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.playbook.editor - config');
        $stateProvider.state('playbook.editor', {
            url: '/editor',
            templateUrl: 'modules/playbook/editor/playbook-editor.tpl.html',
            controller: 'playbook.editor.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.playbook.editor - run');
});
/// <reference path='../playbook-editor.mdl.ts' />
impakt.playbook.editor.canvas =
    angular.module('impakt.playbook.editor.canvas', [])
        .config(function () {
        console.debug('impakt.playbook.editor.canvas - config');
    })
        .run(function () {
        console.debug('impakt.playbook.editor.canvas - run');
    });
/// <reference path='./playbook-editor-canvas.mdl.ts' />
impakt.playbook.editor.canvas.controller('playbook.editor.canvas.ctrl', [
    '$scope',
    '$timeout',
    '_playbookEditorCanvas',
    function ($scope, $timeout, _playbookEditorCanvas) {
        $scope.unitTypes = _playbookEditorCanvas.unitTypes;
        $scope.formations = _playbookEditorCanvas.formations;
        $scope.personnelCollection = _playbookEditorCanvas.personnelCollection;
        $scope.assignmentGroups = _playbookEditorCanvas.assignmentGroups;
        $scope.plays = _playbookEditorCanvas.plays;
        $scope.tab = _playbookEditorCanvas.getActiveTab();
        $scope.tabs = _playbookEditorCanvas.tabs;
        $scope.hasOpenTabs = _playbookEditorCanvas.hasTabs();
        $scope.canvas = _playbookEditorCanvas.canvas;
        $scope.editorModeClass = '';
        // check if there are any open tabs; if not, hide the canvas and
        // clear the canvas data.
        if (Common.Utilities.isNotNullOrUndefined($scope.tab)) {
            $scope.tab.onclose(function () {
                $scope.hasOpenTabs = _playbookEditorCanvas.hasTabs();
            });
            $scope.canvas.onready(function () {
                $scope.editorModeClass = $scope.getEditorTypeClass($scope.canvas.scenario.editorType);
                $scope.canvas.onModified(function () {
                    if (Common.Utilities.isNullOrUndefined($scope.canvas.scenario))
                        return;
                    $scope.editorModeClass = $scope.getEditorTypeClass($scope.canvas.scenario.editorType);
                    $timeout(function () {
                        console.log('timeout running');
                        $scope.$apply();
                    }, 1);
                });
            });
        }
        if (Common.Utilities.isNotNullOrUndefined($scope.tabs)) {
            $scope.tabs.onModified(function (tabs) {
                $scope.hasOpenTabs = tabs.hasElements();
            });
        }
        // _playbookEditorCanvas.onready(function() {
        // 	$scope.tab = _playbookEditorCanvas.activeTab;
        // });	
        $scope.formations.onModified(function () {
            // $scope.$apply();
        });
        /**
         * Toggle Editor mode
         */
        $scope.switchToPlayMode = function () {
            console.log('switch from formation mode to play mode', $scope.tab.scenario);
            $scope.tab.scenario.editorType = Playbook.Enums.EditorTypes.Play;
        };
        $scope.getEditorTypeClass = function (editorType) {
            return _playbookEditorCanvas.getEditorTypeClass(parseInt(editorType));
        };
        /**
         * Toggle Formation / Personnel / Assignments
         */
        $scope.applyFormation = function (formation) {
            console.log('apply formation to editor');
            _playbookEditorCanvas.applyPrimaryFormation(formation);
            $scope.formationDropdownVisible = false;
        };
        $scope.applyPersonnel = function (personnel) {
            _playbookEditorCanvas.applyPrimaryPersonnel(personnel);
            $scope.setDropdownVisible = false;
        };
        $scope.applyPlay = function (play) {
            _playbookEditorCanvas.applyPrimaryPlay(play);
        };
        $scope.applyAssignmentGroup = function (assignmentGroup) {
            _playbookEditorCanvas.applyPrimaryAssignmentGroup(assignmentGroup);
        };
        $scope.applyUnitType = function (unitType) {
            if (unitType.unitType == $scope.canvas.scenario.playPrimary.unitType)
                return;
            _playbookEditorCanvas.applyPrimaryUnitType(unitType.unitType);
            $scope.unitTypeDropdownVisible = false;
        };
        $scope.flipScenario = function () {
            _playbookEditorCanvas.flipScenario();
        };
        /**
         * Determine whether to show quick formation dropdown. Should only
         * be possible when in play- or formation-editing types.
         * @param {Playbook.Enums.EditorTypes} editorType Editor type enum to
         * determine which type of editor window we have open.
         */
        $scope.isFormationVisible = function (editorType) {
            return editorType == Playbook.Enums.EditorTypes.Formation ||
                editorType == Playbook.Enums.EditorTypes.Play ||
                editorType == Playbook.Enums.EditorTypes.Scenario;
        };
        /**
         * Personnel should be visible when setting assignments, since we need the
         * mapping information of a personnel group to determine how assignments are
         * paired with the players in the given formation.
         * @param {Playbook.Enums.EditorTypes} editorType [description]
         */
        $scope.isPersonnelVisible = function (editorType) {
            return editorType == Playbook.Enums.EditorTypes.Assignment ||
                editorType == Playbook.Enums.EditorTypes.Play ||
                editorType == Playbook.Enums.EditorTypes.Scenario;
        };
        $scope.isAssignmentGroupsVisible = function (editorType) {
            return editorType == Playbook.Enums.EditorTypes.Assignment ||
                editorType == Playbook.Enums.EditorTypes.Play ||
                editorType == Playbook.Enums.EditorTypes.Scenario;
        };
        $scope.isOpponentBarVisible = function (editorType) {
            return editorType == Playbook.Enums.EditorTypes.Scenario;
        };
        $scope.toBrowser = function () {
            _playbookEditorCanvas.toBrowser();
        };
    }]);
///<reference path='./playbook-editor-canvas.mdl.ts' />
// TODO - needed?
impakt.playbook.editor.canvas.directive('playbookEditorCanvas', ['$rootScope',
    '$compile',
    '$templateCache',
    '$timeout',
    '_contextmenu',
    '_playPreview',
    '_playbookEditorCanvas',
    '_scrollable',
    function ($rootScope, $compile, $templateCache, $timeout, _contextmenu, _playPreview, _playbookEditorCanvas, _scrollable) {
        console.debug('directive: impakt.playbook.editor.canvas - register');
        return {
            restrict: 'E',
            link: function ($scope, $element, attrs) {
                console.debug('directive: impakt.playbook.editor.canvas - link');
                $scope.canvas = _playbookEditorCanvas.getCanvas();
                // $timeout NOTE:
                // wrapping this step in a timeout due to a DOM rendering race.
                // The angular ng-show directive kicks in when activating/
                // deactivating the tabs, and the .col class (css-flex)
                // needs time itself to render to the appropriate size.
                // This timeout lets all of that finish before intializing
                // the canvas; the canvas requires an accurate $element height
                // value in order to get its proper dimensions.
                $timeout(function () {
                    if ($scope.canvas) {
                        $scope.canvas.onready(function () {
                            var scrollTop = $scope.canvas.paper.field.getLOSAbsolute()
                                - ($element.height() / 2);
                            $element.scrollTop(scrollTop);
                            if (Common.Utilities.isNotNullOrUndefined($scope.canvas.paper) &&
                                Common.Utilities.isNotNullOrUndefined($scope.canvas.paper.field) &&
                                Common.Utilities.isNotNullOrUndefined($scope.canvas.paper.field.los)) {
                                $scope.canvas.paper.field.los.onModified(function () {
                                    var scrollTop = $scope.canvas.paper.field.getLOSAbsolute()
                                        - ($element.height() / 2);
                                    $element.scrollTop(scrollTop);
                                });
                            }
                        });
                        $scope.canvas.initialize($element);
                        // Listen for routenode contextmenu
                        $scope.canvas.listener.listen(Playbook.Enums.Actions.RouteNodeContextmenu, function (data) {
                            _contextmenu.open(data);
                        });
                    }
                }, 0);
                $(document).on('keydown', function (e) {
                    //console.log(e.which);
                    if (e.which == 8) {
                        console.log('backspace pressed - playbook-editor-canvas.drv.ts');
                    }
                    if (e.which == 82) {
                        console.log('R pressed - playbook-editor-canvas.drv.ts');
                    }
                    if (e.which == 65) {
                        console.log('A pressed - playbook-editor-canvas.drv.ts');
                    }
                });
            }
        };
    }]);
/// <reference path='../../../../common/common.ts' />
/// <reference path='./playbook-editor-canvas.mdl.ts' />
impakt.playbook.editor.canvas.service('_playbookEditorCanvas', [
    '$rootScope',
    '$timeout',
    '_base',
    '_contextmenu',
    '_playPreview',
    '_playbook',
    '_playbookEditor',
    function ($rootScope, $timeout, _base, _contextmenu, _playPreview, _playbook, _playbookEditor) {
        console.debug('service: impakt.playbook.editor.canvas');
        var self = this;
        this.activeTab = _playbookEditor.activeTab;
        this.tabs = _playbookEditor.tabs;
        this.playbooks = impakt.context.Playbook.playbooks;
        this.formations = impakt.context.Playbook.formations;
        this.personnelCollection = impakt.context.Team.personnel;
        this.assignmentGroups = impakt.context.Playbook.assignmentGroups;
        this.plays = impakt.context.Playbook.plays;
        this.readyCallbacks = [function () { console.log('canvas ready'); }];
        this.canvas = _playbookEditor.canvas;
        this.unitTypes = impakt.context.Team.unitTypes;
        this.component = new Common.Base.Component('_playbookEditorCanvas', Common.Base.ComponentType.Service, []);
        function init() {
            _playbookEditor.component.loadDependency(self.component);
        }
        this.onready = function (callback) {
            this.readyCallbacks.push(callback);
            _playbookEditor.onready(function () {
                self.ready();
            });
        };
        this.ready = function () {
            for (var i = 0; i < this.readyCallbacks.length; i++) {
                this.readyCallbacks[i]();
            }
            this.readyCallbacks = [];
        };
        this.create = function (tab) {
            if (Common.Utilities.isNullOrUndefined(tab))
                throw new Error('playbook-editor-canvas.srv create(): tab is null or undefined');
            if (Common.Utilities.isNullOrUndefined(tab.scenario))
                throw new Error('playbook-editor-canvas.srv create(): tab.scenario is null or undefined');
            var canvas = new Playbook.Models.EditorCanvas(tab.scenario);
            canvas.tab = tab;
        };
        this.getActiveTab = function () {
            this.activeTab = _playbookEditor.activeTab;
            return this.activeTab;
        };
        this.hasTabs = function () {
            return _playbookEditor.hasTabs();
        };
        this.toBrowser = function () {
            _playbookEditor.toBrowser();
        };
        this.getCanvas = function () {
            return _playbookEditor.canvas;
        };
        /**
         * Applies the given formation to the field
         * @param {Common.Models.Formation} formation The Formation to apply
         */
        this.applyPrimaryFormation = function (formation) {
            if (canApplyData()) {
                _playbookEditor.canvas.paper.field.applyPrimaryFormation(formation);
            }
        };
        /**
         * Applies the given personnel data to the field
         * @param {Team.Models.Personnel} personnel The Personnel to apply
         */
        this.applyPrimaryPersonnel = function (personnel) {
            if (canApplyData()) {
                _playbookEditor.canvas.paper.field.applyPrimaryPersonnel(personnel);
            }
        };
        /**
         * Applies the given assignmentGroup data to the field
         * @param {Common.Models.AssignmentGroup} assignmentGroup The AssignmentGroup to apply
         */
        this.applyPrimaryAssignmentGroup = function (assignmentGroup) {
            if (canApplyData()) {
                _playbookEditor.canvas.paper.field.applyPrimaryAssignmentGroup(assignmentGroup);
            }
        };
        /**
         * Applies the given play data to the field
         * @param {Common.Models.Play} play The Play to apply
         */
        this.applyPrimaryPlay = function (playPrimary) {
            if (canApplyData()) {
                _playbookEditor.canvas.paper.field.applyPlayPrimary(playPrimary);
            }
        };
        /**
         * Applies the given unitType to the play
         * @param {Common.Models.Play} play The Play to apply
         */
        this.applyPrimaryUnitType = function (unitType) {
            if (canApplyData()) {
                _playbookEditor.canvas.paper.field.applyPrimaryUnitType(unitType);
            }
        };
        this.flipScenario = function () {
            _playbookEditor.flipScenario();
        };
        function canApplyData() {
            if (!_playbookEditor.canvas ||
                !_playbookEditor.canvas.paper ||
                !_playbookEditor.canvas.paper.field) {
                throw new Error('Cannot apply primary formation; canvas, paper, or field is null or undefined');
            }
            return true;
        }
        function getAbsolutePosition(element) {
            var $dom = $(element.graphics.raphael.node);
            console.log('$dom offsets: ', $dom.offset().left, $dom.offset().top, element.graphics.dimensions.width, element.graphics.dimensions.height);
            //let $playbookCanvas = $dom.closest('playbook-editor-canvas');
            return {
                left: $dom.offset().left,
                top: $dom.offset().top
            };
        }
        this.remove = function (tab) {
            // do something
        };
        this.scrollTo = function (x, y) {
            console.log(x, y);
            this.canvas.paper.scroll(x, y, true);
        };
        this.getEditorTypeClass = function (editorType) {
            return _playbookEditor.getEditorTypeClass(editorType);
        };
        /*****
        *
        *
        *	RECEIVE EXTERNAL COMMANDS
        *
        *
        ******/
        // receives command from playbook.editor to create a new canvas
        $rootScope.$on('playbook-editor-canvas.create', function (e, tab) {
            console.log('creating canvas...');
            self.create(tab);
        });
        $rootScope.$on('playbook-editor-canvas.zoomIn', function (e, data) {
            //self.active.canvas.paper.zoomIn();
        });
        $rootScope.$on('playbook-editor-canvas.zoomOut', function (e, data) {
            //self.active.canvas.paper.zoomOut();
        });
        // receives command from playbook.editor to close canvas
        $rootScope.$on('playbook-editor-canvas.close', function (e, tab) {
            console.log('closing canvas...');
            self.remove(tab);
        });
        // receives command from playbook.editor to activate canvas
        $rootScope.$on('playbook-editor-canvas.activate', function (e, tab) {
            console.log('activating canvas...');
            self.activate(tab);
        });
        // receives command from playbook.editor to add a player to canvas
        $rootScope.$on('playbook-editor-canvas.addPlayer', function (e, data) {
            //self.active.canvas.field.addPlayer({});
            console.info('add player');
        });
        // receives command from playbook.editor to zoom in canvas
        $rootScope.$on('playbook-editor-canvas.zoomIn', function (e, data) {
            console.info('zoom in');
        });
        // receives command from playbook.editor to zoom out canvas
        $rootScope.$on('playbook-editor-canvas.zoomOut', function (e, data) {
            console.info('zoom out');
        });
        init();
    }]);
/// <reference path='../playbook-editor.mdl.ts' />
impakt.playbook.editor.details = angular.module('impakt.playbook.editor.details', [])
    .config(function () {
    console.debug('impakt.playbook.editor.details - config');
})
    .run(function () {
    console.debug('impakt.playbook.editor.details - run');
});
/// <reference path='./playbook-editor-details.mdl.ts' />
impakt.playbook.editor.details.controller('playbook.editor.details.ctrl', [
    '$scope',
    '$timeout',
    '_playbookModals',
    '_playbookEditorDetails',
    function ($scope, $timeout, _playbookModals, _playbookEditorDetails) {
        $scope.canvas = _playbookEditorDetails.canvas;
        $scope.paper;
        $scope.field;
        $scope.grid;
        $scope.scenario;
        $scope.layers;
        $scope.selected;
        $scope.players;
        $scope.canvas.onready(function () {
            $scope.paper = $scope.canvas.paper;
            $scope.field = $scope.paper.field;
            $scope.grid = $scope.paper.grid;
            $scope.scenario = $scope.canvas.scenario;
            $scope.layers = $scope.field.layers;
            $scope.selected = $scope.field.selected;
            $scope.players = $scope.field.primaryPlayers;
            // update scope when changes to field occur
            $scope.field.onModified(function () {
                $timeout(function () {
                    $scope.$apply();
                }, 0);
            });
        });
        $scope.refreshPreview = function () {
        };
    }]);
/// <reference path='./playbook-editor-details.mdl.ts' />
impakt.playbook.editor.details.service('_playbookEditorDetails', [
    '_playbookEditor',
    function (_playbookEditor) {
        console.debug('service: impakt.playbook.browser');
        this.canvas = _playbookEditor.canvas;
        this.closeActiveTab = function () {
            _playbookEditor.closeTab(_playbookEditor.activeTab);
        };
    }]);
/// <reference path='../playbook-editor.mdl.ts' />
impakt.playbook.editor.mode = angular.module('impakt.playbook.editor.mode', [])
    .config(function () {
    console.debug('impakt.playbook.editor.mode - config');
})
    .run(function () {
    console.debug('impakt.playbook.editor.mode - run');
});
/// <reference path='./playbook-editor-mode.mdl.ts' />
impakt.playbook.editor.mode.controller('playbook.editor.mode.ctrl', [
    '$scope',
    '_playbookEditor',
    function ($scope, _playbookEditor) {
        $scope.canvas = _playbookEditor.canvas;
        $scope.canvas.onready(function () {
            $scope.cursorCoordinates = $scope.canvas.paper.field.cursorCoordinates;
            $scope.canvas.paper.field.onModified(function (field) {
                $scope.cursorCoordinates.x = field.cursorCoordinates.x;
                $scope.cursorCoordinates.y = field.cursorCoordinates.y;
                if (!$scope.$$phase)
                    $scope.$apply();
            });
        });
    }]);
/// <reference path='./playbook-editor.mdl.ts' />
impakt.playbook.editor.controller('playbook.editor.ctrl', [
    '$scope',
    '$stateParams',
    '_playbookEditor',
    function ($scope, $stateParams, _playbookEditor) {
        $scope.canvas = _playbookEditor.canvas;
        _playbookEditor.init();
        var templatePrefix = 'modules/playbook/editor/';
        $scope.templates = {
            tools: [
                templatePrefix,
                'tools/playbook-editor-tools.tpl.html'
            ].join(''),
            tabs: [
                templatePrefix,
                'tabs/playbook-editor-tabs.tpl.html'
            ].join(''),
            canvas: [
                templatePrefix,
                'canvas/playbook-editor-canvas.tpl.html'
            ].join(''),
            mode: [
                templatePrefix,
                'mode/playbook-editor-mode.tpl.html'
            ].join('')
        };
    }]);
/// <reference path='./playbook-editor.mdl.ts' />
impakt.playbook.editor.service('_playbookEditor', [
    '$rootScope',
    '$q',
    '_base',
    '_associations',
    '_playbook',
    '_playbookModals',
    function ($rootScope, $q, _base, _associations, _playbook, _playbookModals) {
        console.debug('service: impakt.playbook.editor');
        var self = this;
        this.component = new Common.Base.Component('_playbookEditor', Common.Base.ComponentType.Service, [
            '_playbookEditorTools',
            '_playbookEditorTabs',
            '_playbookEditorCanvas'
        ]);
        this.tabs = impakt.context.Playbook.editor.tabs;
        this.scenarios = impakt.context.Playbook.editor.scenarios;
        // sets a default tab - this should be overwritten as soon as it becomes available
        this.activeTab = null;
        this.canvas = null;
        this.toolMode = Playbook.Enums.ToolModes[Playbook.Enums.ToolModes.None];
        $rootScope.$on('playbook-editor.refresh', function (e, formationKey) {
            self.scenarios = impakt.context.Playbook.editor.scenarios;
            self.loadTabs();
        });
        this.readyCallback = function () {
            console.log('Playbook editor ready default callback');
        };
        var initialized = false;
        this.ready = function () {
            this.readyCallback();
        };
        this.init = function () {
            initialized = true;
            var activeScenario = null;
            if (self.tabs.isEmpty() || self.tabs.size() != self.scenarios.size()) {
                self.loadTabs();
            }
            // check for active tab and initialize the canvas with that tab's play
            self.tabs.forEach(function (tab, index) {
                if (tab.active) {
                    activeScenario = self.scenarios.filterFirst(function (scenario, j) {
                        return scenario.guid == tab.scenario.guid;
                    });
                }
            });
            if (activeScenario) {
                if (!self.canvas) {
                    self.canvas = new Playbook.Models.EditorCanvas(activeScenario);
                    self.editorType = activeScenario.editorType;
                }
            }
            if (!activeScenario) {
                // Throw an error at this point; we should always have some physical play to use
                // whether it's a new play or an existing play; we shouldn't arbitrarily initialize
                // the canvas with a blank play here
                throw new Error('_playbookEditor init(): Trying to create a new canvas but there are no active tabs / scenario data to start with.');
            }
            self.canvas.clearListeners();
            self.canvas.onready(function () {
                self.loadTabs();
                self.ready();
            });
            _base.loadComponent(self.component);
        };
        this.onready = function (callback) {
            this.readyCallback = callback;
        };
        this.getEditorType = function () {
            return this.editorType;
        };
        /**
         * Checks for open scenarios in the editor context, as well as the
         * corresponding tab; if the tab is active, grab the corresponding
         * scenario and pass it in to initialize the canvas.
         */
        this.loadTabs = function () {
            this.scenarios.forEach(function (scenario, index) {
                // loop over all scenarios currently 'open' in the editor context...
                // determine whether each scenario has a corresponding tab 
                var scenarioExists = false;
                self.tabs.forEach(function (tab, j) {
                    if (tab.scenario.guid == scenario.guid) {
                        scenarioExists = true;
                    }
                });
                if (!scenarioExists) {
                    var tab = new Common.Models.Tab(scenario);
                    // Hmm...
                    tab.active = index == 0;
                    self.addTab(tab);
                }
            });
        };
        this.addTab = function (tab) {
            // ignore if it is already open
            if (this.tabs.contains(tab.guid)) {
                this.activateTab(tab, true);
                return;
            }
            else {
                // add the new tab...
                this.tabs.add(tab);
                this.activateTab(tab, false);
            }
        };
        this.activateTab = function (tab) {
            this.inactivateOtherTabs(tab);
            // for redundancy to ensure tab is explicitly set to active
            tab.active = true;
            // create another pointer to always track the active tab
            this.activeTab = tab;
            if (this.canvas) {
                // pass new data to canvas
                this.canvas.updateScenario(this.activeTab.scenario, true);
            }
        };
        this.closeTab = function (tab) {
            this.tabs.close(tab);
            // remove play from editor context
            this.scenarios.remove(tab.scenario.guid);
            // get last tab
            if (this.tabs.hasElements()) {
                // activate the last tab
                this.activateTab(this.tabs.getLast());
            }
            else {
                // no remaining tabs - nullify active Tab
                this.activeTab = null;
                this.canvas.clear();
            }
            // tell tab to close (fire off close callbacks)
            tab.close();
        };
        this.inactivateOtherTabs = function (tab) {
            this.tabs.forEach(function (currentTab, index) {
                if (currentTab.guid != tab.guid)
                    currentTab.active = false;
            });
        };
        this.hasTabs = function () {
            return this.tabs.hasElements();
        };
        this.getEditorTypeClass = function (editorType) {
            return _playbook.getEditorTypeClass(editorType);
        };
        this.flipScenario = function () {
            if (Common.Utilities.isNotNullOrUndefined(this.canvas)) {
                this.canvas.paper.field.primaryPlayers.forEach(function (player, index) {
                    player.flip();
                });
                this.canvas.paper.field.opponentPlayers.forEach(function (player, index) {
                    player.flip();
                });
            }
        };
        /*
        *
        *	Tool -> Canvas bindings
        *
        */
        this.toggleMenu = function () {
            // N/A
        };
        this.addPlayer = function () {
            $rootScope.$broadcast('playbook-editor-canvas.addPlayer');
        };
        this.save = function () {
            // save the data for the active item
            var activeTab = this.activeTab;
            if (Common.Utilities.isNotNullOrUndefined(activeTab)) {
                var scenario = activeTab.scenario;
                switch (scenario.editorType) {
                    case Playbook.Enums.EditorTypes.Formation:
                        _playbookModals.saveFormation(scenario.playPrimary);
                        break;
                    case Playbook.Enums.EditorTypes.Play:
                        _playbookModals.savePlay(scenario.playPrimary);
                        break;
                    case Playbook.Enums.EditorTypes.Scenario:
                        _playbookModals.saveScenario(scenario);
                        break;
                }
            }
        };
        this.zoomIn = function () {
            $rootScope.$broadcast('playbook-editor-canvas.zoomIn');
        };
        this.zoomOut = function () {
            $rootScope.$broadcast('playbook-editor-canvas.zoomOut');
        };
        this.setCursor = function (cursor) {
            if (this.canvas && this.canvas.$container) {
                this.canvas.$container.css({ 'cursor': cursor });
            }
        };
        this.setToolMode = function (toolMode) {
            console.log('Change editor tool mode: ', toolMode, Playbook.Enums.ToolModes[toolMode]);
            if (this.canvas) {
                this.canvas.toolMode = toolMode;
                this.toolMode = Playbook.Enums.ToolModes[toolMode];
            }
        };
        this.toBrowser = function () {
            _playbook.toBrowser();
        };
        this.editScenario = function (scenario) {
            _playbook.editScenario(scenario);
            this.loadTabs();
        };
        this.editPlay = function (play) {
            _playbook.editPlay(play);
            this.loadTabs();
        };
        this.editFormation = function (formation) {
            _playbook.editFormation(formation);
            this.loadTabs();
        };
        /**
         * Receives broadcast command from other services;
         * loads all tabs according to any plays that have been
         * added to the editor context.
         */
        $rootScope.$on('playbook-editor.loadTabs', function (e, data) {
            self.loadTabs();
        });
    }]);
/// <reference path='../playbook-editor.mdl.ts' />
impakt.playbook.editor.tabs =
    angular.module('impakt.playbook.editor.tabs', [
        'impakt.playbook.editor.canvas'
    ])
        .config(function () {
        console.debug('impakt.playbook.editor.tabs - config');
    })
        .run(function () {
        console.debug('impakt.playbook.editor.tabs - run');
    });
/// <reference path='./playbook-editor-tabs.mdl.ts' />
/// <reference path='../../../../common/common.ts' />
impakt.playbook.editor.tabs.controller('playbook.editor.tabs.ctrl', [
    '$scope',
    '_base',
    '_playbookModals',
    '_playbookEditorTabs',
    function ($scope, _base, _playbookModals, _playbookEditorTabs) {
        this.component = new Common.Base.Component('playbook.editor.tabs.ctrl', Common.Base.ComponentType.Controller);
        function init(self) {
            _playbookEditorTabs.component.loadDependency(self.component);
        }
        $scope.tabs = _playbookEditorTabs.tabs;
        $scope.getEditorTypeClass = function (editorType) {
            return _playbookEditorTabs.getEditorTypeClass(parseInt(editorType));
        };
        $scope.new = function () {
            _playbookModals.openNewEditorTab();
        };
        $scope.close = function (tab) {
            var toClose = confirm('Are you sure you want to close?');
            if (toClose)
                _playbookEditorTabs.close(tab);
        };
        $scope.activate = function (tab) {
            _playbookEditorTabs.activate(tab, true);
        };
        $scope.toBrowser = function () {
            _playbookEditorTabs.toBrowser();
        };
        init(this);
    }]);
/// <reference path='../../playbook.ts' />
/// <reference path='./playbook-editor-tabs.mdl.ts' />
impakt.playbook.editor.tabs.service('_playbookEditorTabs', ['$rootScope',
    '_base',
    '_playbookEditor',
    function ($rootScope, _base, _playbookEditor) {
        console.debug('service: impakt.playbook.editor.tabs');
        var self = this;
        this.tabs = _playbookEditor.tabs;
        this.canvas = _playbookEditor.canvas;
        this.component = new Common.Base.Component('_playbookEditorTabs', Common.Base.ComponentType.Service, [
            'playbook.editor.tabs.ctrl'
        ]);
        function init() {
            _playbookEditor.component.loadDependency(self.component);
        }
        this.close = function (tab) {
            // remove the tab from the array			
            _playbookEditor.closeTab(tab);
        };
        this.activate = function (tab, activateCanvas) {
            if (!tab.active)
                _playbookEditor.activateTab(tab, true);
        };
        this.toBrowser = function () {
            _playbookEditor.toBrowser();
        };
        this.getEditorTypeClass = function (editorType) {
            return _playbookEditor.getEditorTypeClass(editorType);
        };
        this.editScenario = function (scenario) {
            _playbookEditor.editScenario(scenario);
        };
        this.editPlay = function (play) {
            _playbookEditor.editPlay(play);
        };
        this.editFormation = function (formation) {
            _playbookEditor.editFormation(formation);
        };
        init();
    }]);
/// <reference path='../playbook-editor.mdl.ts' />
impakt.playbook.editor.tools =
    angular.module('impakt.playbook.editor.tools', [])
        .config(function () {
        console.debug('impakt.playbook.editor.tools - config');
    })
        .run(function () {
        console.debug('impakt.playbook.editor.tools - run');
    });
/// <reference path='./playbook-editor-tools.mdl.ts' />
// Inherits from playbookEditorController
impakt.playbook.editor.tools.controller('playbook.editor.tools.ctrl', ['$scope', '$rootScope', '_playbookEditorTools',
    function ($scope, $rootScope, _playbookEditorTools) {
        console.debug('controller: playbook.editor.tools');
        this.component = new Common.Base.Component('playbook.editor.tools.ctrl', Common.Base.ComponentType.Controller);
        function init(self) {
            _playbookEditorTools.component.loadDependency(self.component);
        }
        $scope.tools = _playbookEditorTools.tools;
        $scope.expanded = false;
        $scope.toolClick = function (tool) {
            _playbookEditorTools.invoke(tool);
        };
        $rootScope.$on('playbook-editor-canvas.toggleMenu', function (e, data) {
            $scope.expanded = !$scope.expanded;
        });
        init(this);
    }]);
/// <reference path='../../playbook.ts' />
/// <reference path='./playbook-editor-tools.mdl.ts' />
/// <reference path='../playbook-editor.srv.ts' />
impakt.playbook.editor.tools.service('_playbookEditorTools', ['$rootScope', '_base', '_playbookEditor',
    function ($rootScope, _base, _playbookEditor) {
        console.debug('service: impakt.Playbook.Models.tools');
        this.component = new Common.Base.Component('_playbookEditorTools', Common.Base.ComponentType.Service, [
            'Playbook.Models.tools.ctrl'
        ]);
        function init(self) {
            _playbookEditor.component.loadDependency(self.component);
        }
        this.tools = [
            new Playbook.Models.Tool('Toggle menu', Playbook.Enums.ToolActions.ToggleMenu, 'menu-hamburger'),
            new Playbook.Models.Tool('Save', Playbook.Enums.ToolActions.Save, 'floppy-disk'),
            new Playbook.Models.Tool('Select', Playbook.Enums.ToolActions.Select, 'hand-up', 'Select', Common.Enums.CursorTypes.pointer, Playbook.Enums.ToolModes.Select, true),
            new Playbook.Models.Tool('Assignment', Playbook.Enums.ToolActions.Assignment, 'screenshot', '', Common.Enums.CursorTypes.crosshair, Playbook.Enums.ToolModes.Assignment),
        ];
        this.deselectAll = function () {
            for (var i = 0; i < this.tools.length; i++) {
                this.tools[i].selected = false;
            }
        };
        this.invoke = function (tool) {
            this.deselectAll();
            tool.selected = true;
            switch (tool.action) {
                case Playbook.Enums.ToolActions.Select:
                    break;
                case Playbook.Enums.ToolActions.ToggleMenu:
                    this.toggleMenu();
                    break;
                case Playbook.Enums.ToolActions.AddPlayer:
                    this.addPlayer();
                    break;
                case Playbook.Enums.ToolActions.Save:
                    this.save();
                    break;
                case Playbook.Enums.ToolActions.ZoomIn:
                    this.zoomIn();
                    break;
                case Playbook.Enums.ToolActions.ZoomOut:
                    this.zoomOut();
                    break;
                case Playbook.Enums.ToolActions.Assignment:
                    break;
            }
            this.setCursor(tool.cursor);
            this.setToolMode(tool.mode);
        };
        /*
        *	TOOL BINDINGS
        */
        this.toggleMenu = function () {
            $rootScope.$broadcast('playbook-editor-canvas.toggleMenu');
        };
        this.addPlayer = function () {
            _playbookEditor.addPlayer();
        };
        this.save = function () {
            _playbookEditor.save();
        };
        this.zoomIn = function () {
            _playbookEditor.zoomIn();
        };
        this.zoomOut = function () {
            _playbookEditor.zoomOut();
        };
        this.setCursor = function (cursor) {
            _playbookEditor.setCursor(cursor);
        };
        this.setToolMode = function (mode) {
            _playbookEditor.setToolMode(mode);
        };
        init(this);
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.layout = angular.module('impakt.playbook.layout', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.playbook.layout - config');
        $stateProvider.state('playbook.layout', {
            url: '/layout',
            views: {
                'sidebar': {},
                'main': {
                    templateUrl: 'modules/playbook/layout/playbook-layout.tpl.html'
                },
                'details': {}
            }
        });
    }])
    .run(function () {
    console.debug('impakt.playbook.layout - run');
});
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.modals = angular.module('impakt.playbook.modals', [])
    .config(function () {
    console.debug('impakt.playbook.modals - config');
})
    .run(function () {
    console.debug('impakt.playbook.modals - run');
});
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.createFormation.ctrl', ['$scope',
    '$uibModalInstance',
    '_associations',
    '_playbook',
    function ($scope, $uibModalInstance, _associations, _playbook) {
        $scope.unitTypeCollection = impakt.context.Team.unitTypes;
        $scope.selectedUnitType = $scope.unitTypeCollection.getByUnitType(Team.Enums.UnitTypes.Offense).toJson();
        $scope.playbooks = impakt.context.Playbook.playbooks;
        $scope.play = new Common.Models.PlayPrimary($scope.selectedUnitType.unitType);
        $scope.play.formation = new Common.Models.Formation($scope.selectedUnitType.unitType);
        $scope.formations = impakt.context.Playbook.formations;
        $scope.selectedPlaybook = $scope.playbooks.first();
        /**
         * Check to ensure there are formations to select as a base formation;
         * Add a new empty formation if there are no others to select from
         */
        $scope.formations.add($scope.play.formation);
        /**
         * If there are no other formations, the selected base formation
         * will be the current, new formation
         */
        $scope.selectedBaseFormation = $scope.play.formation;
        impakt.context.Playbook.creation.plays.add($scope.play);
        /**
         * If there is a selected playbook available, add an association to
         * the new formation to that playbook.
         */
        if ($scope.selectedPlaybook) {
        }
        $scope.selectPlaybook = function (playbook) {
            // update the new formation associated playbook so that it only has 1 playbook
            // association, max, when creating it.
            //$scope.formation.associated.playbooks.only(playbook.guid);
            // Remove the formation from the currently selected playbook
            //$scope.selectedPlaybook.associated.formations.remove($scope.formation.guid);
            // Add the formation to the newly selected playbook
            $scope.selectedPlaybook = playbook;
        };
        $scope.selectBaseFormation = function (formation) {
            if ($scope.selectedBaseFormation != '' &&
                Common.Utilities.isNotNullOrUndefined($scope.selectedBaseFormation)) {
                $scope.play.formation.setPlacements($scope.selectedBaseFormation.placements);
            }
        };
        $scope.selectUnitType = function () {
            $scope.play.setUnitType($scope.selectedUnitType.unitType);
        };
        $scope.ok = function () {
            $scope.play.formation.parentRK = 1; // TODO @theBull - deprecate parentRK
            _playbook.createFormation($scope.play.formation)
                .then(function (createdFormation) {
                _associations.createAssociation(createdFormation, $scope.selectedPlaybook);
                removeFormationFromCreationContext();
                $uibModalInstance.close(createdFormation);
            }, function (err) {
                removeFormationFromCreationContext();
                removeFormationFromCollectionContext();
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            removeFormationFromCreationContext();
            removeFormationFromCollectionContext();
            $uibModalInstance.dismiss();
        };
        function removeFormationFromCreationContext() {
            // Remove the formation from the creation context
            // after creating the new formation or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.play.formation)) {
                impakt.context.Playbook.creation.formations.remove($scope.play.formation.guid);
            }
        }
        function removeFormationFromCollectionContext() {
            // Removes the formation from the formation collection context;
            // call this if you cancel / dismiss the dialog without invoking
            // the createFormation request, since the formation is temporarily
            // added to the formation collection in the situation where
            // there are 0 formations in the user's collection.
            if (Common.Utilities.isNotNullOrUndefined($scope.play.formation)) {
                $scope.formations.remove($scope.play.formation.guid);
            }
        }
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.createPlay.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_playbook',
    function ($scope, $uibModalInstance, _associations, _playbook) {
        $scope.unitTypeCollection = impakt.context.Team.unitTypes;
        $scope.selectedUnitType =
            $scope.unitTypeCollection.getByUnitType(Team.Enums.UnitTypes.Offense).toJson();
        $scope.newPlay = new Common.Models.PlayPrimary($scope.selectedUnitType.unitType);
        $scope.playbooks = impakt.context.Playbook.playbooks;
        $scope.formations = impakt.context.Playbook.formations;
        $scope.assignmentGroups = impakt.context.Playbook.assignmentGroups;
        $scope.selectedPlaybook = $scope.playbooks.first();
        $scope.selectedFormation = $scope.formations.first();
        $scope.selectedAssignmentGroup = null;
        $scope.personnelCollection = impakt.context.Team.personnel;
        $scope.selectedPersonnel = $scope.personnelCollection.first();
        // Intialize new Play with data
        $scope.newPlay.setFormation($scope.selectedFormation);
        $scope.newPlay.setAssignmentGroup($scope.selectedAssignmentGroup);
        $scope.newPlay.setPersonnel($scope.selectedPersonnel);
        // Add the new play onto the creation context, to access from
        // other parts of the application
        impakt.context.Playbook.creation.plays.add($scope.newPlay);
        $scope.selectUnitType = function () {
            $scope.newPlay.unitType = $scope.selectedUnitType.unitType;
        };
        $scope.selectPlaybook = function (playbook) {
            $scope.newPlay.setPlaybook($scope.playbooks.get(playbook.guid));
        };
        $scope.selectFormation = function (formation) {
            $scope.newPlay.setFormation($scope.formations.get(formation.guid));
        };
        $scope.selectAssignmentGroup = function (assignmentGroup) {
            if (Common.Utilities.isNotNullOrUndefined(assignmentGroup)) {
                $scope.newPlay.setAssignmentGroup($scope.assignmentGroups.get(assignmentGroup.guid));
            }
            else {
                $scope.newPlay.setAssignmentGroup(null);
            }
        };
        $scope.selectPersonnel = function (personnel) {
            $scope.newPlay.setPersonnel($scope.personnelCollection.get(personnel.guid));
            $scope.selectedUnitType = $scope.unitTypeCollection.getByUnitType(personnel.unitType);
            $scope.selectUnitType($scope.selectedUnitType);
        };
        $scope.ok = function () {
            _playbook.createPlay($scope.newPlay)
                .then(function (createdPlay) {
                _associations.createAssociations(createdPlay, [
                    $scope.selectedPlaybook,
                    $scope.selectedFormation,
                    $scope.selectedPersonnel,
                    $scope.selectedAssignmentGroup
                ]);
                removePlayFromCreationContext();
                $uibModalInstance.close(createdPlay);
            }, function (err) {
                removePlayFromCreationContext();
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            removePlayFromCreationContext();
            $uibModalInstance.dismiss();
        };
        // Navigates to the team module
        $scope.toTeam = function () {
            var response = confirm('You are about to navigate to the Team module. Your play will not be created. Continue?');
            if (response) {
                $scope.cancel();
                _playbook.toTeam();
            }
        };
        function removePlayFromCreationContext() {
            // Remove the play from the creation context
            // after creating the new play or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.newPlay))
                impakt.context.Playbook.creation.plays.remove($scope.newPlay.guid);
        }
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.createPlaybookDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_playbook',
    'playbook',
    function ($scope, $uibModalInstance, _playbook, playbook) {
        $scope.playbook = playbook;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.createPlaybook.ctrl', [
    '$scope', '$uibModalInstance', '_playbook',
    function ($scope, $uibModalInstance, _playbook) {
        $scope.unitTypeCollection = impakt.context.Team.unitTypes;
        $scope.selectedUnitType = $scope.unitTypeCollection.getByUnitType(Team.Enums.UnitTypes.Offense);
        $scope.newPlaybookModel = new Common.Models.PlaybookModel($scope.selectedUnitType);
        $scope.ok = function () {
            $scope.newPlaybookModel.unitType = $scope.selectedUnitType.unitType;
            _playbook.createPlaybook($scope.newPlaybookModel)
                .then(function (createdPlaybook) {
                $uibModalInstance.close(createdPlaybook);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.createScenario.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_playbook',
    function ($scope, $uibModalInstance, _associations, _playbook) {
        $scope.newScenario = new Common.Models.Scenario();
        $scope.playbooks = impakt.context.Playbook.playbooks;
        $scope.plays = impakt.context.Playbook.plays;
        $scope.selectedPlaybook = $scope.playbooks.first();
        $scope.selectedPrimaryPlay = null;
        $scope.selectedOpponentPlay = null;
        // Intialize new Scenario with data
        // TODO @theBull
        // Add the new scenario onto the creation context, to access from
        // other parts of the application
        impakt.context.Playbook.creation.scenarios.add($scope.newScenario);
        $scope.selectPlaybook = function (playbook) {
            $scope.newPlay.setPlaybook($scope.playbooks.get(playbook.guid));
        };
        $scope.selectPrimaryPlay = function (play) {
            _playbook.setPlayAssociations($scope.selectedPrimaryPlay);
            $scope.newScenario.setPlayPrimary($scope.selectedPrimaryPlay);
        };
        $scope.selectOpponentPlay = function (play) {
            _playbook.setPlayAssociations($scope.selectedOpponentPlay);
            $scope.newScenario.setPlayOpponent($scope.selectedOpponentPlay);
        };
        $scope.ok = function () {
            _playbook.createScenario($scope.newScenario)
                .then(function (createdScenario) {
                _associations.createAssociations(createdScenario, [
                    $scope.selectedPlaybook,
                    $scope.selectedPrimaryPlay,
                    $scope.selectedOpponentPlay
                ]);
                removeScenarioFromCreationContext();
                $uibModalInstance.close(createdScenario);
            }, function (err) {
                removeScenarioFromCreationContext();
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            removeScenarioFromCreationContext();
            $uibModalInstance.dismiss();
        };
        function removeScenarioFromCreationContext() {
            // Remove the scenario from the creation context
            // after creating the new scenario or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.newScenario))
                impakt.context.Playbook.creation.scenarios.remove($scope.newScenario.guid);
        }
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.deleteAssignmentGroup.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_playbook',
    'assignmentGroup',
    function ($scope, $uibModalInstance, _associations, _playbook, assignmentGroup) {
        $scope.assignmentGroup = assignmentGroup;
        $scope.ok = function () {
            _playbook.deleteAssignmentGroup($scope.assignmentGroup)
                .then(function (results) {
                _associations.deleteAssociations($scope.assignmentGroup.associationKey);
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.deleteFormation.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_playbook',
    'formation',
    function ($scope, $uibModalInstance, _associations, _playbook, formation) {
        $scope.formation = formation;
        $scope.ok = function () {
            _playbook.deleteFormation($scope.formation)
                .then(function (results) {
                _associations.deleteAssociations($scope.formation.associationKey);
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.deletePlay.ctrl', [
    '$scope', '$uibModalInstance', '_playbook', 'play',
    function ($scope, $uibModalInstance, _playbook, play) {
        $scope.play = play;
        $scope.ok = function () {
            _playbook.deletePlay($scope.play)
                .then(function (results) {
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.deletePlaybook.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_playbook',
    'playbook',
    function ($scope, $uibModalInstance, _playbook, playbook) {
        $scope.playbook = playbook;
        $scope.ok = function () {
            _playbook.deletePlaybook($scope.playbook)
                .then(function (results) {
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.deleteScenario.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_playbook',
    'scenario',
    function ($scope, $uibModalInstance, _playbook, scenario) {
        $scope.scenario = scenario;
        $scope.ok = function () {
            _playbook.deleteScenario($scope.scenario)
                .then(function (results) {
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.newEditor.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_playbookEditorTabs',
    'data',
    function ($scope, $uibModalInstance, _playbookEditorTabs, data) {
        $scope.scenarios = impakt.context.Playbook.scenarios;
        $scope.plays = impakt.context.Playbook.plays;
        $scope.formations = impakt.context.Playbook.formations;
        $scope.selectedScenario = $scope.scenarios.first();
        $scope.selectedPlay = $scope.plays.first();
        $scope.selectedFormation = $scope.formations.first();
        $scope.editScenarioSelected = false;
        $scope.editPlaySelected = false;
        $scope.editFormationSelected = false;
        $scope.selectScenario = function () { };
        $scope.selectPlay = function () { };
        $scope.selectFormation = function () { };
        $scope.editScenario = function () {
            $scope.editScenarioSelected = true;
            $scope.editPlaySelected = false;
            $scope.editFormationSelected = false;
            $scope.selectedPlay = null;
            $scope.selectedFormation = null;
        };
        $scope.editPlay = function () {
            $scope.editScenarioSelected = false;
            $scope.editPlaySelected = true;
            $scope.editFormationSelected = false;
            $scope.selectedScenario = null;
            $scope.selectedFormation = null;
        };
        $scope.editFormation = function () {
            $scope.editScenarioSelected = false;
            $scope.editPlaySelected = false;
            $scope.editFormationSelected = true;
            $scope.selectedScenario = null;
            $scope.selectedPlay = null;
        };
        $scope.ok = function () {
            if ($scope.selectedScenario)
                _playbookEditorTabs.editScenario($scope.selectedScenario);
            if ($scope.selectedPlay)
                _playbookEditorTabs.editPlay($scope.selectedPlay);
            if ($scope.selectedFormation)
                _playbookEditorTabs.editFormation($scope.selectedFormation);
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='./playbook-modals.mdl.ts' />
impakt.playbook.modals.service('_playbookModals', [
    '$q',
    '__modals',
    function ($q, __modals) {
        /**
         *
         * PLAYBOOK
         *
         */
        this.createPlaybook = function () {
            var d = $q.defer();
            console.log('create playbook');
            var modalInstance = __modals.open('', 'modules/playbook/modals/create-playbook/create-playbook.tpl.html', 'playbook.modals.createPlaybook.ctrl', {});
            modalInstance.result.then(function (createdPlaybook) {
                console.log(createdPlaybook);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createPlaybookDuplicate = function (playbookModel) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/playbook/modals/create-playbook-duplicate-error/create-playbook-duplicate-error.tpl.html', 'playbook.modals.createPlaybookDuplicateError.ctrl', {
                playbook: function () {
                    return playbookModel;
                }
            });
            modalInstance.result.then(function (createdPlaybook) {
                console.log(createdPlaybook);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deletePlaybook = function (playbook) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/playbook/modals/delete-playbook/delete-playbook.tpl.html', 'playbook.modals.deletePlaybook.ctrl', {
                playbook: function () {
                    return playbook;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * SCENARIO
         *
         */
        this.createScenario = function () {
            var d = $q.defer();
            console.log('create scenario');
            var modalInstance = __modals.open('lg', 'modules/playbook/modals/create-scenario/create-scenario.tpl.html', 'playbook.modals.createScenario.ctrl', {});
            modalInstance.result.then(function (createdScenario) {
                console.log(createdScenario);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveScenario = function (scenario) {
            var d = $q.defer();
            var modalInstance = __modals.open('lg', 'modules/playbook/modals/save-scenario/save-scenario.tpl.html', 'playbook.modals.saveScenario.ctrl', {
                scenario: function () {
                    return scenario;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteScenario = function (scenario) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/playbook/modals/delete-scenario/delete-scenario.tpl.html', 'playbook.modals.deleteScenario.ctrl', {
                scenario: function () {
                    return scenario;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * PLAY
         *
         */
        this.createPlay = function () {
            var d = $q.defer();
            console.log('create play');
            var modalInstance = __modals.open('lg', 'modules/playbook/modals/create-play/create-play.tpl.html', 'playbook.modals.createPlay.ctrl', {});
            modalInstance.result.then(function (createdPlay) {
                console.log(createdPlay);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.savePlay = function (play) {
            var d = $q.defer();
            var modalInstance = __modals.open('lg', 'modules/playbook/modals/save-play/save-play.tpl.html', 'playbook.modals.savePlay.ctrl', {
                play: function () {
                    return play;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deletePlay = function (play) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/playbook/modals/delete-play/delete-play.tpl.html', 'playbook.modals.deletePlay.ctrl', {
                play: function () {
                    return play;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * FORMATION
         *
         */
        this.createFormation = function () {
            var d = $q.defer();
            var modalInstance = __modals.open('lg', 'modules/playbook/modals/create-formation/create-formation.tpl.html', 'playbook.modals.createFormation.ctrl', {});
            modalInstance.result.then(function (createdFormation) {
                d.resolve();
            }, function (results) {
                d.reject();
            });
            return d.promise;
        };
        this.saveFormation = function (play) {
            var d = $q.defer();
            var modalInstance = __modals.open('lg', 'modules/playbook/modals/save-formation/save-formation.tpl.html', 'playbook.modals.saveFormation.ctrl', {
                play: function () {
                    return play;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteFormation = function (formation) {
            var d = $q.defer();
            console.log('delete formation');
            var modalInstance = __modals.open('', 'modules/playbook/modals/delete-formation/delete-formation.tpl.html', 'playbook.modals.deleteFormation.ctrl', {
                formation: function () {
                    return formation;
                }
            });
            modalInstance.result.then(function (results) {
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteAssignmentGroup = function (assignmentGroup) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/playbook/modals/delete-assignmentGroup/delete-assignmentGroup.tpl.html', 'playbook.modals.deleteAssignmentGroup.ctrl', {
                assignmentGroup: function () {
                    return assignmentGroup;
                }
            });
            modalInstance.result.then(function (results) {
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.openNewEditorTab = function () {
            var d = $q.defer();
            console.log('new editor tab');
            var modalInstance = __modals.open('', 'modules/playbook/modals/new-editor/new-editor.tpl.html', 'playbook.modals.newEditor.ctrl', {
                data: function () {
                    return 1;
                }
            });
            modalInstance.result.then(function (data) {
                console.log(data);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.saveFormation.ctrl', ['$scope',
    '$uibModalInstance',
    '_playbook',
    'play',
    function ($scope, $uibModalInstance, _playbook, play) {
        $scope.play = play.copy();
        $scope.playbooks = impakt.context.Playbook.playbooks;
        $scope.formation = play.formation.copy();
        $scope.play.formation = $scope.formation;
        $scope.copyFormation = false;
        $scope.associatedPlaybook;
        var originalFormationKey = $scope.formation.key;
        var originalFormationName = $scope.formation.name;
        var originalFormationGuid = $scope.formation.guid;
        function init() {
            // look for first associated playbook in formation
            var associatedPlaybook = false;
        }
        $scope.copyFormationChange = function () {
            $scope.formation.key = $scope.copyFormation ? -1 : originalFormationKey;
            $scope.formation.name = $scope.copyFormation ?
                $scope.formation.name + ' (copy)' :
                originalFormationName;
            $scope.formation.guid = $scope.copyFormation ?
                Common.Utilities.guid() :
                originalFormationGuid;
        };
        $scope.ok = function () {
            var options = {
                formation: {
                    action: Common.API.Actions.Overwrite // overwrite if modified
                }
            };
            if (Common.Utilities.isNullOrUndefined($scope.formation.key)) {
                options.formation.action = Common.API.Actions.Create;
            }
            if ($scope.copyFormation) {
                options.formation.action = Common.API.Actions.Copy;
            }
            _playbook.saveFormation($scope.formation, options)
                .then(function (savedFormation) {
                if ($scope.copyFormation) {
                    var contextFormation = impakt.context.Playbook.formations.get(savedFormation.guid);
                    if (contextFormation) {
                        // add new copied formation as new tab in editor
                        _playbook.editFormation(contextFormation);
                    }
                }
                console.log(savedFormation);
                $uibModalInstance.close(savedFormation);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $scope.formation.key = originalFormationKey;
            $scope.formation.name = originalFormationName;
            $uibModalInstance.dismiss();
        };
        init();
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.savePlay.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_playbook',
    'play',
    function ($scope, $uibModalInstance, _playbook, play) {
        $scope.play = play.copy();
        $scope.copyPlay = false;
        $scope.copyFormation = false;
        $scope.copyPersonnel = false;
        $scope.copyAssignmentGroup = false;
        // retain the orginal keys for toggling copy state
        var originalPlayKey = $scope.play.key;
        var originalFormationKey = $scope.play.formation.key;
        var originalAssignmentGroupKey = $scope.play.assignmentGroup.key;
        $scope.copyPlayChange = function () {
            $scope.play.key =
                $scope.copyPlay ? -1 :
                    originalPlayKey;
        };
        $scope.copyFormationChange = function () {
            $scope.play.formation.key =
                $scope.copyFormation ? -1 :
                    originalFormationKey;
        };
        $scope.copyAssignmentGroupChange = function () {
            $scope.play.assignmentGroup.key =
                $scope.copyAssignmentGroup ? -1 :
                    originalAssignmentGroupKey;
        };
        $scope.ok = function () {
            var play = $scope.play;
            // determine whether there are changes to the entity; if so,
            // set action to overwrite, otherwise set action to nothing
            // track options for how to send the data to the server
            // TO-DO: create a better model for this
            var options = {
                play: {
                    action: Common.API.Actions.Overwrite // keeping it simple here - always overwrite
                },
                formation: {
                    action: Common.API.Actions.Overwrite // keeping it simple here - always overwrite
                },
                assignmentGroup: {
                    action: play.assignmentGroup.assignments.hasElements() ?
                        (play.assignmentGroup.key == -1 ?
                            Common.API.Actions.Create : Common.API.Actions.Overwrite) :
                        Common.API.Actions.Nothing // don't do anything if there are no assignments
                }
            };
            // If any of the following entities (play, formation, assignmentGroup)
            // exist on the play and their corresponding copy boolean
            // (copyPlay, copyFormation, copyPersonnel, copyAssignmentGroup) is set to true,
            // a new corresponding entity (Play, Formation, AssigmentGroup)
            // will be created and the new entity will have its values copied 
            // from the existing entity.
            // this new copied entity gets sent to server-side for creation.
            if ($scope.play && $scope.copyPlay) {
                originalPlayKey = $scope.play.key;
                $scope.play.key = -1;
                options.play.action = Common.API.Actions.Copy;
                play = $scope.play;
            }
            if ($scope.play.formation && $scope.copyFormation) {
                originalFormationKey = $scope.play.formation.key;
                $scope.play.formation.key = -1;
                options.formation.action = Common.API.Actions.Copy;
                play.formation = $scope.formation;
            }
            if ($scope.play.assignmentGroup && $scope.copyAssignmentGroup) {
                originalAssignmentGroupKey = $scope.play.assignmentGroup.key;
                $scope.play.assignmentGroup.key = -1;
                options.assignmentGroup.action = Common.API.Actions.Copy;
                play.assignmentGroup = $scope.assignmentGroup;
            }
            _playbook.savePlay(play, options)
                .then(function (savedPlay) {
                $uibModalInstance.close(savedPlay);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook-modals.mdl.ts' />
impakt.playbook.modals.controller('playbook.modals.saveScenario.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_playbook',
    'scenario',
    function ($scope, $uibModalInstance, _playbook, scenario) {
        $scope.scenario = scenario.copy();
        $scope.ok = function () {
            // _playbook.saveScenario(scenario)
            // .then(function(savedScenario) {
            // 	$uibModalInstance.close(savedScenario);
            // }, function(err) {
            // 	console.error(err);
            // 	$uibModalInstance.close(err);
            // });
            $uibModalInstance.close(null);
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.nav = angular.module('impakt.playbook.nav', [])
    .config(function () {
    console.debug('impakt.playbook.nav - config');
})
    .run(function () {
    console.debug('impakt.playbook.nav - run');
});
/// <reference path='./playbook-nav.mdl.ts' />
impakt.playbook.nav.controller('playbook.nav.ctrl', ['$scope', '$location', '_playbook', '_playbookNav',
    function ($scope, $location, _playbook, _playbookNav) {
    }]);
/// <reference path='../../nav/nav.fct.ts' />
/// <reference path='./playbook-nav.mdl.ts' />
impakt.playbook.nav.service('_playbookNav', ['__nav', '_playbook', function (__nav, _playbook) {
        console.log('_playbookNav (component service)');
    }]);
/// <reference path='./playbook.mdl.ts' />
/**
 * Playbook constants defined here
 */
impakt.playbook.constant('PLAYBOOK', {
    //GET_PLAYBOOKS: 'data/playbook.json',
    ENDPOINT: '/playbook',
    // Playbooks
    CREATE_PLAYBOOK: '/createPlaybook',
    GET_PLAYBOOKS: '/getPlaybooks',
    GET_PLAYBOOK: '/getPlaybook',
    DELETE_PLAYBOOK: '/deletePlaybook',
    // Formations
    CREATE_FORMATION: '/createFormation',
    GET_FORMATIONS: '/getFormations',
    GET_FORMATION: '/getFormation',
    DELETE_FORMATION: '/deleteFormation',
    UPDATE_FORMATION: '/updateFormation',
    // Assignments
    CREATE_ASSIGNMENTGROUP: '/createAssignmentGroup',
    GET_ASSIGNMENTGROUPS: '/getAssignmentGroups',
    UPDATE_ASSIGNMENTGROUP: '/updateAssignmentGroup',
    DELETE_ASSIGNMENTGROUP: '/deleteAssignmentGroup',
    // Plays
    CREATE_PLAY: '/createPlay',
    UPDATE_PLAY: '/updatePlay',
    GET_PLAY: '/getPlay',
    GET_PLAYS: '/getPlays',
    DELETE_PLAY: '/deletePlay',
    // Scenarios
    CREATE_SCENARIO: '/createScenario',
    UPDATE_SCENARIO: '/updateScenario',
    GET_SCENARIO: '/getScenario',
    GET_SCENARIOS: '/getScenarios',
    DELETE_SCENARIO: '/deleteScenario'
});
/// <reference path='./playbook.mdl.ts' />
impakt.playbook.controller('playbook.ctrl', ['$scope', '$state', '$stateParams', '_playbook',
    function ($scope, $state, $stateParams, _playbook) {
        // load up the browser by default
        $state.go('playbook.browser');
    }]);
/// <reference path='./models/models.ts' />
/// <reference path='./playbook.ts' />
// Playbook service
impakt.playbook.service('_playbook', [
    'PLAYBOOK',
    '$rootScope',
    '$q',
    '$state',
    '__api',
    '__localStorage',
    '__notifications',
    '_associations',
    '_playbookModals',
    function (PLAYBOOK, $rootScope, $q, $state, __api, __localStorage, __notifications, _associations, _playbookModals) {
        var self = this;
        this.drilldown = {
            playbook: null
        };
        // TODO @theBull - ensure the 'current user' is being addressed
        // TODO @theBull - add notification handling
        /**
         * Retrieves all playbooks for the current user
         */
        this.getPlaybooks = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting playbooks...');
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_PLAYBOOKS))
                .then(function (response) {
                var collection = new Common.Models.PlaybookModelCollection(Team.Enums.UnitTypes.Mixed);
                if (response && response.data && response.data.results) {
                    var playbookResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < playbookResults.length; i++) {
                        var playbookResult = playbookResults[i];
                        if (playbookResult && playbookResult.data && playbookResult.data.model) {
                            var playbookModel = new Common.Models.PlaybookModel(Team.Enums.UnitTypes.Other);
                            playbookResult.data.model.key = playbookResult.key;
                            playbookModel.fromJson(playbookResult.data.model);
                            collection.add(playbookModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Playbooks successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Playbooks');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single playbook with the given key
         * @param {number} key The key of the playbook to retrieve
         */
        this.getPlaybook = function (key) {
            var d = $q.defer();
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_PLAYBOOK, '/' + key))
                .then(function (response) {
                var playbook = Common.Utilities.parseData(response.data.results);
                d.resolve(playbook);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a playbook model to the server for storage
         * @param {Common.Models.PlaybookModel} playbookModel The model to be created/saved
         */
        this.createPlaybook = function (newPlaybookModel) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newPlaybookModel)) {
                var nameExists = impakt.context.Playbook.playbooks.hasElementWhich(function (playbookModel, index) {
                    return playbookModel.name == newPlaybookModel.name;
                });
                if (nameExists) {
                    var notification_5 = __notifications.warning('Failed to create playbook. Playbook "', newPlaybookModel.name, '" already exists.');
                    _playbookModals.createPlaybookDuplicate(newPlaybookModel);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newPlaybookModel.key = -1;
            var playbookModelJson = newPlaybookModel.toJson();
            var notification = __notifications.pending('Creating playbook "', newPlaybookModel.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.CREATE_PLAYBOOK), {
                version: 1,
                name: newPlaybookModel.name,
                data: {
                    version: 1,
                    model: playbookModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var playbookModel = new Common.Models.PlaybookModel(newPlaybookModel.unitType);
                if (results && results.data && results.data.model) {
                    results.data.model.key = results.key;
                    playbookModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.Playbook.playbooks.add(playbookModel);
                }
                else {
                    throw new Error('CreatePlaybook did not return a valid playbook model');
                }
                notification.success('Successfully created playbook "', playbookModel.name, '"');
                $rootScope.$broadcast('create-entity', playbookModel);
                d.resolve(playbookModel);
            }, function (error) {
                notification.error('Failed to create playbook "', newPlaybookModel.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given playbook for the current user
         * @param {Common.Models.PlaybookModel} playbook The playbook to be deleted
         */
        this.deletePlaybook = function (playbook) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting playbook "', playbook.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.DELETE_PLAYBOOK), { key: playbook.key }).then(function (response) {
                // update the context
                impakt.context.Playbook.playbooks.remove(playbook.guid);
                notification.success('Deleted playbook "', playbook.name, '"');
                d.resolve(playbook);
            }, function (error) {
                notification.error('Failed to delete playbook "', playbook.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Creates the given formation for the current user
         * @param {Common.Models.Formation} newFormation The formation to be created
         */
        this.createFormation = function (newFormation) {
            var d = $q.defer();
            if (newFormation.key > 0) {
                throw new Error('The formation you are trying to create already exists (key > 0) key: '
                    + newFormation.key);
            }
            var notification = __notifications.pending('Creating formation "', newFormation.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.CREATE_FORMATION), {
                version: 1,
                name: newFormation.name,
                ownerRK: 1,
                parentRK: 1,
                data: {
                    version: 1,
                    name: newFormation.name,
                    ownerRK: 1,
                    parentRK: 1,
                    formation: newFormation.toJson()
                }
            })
                .then(function (response) {
                var result = Common.Utilities.parseData(response.data.results);
                if (!result || !result.data || !result.data.formation) {
                    d.reject('Create playbook result was invalid');
                }
                var formationModel = new Common.Models.Formation(Team.Enums.UnitTypes.Other);
                result.data.formation.key = result.key;
                formationModel.fromJson(result.data.formation);
                console.log(formationModel);
                impakt.context.Playbook.formations.add(formationModel);
                notification.success('Successfully created formation "', formationModel.name, '"');
                $rootScope.$broadcast('create-entity', formationModel);
                d.resolve(formationModel);
            }, function (error) {
                notification.error('Failed to create formation "', newFormation.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given formation for the current user
         * @param {Common.Models.Formation} formation The formation to be deleted
         */
        this.deleteFormation = function (formation) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting formation "', formation.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.DELETE_FORMATION), {
                key: formation.key
            })
                .then(function (response) {
                var formationKey = response.data.results.key;
                // TODO @theBull
                // Deleting a formation will adversely impakt all plays that are
                // associated with that formation...How do we handle this?
                // update the context
                impakt.context.Playbook.formations.remove(formation.guid);
                notification.success('Successfully deleted formation "', formation.name, '"');
                d.resolve(formationKey);
            }, function (error) {
                notification.error('Failed to delete formation "', formation.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all formations for the current user
         */
        this.getFormations = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting Formations...');
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_FORMATIONS, '?$filter=ParentRK gt 0'))
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var formationCollection = new Common.Models.FormationCollection(Team.Enums.UnitTypes.Mixed);
                for (var i = 0; i < results.length; i++) {
                    var result = results[i];
                    if (result && result.data && result.data.formation) {
                        var rawFormation = result.data.formation;
                        rawFormation.key = result.key;
                        var formationModel = new Common.Models.Formation(Team.Enums.UnitTypes.Other);
                        formationModel.fromJson(rawFormation);
                        formationCollection.add(formationModel);
                    }
                    else {
                        throw new Error('An invalid formation was retrieved');
                    }
                }
                notification.success(formationCollection.size(), ' Formations successfully retrieved');
                d.resolve(formationCollection);
            }, function (error) {
                notification.error('Failed to retrieve Formations');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves the formation with the given key for the current user
         * @param {[type]} key The key to retrieve
         */
        this.getFormation = function (key) {
            var d = $q.defer();
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_FORMATION, '?Key=' + key))
                .then(function (response) {
                var rawResults = Common.Utilities.parseData(response.data.results);
                var formationRaw = (JSON.parse(rawResults.data)).formation;
                var formationModel = new Common.Models.Formation(Team.Enums.UnitTypes.Other);
                formationModel.fromJson(formationRaw);
                d.resolve(formationModel);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        this.newFormation = function () {
        };
        /**
         * Opens the given formation for editing / navigates to the play editor
         * @param {Common.Models.Formation} formation The formation to be edited
         */
        this.editFormation = function (formation, forceOpen) {
            var notification = __notifications.info('Opened formation "', formation.name, '" for editing.');
            // determine whether the formation is already open            
            var formationOpen = forceOpen ? forceOpen : impakt.context.Playbook.editor.scenarios.hasElementWhich(function (scenario) {
                if (Common.Utilities.isNullOrUndefined(scenario.playPrimary) ||
                    Common.Utilities.isNullOrUndefined(scenario.playPrimary.formation))
                    return false;
                return scenario.editorType == Playbook.Enums.EditorTypes.Formation &&
                    scenario.playPrimary.formation.guid == formation.guid;
            });
            if (!formationOpen) {
                // formation isn't opened yet,
                // 1. create new scenario / primary play for the formation to sit in
                // 2. create a working copy of the formation
                // 3. update the working copy's properties accordingly
                // 4. add the working play to the editor context
                // Set Play to formation-only editing mode
                var primaryPlay = new Common.Models.PlayPrimary(formation.unitType);
                // need to make a copy of the formation here
                var formationCopy = formation.copy();
                primaryPlay.setFormation(formationCopy);
                // Set association data
                this.setFormationAssociations(primaryPlay);
                var scenario = new Common.Models.Scenario();
                scenario.setPlayPrimary(primaryPlay);
                scenario.setPlayOpponent(null);
                scenario.editorType = Playbook.Enums.EditorTypes.Formation;
                scenario.name = formation.name;
                // add the play onto the editor context
                impakt.context.Playbook.editor.scenarios.add(scenario);
            }
            // navigate to playbook editor
            //if(!$state.is('playbook.editor'))
            $state.transitionTo('playbook.editor');
        };
        /**
         * Updates the given formation for the current user
         * @param {Common.Models.Formation} formation The formation to update
         */
        this.updateFormation = function (formation) {
            var d = $q.defer();
            // update assignment collection to json object
            var formationData = formation.toJson();
            var notification = __notifications.pending('Updating formation');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.UPDATE_FORMATION), {
                version: 1,
                name: formationData.name,
                key: formationData.key,
                data: {
                    version: 1,
                    name: formationData.name,
                    key: formationData.key,
                    formation: formationData
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var formationModel = new Common.Models.Formation(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.formation) {
                    formationModel.fromJson(results.data.formation);
                    // update the context
                    impakt.context.Playbook.formations.set(formationModel.guid, formationModel);
                }
                notification.success('Successfully updated formation "', formation.name, '"');
                d.resolve(formationModel);
            }, function (error) {
                notification.error('Failed to update formation "', formation.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Saves the given formation according to the options passed for the given user
         * TODO @theBull create Options model
         *
         * @param {Common.Models.Formation} formation    Formation to save
         * @param {any}                  options Save options
         */
        this.saveFormation = function (formation, options) {
            var d = $q.defer();
            var notification = __notifications.pending('Saving formation "', formation.name, '"...');
            if (options.formation.action == Common.API.Actions.Create ||
                options.formation.action == Common.API.Actions.Copy) {
                // ensure formation has no key
                formation.key = -1;
                // ensure formation has a unique guid
                formation.guid = Common.Utilities.guid();
                self.createFormation(formation)
                    .then(function (createdFormation) {
                    notification.success('Successfully created and saved formation "', formation.name, '"');
                    d.resolve(createdFormation);
                }, function (err) {
                    notification.error('Failed to save formation "', formation.name, '"');
                    d.reject(err);
                });
            }
            else if (options.formation.action == Common.API.Actions.Overwrite) {
                // double check that the formation is  modified
                if (formation.modified) {
                    self.updateFormation(formation)
                        .then(function (updatedFormation) {
                        notification.success('Successfully saved formation "', formation.name, '"');
                        d.resolve(updatedFormation);
                    }, function (err) {
                        notification.error('Failed to save formation "', formation.name, '"');
                        d.reject(err);
                    });
                }
                else {
                    notification.warning('Formation "', formation.name, '" was not saved; no changes were detected.');
                    d.reject(null);
                }
            }
            return d.promise;
        };
        /**
         * Retrieves all assignment groups for the current user
         */
        this.getAssignmentGroups = function () {
            var d = $q.defer();
            var assignmentsNotification = __notifications.pending('Getting Assignments...');
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_ASSIGNMENTGROUPS))
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var assignmentGroupCollection = new Common.Models.AssignmentGroupCollection(Team.Enums.UnitTypes.Mixed);
                for (var i = 0; i < results.length; i++) {
                    var result = results[i];
                    if (result && result.data && result.data.assignmentGroup) {
                        var assignmentGroupModel = new Common.Models.AssignmentGroup(Team.Enums.UnitTypes.Other);
                        assignmentGroupModel.key = result.key;
                        result.data.assignmentGroup.key = result.key;
                        assignmentGroupModel.fromJson(result.data.assignmentGroup);
                        assignmentGroupCollection.add(assignmentGroupModel);
                    }
                }
                assignmentsNotification.success(assignmentGroupCollection.size(), ' Assignment groups successfully retrieved');
                d.resolve(assignmentGroupCollection);
            }, function (error) {
                assignmentsNotification.error('Failed to retrieve Assignment groups');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given assignment group for the current user
         * @param {Common.Models.AssignmentGroup} assignmentGroup The assignment group to be deleted
         */
        this.deleteAssignmentGroup = function (assignmentGroup) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting assignment group "', assignmentGroup.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.DELETE_ASSIGNMENTGROUP), {
                key: assignmentGroup.key
            })
                .then(function (response) {
                var assignmentGroupKey = response.data.results.key;
                // update the context
                impakt.context.Playbook.assignmentGroups.remove(assignmentGroup.guid);
                notification.success('Successfully deleted assignment group "', assignmentGroup.name, '"');
                d.resolve(assignmentGroupKey);
            }, function (error) {
                notification.error('Failed to delete assignment group "', assignmentGroup.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Creates a collection group
         * @param {[type]} assignments The assignments to create
         */
        this.createAssignmentGroup = function (assignmentGroup) {
            var d = $q.defer();
            var notification = __notifications.pending('Creating assignment group "', assignmentGroup.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.CREATE_ASSIGNMENTGROUP), {
                version: 1,
                name: assignmentGroup.name,
                ownerRK: 1,
                parentRK: 1,
                data: {
                    version: 1,
                    name: assignmentGroup.name,
                    ownerRK: 1,
                    parentRK: 1,
                    assignmentGroup: assignmentGroup.toJson()
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var assignmentGroup = new Common.Models.AssignmentGroup(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.assignmentGroup) {
                    var rawAssignmentGroup = results.data.assignmentGroup;
                    rawAssignmentGroup.key = results.key;
                    assignmentGroup.fromJson(rawAssignmentGroup);
                    impakt.context.Playbook.assignmentGroups.add(assignmentGroup);
                    notification.success('Successfully created assignment group "', assignmentGroup.name, '"');
                    $rootScope.$broadcast('create-entity', assignmentGroup);
                    d.resolve(assignmentGroup);
                }
                else {
                    notification.warning('Created assignment group "', assignmentGroup.name, '" but an error may have occurred \
                         in the process. You may need to refresh your browser if you experience issues.');
                    d.reject(null);
                }
            }, function (error) {
                notification.success('Failed to create assignment group "', assignmentGroup.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given assignment collection (group) for the current user
         * @param {Common.Models.AssignmentGroup} assignments The assignment collection (group) to update
         */
        this.updateAssignmentGroup = function (assignmentGroup) {
            var d = $q.defer();
            // update assignment group to json object
            var assignmentGroupData = assignmentGroup.toJson();
            var notification = __notifications.pending('Updating assignment group "', assignmentGroup.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.UPDATE_ASSIGNMENTGROUP), {
                version: 1,
                name: assignmentGroupData.name,
                key: assignmentGroupData.key,
                data: {
                    version: 1,
                    name: assignmentGroupData.name,
                    key: assignmentGroupData.key,
                    assignmentGroup: assignmentGroup.toJson()
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var assignmentGroupModel = new Common.Models.AssignmentGroup(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.assignmentGroup) {
                    assignmentGroupModel.fromJson(results.data.assignmentGroup);
                    // update the context
                    impakt.context.Playbook.assignmentGroups.set(assignmentGroupModel.guid, assignmentGroupModel);
                }
                notification.success('Successfully updated assignment group "', assignmentGroupModel.name, '"');
                d.resolve(assignmentGroupModel);
            }, function (error) {
                notification.error('Failed to update assignment group "', assignmentGroup.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Creates the given play for the current user
         * @param {Common.Models.Play} play The play to create
         */
        this.createPlay = function (play) {
            var playData = play.toJson();
            var d = $q.defer();
            var notification = __notifications.pending('Creating play "', play.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.CREATE_PLAY), {
                version: 1,
                name: play.name,
                ownerRK: 1,
                parentRK: 1,
                data: {
                    version: 1,
                    name: play.name,
                    ownerRK: 1,
                    parentRK: 1,
                    play: playData
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var playModel = null;
                if (results && results.data && results.data.play) {
                    playModel = new Common.Models.PlayPrimary(Team.Enums.UnitTypes.Other);
                    results.data.play.key = results.key;
                    playModel.fromJson(results.data.play);
                    impakt.context.Playbook.plays.add(playModel);
                }
                notification.success('Successfully created play "', play.name, '"');
                $rootScope.$broadcast('create-entity', playModel);
                d.resolve(playModel);
            }, function (error) {
                notification.error('Failed to create play "', play.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Saves the given play according to the options passed for the given user
         * TODO @theBull create Options model
         *
         * @param {Common.Models.Play} play    [description]
         * @param {any}                  options [description]
         */
        this.savePlay = function (play, options) {
            var d = $q.defer();
            var notification = __notifications.pending('Saving play "', play.name, '"...');
            async.parallel([
                // 
                // Save formation
                // 
                // 
                // Save formation
                // 
                function (callback) {
                    // create, copy, or overwrite?
                    if (options.formation.action == Common.API.Actions.Create ||
                        options.formation.action == Common.API.Actions.Copy) {
                        // ensure playbook.formation has no key
                        play.formation.key = -1;
                        self.createFormation(play.formation)
                            .then(function (createdFormation) {
                            play.formation = createdFormation;
                            callback(null, play);
                        }, function (err) {
                            callback(err);
                        });
                    }
                    else if (options.formation.action == Common.API.Actions.Overwrite) {
                        self.updateFormation(play.formation)
                            .then(function (updatedFormation) {
                            callback(null, play);
                        }, function (err) {
                            callback(err);
                        });
                    }
                    else {
                        callback(null, play);
                    }
                },
                // save personnel
                // function(callback) {
                //     console.warn('Save Play > Personnel not implemented, skipping...');
                //     callback(null, play);
                // },
                // save assignments
                // save personnel
                // function(callback) {
                //     console.warn('Save Play > Personnel not implemented, skipping...');
                //     callback(null, play);
                // },
                // save assignments
                function (callback) {
                    if (Common.Utilities.isNullOrUndefined(play.assignmentGroup))
                        callback(null, play);
                    if (options.assignmentGroup.action == Common.API.Actions.Create ||
                        options.assignmentGroup.action == Common.API.Actions.Copy) {
                        // ensure play has no key
                        play.assignmentGroup.key = -1;
                        self.createAssignmentGroup(play.assignmentGroup)
                            .then(function (createdAssignmentGroup) {
                            if (!_associations.associationExists(play.associationKey, createdAssignmentGroup.associationKey)) {
                                _associations.createAssociation(play, createdAssignmentGroup).then(function () {
                                    callback(null, play);
                                }, function (err) {
                                    callback(err);
                                });
                            }
                        }, function (err) {
                            callback(err);
                        });
                    }
                    else if (options.assignmentGroup.action == Common.API.Actions.Overwrite) {
                        self.updateAssignmentGroup(play.assignmentGroup)
                            .then(function (updatedAssignmentGroup) {
                            callback(null, updatedAssignmentGroup);
                        }, function (err) {
                            callback(err);
                        });
                    }
                    else {
                        callback(null, play);
                    }
                },
                // save play
                // save play
                function (callback) {
                    if (options.play.action == Common.API.Actions.Create ||
                        options.play.action == Common.API.Actions.Copy) {
                        // ensure play has no key
                        play.key = -1;
                        self.createPlay(play)
                            .then(function (createdPlay) {
                            callback(null, createdPlay);
                        }, function (err) {
                            callback(err);
                        });
                    }
                    else if (options.play.action == Common.API.Actions.Overwrite) {
                        self.updatePlay(play)
                            .then(function (updatedPlay) {
                            callback(null, updatedPlay);
                        }, function (err) {
                            callback(err);
                        });
                    }
                    else {
                        callback(null, play);
                    }
                }
            ], function (err, results) {
                if (err) {
                    notification.error('Failed to save play "', play.name, '"');
                    d.reject(err);
                }
                else {
                    notification.success('Successfully saved play "', play.name, '"');
                    d.resolve(results);
                }
            });
            return d.promise;
        };
        /**
         * Updates the given play for the current user
         * @param {Common.Models.Play} play The play to update
         */
        this.updatePlay = function (play) {
            var d = $q.defer();
            var notification = __notifications.pending('Updating play "', play.name, '"...');
            var playData = play.toJson();
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.UPDATE_PLAY), {
                version: 1,
                name: play.name,
                key: play.key,
                data: {
                    version: 1,
                    name: play.name,
                    key: play.key,
                    play: playData
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var playModel = new Common.Models.PlayPrimary(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.play) {
                    playModel.fromJson(results.data.play);
                    // update the context
                    impakt.context.Playbook.plays.set(playModel.guid, playModel);
                }
                notification.success('Successfully updated play "', playModel.name, '"');
                d.resolve(playModel);
            }, function (error) {
                notification.error('Failed to update play "', play.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all plays for the current user
         */
        this.getPlays = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting Plays...');
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_PLAYS))
                .then(function (response) {
                var playCollection = new Common.Models.PlayCollection(Team.Enums.UnitTypes.Mixed);
                if (response && response.data && response.data.results) {
                    var results = Common.Utilities.parseData(response.data.results);
                    if (results) {
                        var rawPlays = results;
                        for (var i = 0; i < results.length; i++) {
                            var result = results[i];
                            if (result && result.data && result.data.play) {
                                var rawPlay = result.data.play;
                                var playModel = new Common.Models.PlayPrimary(Team.Enums.UnitTypes.Other);
                                rawPlay.key = result.key;
                                playModel.fromJson(rawPlay);
                                playCollection.add(playModel);
                            }
                        }
                    }
                }
                notification.success(playCollection.size(), ' Plays successfully retrieved');
                d.resolve(playCollection);
            }, function (error) {
                notification.error('Failed to retrieve Plays');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Prepares the given play to be opened in the play editor
         * @param {Common.Models.Play} play The play to be edited
         */
        this.editPlay = function (play) {
            var notification = __notifications.info('Opened play "', play.name, '" for editing.');
            // Set Play to play editing mode
            var scenario = new Common.Models.Scenario();
            var playCopy = play.copy();
            if (play.playType != Playbook.Enums.PlayTypes.Primary) {
                playCopy = Common.Models.Play.toPrimary(playCopy);
            }
            scenario.setPlayPrimary(playCopy);
            scenario.setPlayOpponent(null);
            scenario.name = playCopy.name;
            scenario.editorType = Playbook.Enums.EditorTypes.Play;
            // Set association data
            this.setPlayAssociations(scenario.playPrimary);
            // add the play onto the editor context
            impakt.context.Playbook.editor.scenarios.add(scenario);
            // navigate to playbook editor
            //if (!$state.is('playbook.editor'))
            $state.transitionTo('playbook.editor');
        };
        /**
         * Deletes the given play for the current user
         * @param {Common.Models.Play} play The play to be deleted
         */
        this.deletePlay = function (play) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting play "', play.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.DELETE_PLAY), {
                key: play.key
            })
                .then(function (response) {
                var playKey = response.data.results.key;
                // update the context
                impakt.context.Playbook.plays.remove(play.guid);
                notification.success('Successfully deleted play "', play.name, '"');
                d.resolve(play);
            }, function (error) {
                notification.error('Failed to delete play "', play.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Creates the given scenario for the current user
         * @param {Common.Models.Scenario} scenario The scenario to create
         */
        this.createScenario = function (scenario) {
            var scenarioData = scenario.toJson();
            var d = $q.defer();
            var notification = __notifications.pending('Creating scenario "', scenario.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.CREATE_SCENARIO), {
                version: 1,
                name: scenario.name,
                ownerRK: 1,
                parentRK: 1,
                data: {
                    version: 1,
                    name: scenario.name,
                    ownerRK: 1,
                    parentRK: 1,
                    scenario: scenarioData
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var scenarioModel = null;
                if (results && results.data && results.data.scenario) {
                    scenarioModel = new Common.Models.Scenario();
                    results.data.scenario.key = results.key;
                    scenarioModel.fromJson(results.data.scenario);
                    impakt.context.Playbook.scenarios.add(scenarioModel);
                }
                notification.success('Successfully created scenario "', scenario.name, '"');
                $rootScope.$broadcast('create-entity', scenarioModel);
                d.resolve(scenarioModel);
            }, function (error) {
                notification.error('Failed to create scenario "', scenario.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Saves the given scenario according to the options passed for the given user
         * TODO @theBull create Options model
         *
         * @param {Common.Models.Scenario} scenario    [description]
         * @param {any}                  options [description]
         */
        this.saveScenario = function (scenario, options) {
            var d = $q.defer();
            var notification = __notifications.pending('Saving scenario "', scenario.name, '"...');
            async.parallel([
                function (callback) {
                    callback(null, null);
                }
            ], function (err, results) {
                if (err) {
                    notification.error('Failed to save scenario "', scenario.name, '"');
                    d.reject(err);
                }
                else {
                    notification.success('Successfully saved scenario "', scenario.name, '"');
                    d.resolve(results);
                }
            });
            return d.promise;
        };
        /**
         * Updates the given scenario for the current user
         * @param {Common.Models.Scenario} scenario The scenario to update
         */
        this.updateScenario = function (scenario) {
            var d = $q.defer();
            var notification = __notifications.pending('Updating scenario "', scenario.name, '"...');
            var scenarioData = scenario.toJson();
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.UPDATE_SCENARIO), {
                version: 1,
                name: scenario.name,
                key: scenario.key,
                data: {
                    version: 1,
                    name: scenario.name,
                    key: scenario.key,
                    scenario: scenarioData
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var scenarioModel = new Common.Models.PlayPrimary(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.scenario) {
                    scenarioModel.fromJson(results.data.scenario);
                    // update the context
                    impakt.context.Playbook.scenario.set(scenarioModel.guid, scenarioModel);
                }
                notification.success('Successfully updated scenario "', scenarioModel.name, '"');
                d.resolve(scenarioModel);
            }, function (error) {
                notification.error('Failed to update scenario "', scenario.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all scenarios for the current user
         */
        this.getScenarios = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting Scenarios...');
            __api.get(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.GET_SCENARIOS))
                .then(function (response) {
                var scenarioCollection = new Common.Models.ScenarioCollection(Team.Enums.UnitTypes.Mixed);
                if (response && response.data && response.data.results) {
                    var results = Common.Utilities.parseData(response.data.results);
                    if (results) {
                        var rawScenarios = results;
                        for (var i = 0; i < results.length; i++) {
                            var result = results[i];
                            if (result && result.data && result.data.scenario) {
                                var rawScenario = result.data.scenario;
                                var scenarioModel = new Common.Models.Scenario();
                                rawScenario.key = result.key;
                                scenarioModel.fromJson(rawScenario);
                                scenarioCollection.add(scenarioModel);
                            }
                        }
                    }
                }
                notification.success(scenarioCollection.size(), ' Scenarios successfully retrieved');
                d.resolve(scenarioCollection);
            }, function (error) {
                notification.error('Failed to retrieve Scenarios');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Prepares the given scenario to be opened in the editor
         * @param {Common.Models.Scenario} scenario The scenario to be edited
         */
        this.editScenario = function (scenario) {
            var notification = __notifications.info('Opened scenario "', scenario.name, '" for editing.');
            // add the scenario onto the editor context
            var scenarioCopy = scenario.copy();
            scenarioCopy.editorType = Playbook.Enums.EditorTypes.Scenario;
            this.setScenarioAssociations(scenarioCopy);
            impakt.context.Playbook.editor.scenarios.add(scenarioCopy); // <-- create copy
            // navigate to playbook editor
            //if (!$state.is('playbook.editor'))
            $state.transitionTo('playbook.editor');
        };
        /**
         * Deletes the given scenario for the current user
         * @param {Common.Models.Scenario} scenario The scenario to be deleted
         */
        this.deleteScenario = function (scenario) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting scenario "', scenario.name, '"...');
            __api.post(__api.path(PLAYBOOK.ENDPOINT, PLAYBOOK.DELETE_SCENARIO), {
                key: scenario.key
            })
                .then(function (response) {
                var scenarioKey = response.data.results.key;
                // update the context
                impakt.context.Playbook.scenarios.remove(scenario.guid);
                notification.success('Successfully deleted scenario "', scenario.name, '"');
                d.resolve(scenario);
            }, function (error) {
                notification.error('Failed to delete scenario "', scenario.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Returns a list of all unit types
         */
        this.getUnitTypes = function () {
            return new Team.Models.UnitTypeCollection();
        };
        /**
         * Returns an list of all unit types
         */
        this.getUnitTypesEnum = function () {
            var typeEnums = {};
            for (var unitType in Team.Enums.UnitTypes) {
                var unitTypeInt = parseInt(unitType);
                if (unitTypeInt >= 0)
                    typeEnums[unitTypeInt]
                        = Common.Utilities.camelCaseToSpace(Team.Enums.UnitTypes[unitTypeInt], true);
            }
            return typeEnums;
        };
        /**
         * Returns a class for the given editorType
         * @param {Playbook.Enums.EditorTypes} editorType Editor Type enum
         */
        this.getEditorTypeClass = function (editorType) {
            var editorTypeClass = '';
            switch (editorType) {
                case Playbook.Enums.EditorTypes.Formation:
                    editorTypeClass = 'playbook-editor-type-formation';
                    break;
                case Playbook.Enums.EditorTypes.Assignment:
                    editorTypeClass = 'playbook-editor-type-assignment';
                    break;
                case Playbook.Enums.EditorTypes.Play:
                    editorTypeClass = 'playbook-editor-type-play';
                    break;
                case Playbook.Enums.EditorTypes.Scenario:
                    editorTypeClass = 'playbook-editor-type-scenario';
                    break;
            }
            return editorTypeClass;
        };
        /**
         * Navigates to the playbook editor
         */
        this.toEditor = function () {
            $state.transitionTo('playbook.editor');
        };
        /**
         * Refreshes the playbook editor
         */
        this.refreshEditor = function () {
            $rootScope.$broadcast('playbook-editor.refresh');
        };
        /**
         * Navigates to the playbook browser
         */
        this.toBrowser = function () {
            this.drilldown.playbook = null;
            $state.transitionTo('playbook.browser');
        };
        this.toPlaybookDrilldown = function (playbookModel) {
            this.drilldown.playbook = playbookModel;
            $state.transitionTo('playbook.drilldown.playbook');
        };
        /**
         * Navigates to the team module
         */
        this.toTeam = function () {
            $state.transitionTo('team');
        };
        /**
         * Takes a given entity (of unknown type) and uses its internally
         * defined ImpaktDataType to determine the appropriate API method
         * to call.
         *
         * @param {Common.Interfaces.IActionable} entity The entity to delete
         */
        this.deleteEntityByType = function (entity) {
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Playbook:
                    return _playbookModals.deletePlaybook(entity);
                case Common.Enums.ImpaktDataTypes.Play:
                    return _playbookModals.deletePlay(entity);
                case Common.Enums.ImpaktDataTypes.Formation:
                    return _playbookModals.deleteFormation(entity);
                case Common.Enums.ImpaktDataTypes.AssignmentGroup:
                    return _playbookModals.deleteAssignmentGroup(entity);
                case Common.Enums.ImpaktDataTypes.Scenario:
                    return _playbookModals.deleteScenario(entity);
                default:
                    d.reject(new Error('_playbook deleteEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise;
        };
        /**
         * Takes a given entity (of unknown type) and uses its internally
         * defined ImpaktDataType to determine the appropriate API method
         * to call.
         *
         * @param {Common.Interfaces.IActionable} entity The entity to delete
         */
        this.updateEntityByType = function (entity) {
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Playbook:
                    return _playbookModals.savePlaybook(entity);
                case Common.Enums.ImpaktDataTypes.Play:
                    return _playbookModals.savePlay(entity);
                case Common.Enums.ImpaktDataTypes.Formation:
                    return _playbookModals.saveFormation(entity);
                case Common.Enums.ImpaktDataTypes.AssignmentGroup:
                    return _playbookModals.saveAssignmentGroup(entity);
                case Common.Enums.ImpaktDataTypes.Scenario:
                    return _playbookModals.saveScenario(entity);
                default:
                    d.reject(new Error('_playbook deleteEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise;
        };
        this.setScenarioAssociations = function (scenario) {
            var associations = _associations.getAssociated(scenario);
            var plays = associations.plays;
            if (Common.Utilities.isNotNullOrUndefined(plays)) {
                var playPrimary = plays.filterFirst(function (play, index) {
                    return play.guid == scenario.playPrimaryGuid;
                });
                var playOpponent = plays.filterFirst(function (play, index) {
                    return play.guid == scenario.playOpponentGuid;
                });
                if (Common.Utilities.isNotNullOrUndefined(playPrimary)) {
                    this.setPlayAssociations(playPrimary);
                    scenario.setPlayPrimary(playPrimary);
                }
                if (Common.Utilities.isNotNullOrUndefined(playOpponent)) {
                    this.setPlayAssociations(playOpponent);
                    scenario.setPlayOpponent(playOpponent);
                }
            }
            return scenario;
        };
        this.setPlayAssociations = function (play) {
            var associations = _associations.getAssociated(play);
            var formation = associations.formations.first();
            play.formation = formation && formation.copy();
            var assignmentGroup = associations.assignmentGroups.first();
            play.assignmentGroup = assignmentGroup && assignmentGroup.copy();
            var personnel = associations.personnel.first();
            play.personnel = personnel && personnel.copy();
            return play;
        };
        this.setFormationAssociations = function (play) {
            if (Common.Utilities.isNullOrUndefined(play))
                return;
            var associations = _associations.getAssociated(play.formation);
            var personnel = associations.personnel.first();
            play.personnel = personnel && personnel.copy();
        };
    }]);
/// <reference path='../playbook.mdl.ts' />
impakt.playbook.sidebar = angular.module('impakt.playbook.sidebar', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.playbook.sidebar - config');
    }])
    .run([function () {
        console.debug('impakt.playbook.sidebar - run');
    }]);
/// <reference path='./playbook-sidebar.mdl.ts' />
impakt.playbook.sidebar.controller('playbook.sidebar.ctrl', [
    '$scope',
    '__router',
    '_playbook',
    '_playbookModals',
    function ($scope, __router, _playbook, _playbookModals) {
        var parent = 'playbook.sidebar';
        __router.push(parent, [
            new Common.Models.Template('playbook.sidebar.playbooks', 'modules/playbook/sidebar/playbook/playbook-sidebar-playbooks.tpl.html'),
            new Common.Models.Template('playbook.sidebar.plays', 'modules/playbook/sidebar/play/playbook-sidebar-plays.tpl.html'),
            new Common.Models.Template('playbook.sidebar.formations', 'modules/playbook/sidebar/formation/playbook-sidebar-formations.tpl.html')
        ]);
        $scope.template = {};
        $scope.plays = impakt.context.Playbook.plays;
        $scope.formations = impakt.context.Playbook.formations;
        $scope.playbooks = impakt.context.Playbook.playbooks;
        $scope.goToPlaybooks = function () {
            $scope.template = __router.get(parent, 'playbook.sidebar.playbooks');
        };
        $scope.goToPlays = function () {
            $scope.template = __router.get(parent, 'playbook.sidebar.plays');
        };
        $scope.goToFormations = function () {
            $scope.template = __router.get(parent, 'playbook.sidebar.formations');
        };
        $scope.refreshPlays = function () {
            $scope.plays = impakt.context.Playbook.plays;
        };
        $scope.refreshFormations = function () {
            $scope.formations = impakt.context.Playbook.formations;
        };
        $scope.refreshPlaybooks = function () {
            $scope.playbooks = impakt.context.Playbook.playbooks;
        };
        $scope.createPlay = function () {
            _playbookModals.createPlay();
        };
        $scope.createFormation = function () {
            _playbookModals.createFormation();
        };
        $scope.createPlaybook = function () {
            _playbookModals.createPlaybook();
        };
        $scope.openFormationInEditor = function (formation) {
            _playbook.editFormation(formation);
            _playbook.refreshEditor();
        };
        $scope.openPlayInEditor = function (play) {
            _playbook.editPlay(play);
            _playbook.refreshEditor();
        };
        $scope.goToPlays();
    }]);
/// <reference path='../modules.mdl.ts' />
impakt.search = angular.module('impakt.search', [])
    .filter('globalSearchFilter', function () {
    return function (input, searchQuery) {
    };
});
/// <reference path='./search.mdl.ts' />
impakt.search.controller('search.ctrl', [
    '$scope',
    '__context',
    function ($scope, __context) {
        $scope.title = 'Results';
        $scope.query = '';
        $scope.playbooks;
        $scope.formations;
        $scope.plays;
        // attach key listeners
        __context.onReady(function () {
            $scope.playbooks = impakt.context.Playbook.playbooks;
            $scope.formations = impakt.context.Playbook.formations;
            $scope.plays = impakt.context.Playbook.plays;
        });
        $scope.$on("$destroy", function () {
        });
    }]);
/// <reference path='../modules.mdl.ts' />
/// <reference path='./season.ts' />
impakt.season = angular.module('impakt.season', [
    'impakt.season.browser',
    'impakt.season.drilldown',
    'impakt.season.modals'
])
    .config([
    '$stateProvider',
    '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {
        console.debug('impakt.season - config');
        // impakt module states
        $stateProvider.state('season', {
            url: '/season',
            templateUrl: 'modules/season/season.tpl.html',
            controller: 'season.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.season - run');
});
/// <reference path='../season.mdl.ts' />
impakt.season.browser = angular.module('impakt.season.browser', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.season.browser - config');
        $stateProvider.state('season.browser', {
            url: '/browser',
            templateUrl: 'modules/season/browser/season-browser.tpl.html',
            controller: 'season.browser.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.season.browser - run');
});
/// <reference path='./season-browser.mdl.ts' />
impakt.season.browser.controller('season.browser.ctrl', [
    '$scope',
    '_season',
    '_seasonModals',
    function ($scope, _season, _seasonModals) {
        $scope.seasons = impakt.context.Season.seasons;
        // TODO @theBull - filter by year
        // TODO @theBull - filter by league
        // TODO @theBull - filter by week
        $scope.createSeason = function () {
            _seasonModals.createSeason();
        };
    }]);
/// <reference path='../season.mdl.ts' />
impakt.season.drilldown = angular.module('impakt.season.drilldown', [
    'impakt.season.drilldown.season',
    'impakt.season.drilldown.week',
    'impakt.season.drilldown.game'
])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.season.drilldown - config');
        $stateProvider.state('season.drilldown', {
            url: '/drilldown',
            templateUrl: 'modules/season/drilldown/season-drilldown.tpl.html',
            controller: 'season.drilldown.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.season.drilldown - run');
});
/// <reference path='../season-drilldown.mdl.ts' />
impakt.season.drilldown.game = angular.module('impakt.season.drilldown.game', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.season.drilldown.game - config');
        $stateProvider.state('season.drilldown.game', {
            url: '/game',
            templateUrl: 'modules/season/drilldown/game/season-drilldown-game.tpl.html',
            controller: 'season.drilldown.game.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.season.drilldown.game - run');
});
/// <reference path='./season-drilldown-game.mdl.ts' />
impakt.season.drilldown.game.controller('season.drilldown.game.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    '_season',
    '_seasonModals',
    '_teamModals',
    function ($scope, $rootScope, _associations, _season, _seasonModals, _teamModals) {
        $scope.season = _season.drilldown.season;
        $scope.game = _season.drilldown.game;
        $scope.teams = new Team.Models.TeamModelCollection();
        $scope.homeTeam = null;
        $scope.awayTeam = null;
        var deleteGameListener = $rootScope.$on('delete-game', function (e, game) {
            if (!Common.Utilities.isNullOrUndefined(_season.drilldown.week))
                _season.toWeekDrilldown(_season.drilldown.week);
        });
        var associationsUpdatedListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            deleteGameListener();
            associationsUpdatedListener();
        });
        function init() {
            var gameAssociations = _associations.getAssociated($scope.game);
            $scope.game.setSeason($scope.season);
            if (Common.Utilities.isNotNullOrUndefined(gameAssociations)) {
                $scope.teams = gameAssociations.teams;
                $scope.teams.forEach(function (team, index) {
                    var teamAssociations = _associations.getAssociated(team);
                    //team.setGame($scope.game);						
                });
            }
        }
        init();
    }]);
/// <reference path='./season-drilldown.mdl.ts' />
impakt.season.drilldown.controller('season.drilldown.ctrl', [
    '$scope',
    '_details',
    '_season',
    function ($scope, _details, _season) {
        $scope.drilldown = _season.drilldown;
        $scope.toSeasonDrilldown = function (season) {
            _season.toSeasonDrilldown(season);
        };
        $scope.toWeekDrilldown = function (week) {
            _season.toWeekDrilldown(week);
        };
        $scope.toBrowser = function () {
            _details.selectedElements.deselectAll();
            _season.toBrowser();
        };
    }]);
/// <reference path='../season-drilldown.mdl.ts' />
impakt.season.drilldown.season = angular.module('impakt.season.drilldown.season', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.season.drilldown.season - config');
        $stateProvider.state('season.drilldown.season', {
            url: '/season',
            templateUrl: 'modules/season/drilldown/season/season-drilldown-season.tpl.html',
            controller: 'season.drilldown.season.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.season.drilldown.season - run');
});
/// <reference path='./season-drilldown-season.mdl.ts' />
impakt.season.drilldown.season.controller('season.drilldown.season.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    '_season',
    '_seasonModals',
    function ($scope, $rootScope, _associations, _season, _seasonModals) {
        $scope.season = _season.drilldown.season;
        $scope.games = new Season.Models.GameCollection();
        var deleteGameListener = $rootScope.$on('delete-game', function (e, game) {
            $scope.games.remove(game.guid);
        });
        var associationsUpdatedListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            deleteGameListener();
            associationsUpdatedListener();
        });
        function init() {
            var seasonAssociations = _associations.getAssociated($scope.season);
            if (Common.Utilities.isNotNullOrUndefined(seasonAssociations)) {
                $scope.games = seasonAssociations.games;
                $scope.games.forEach(function (game, index) {
                    var gameAssociations = _associations.getAssociated(game);
                    //game.setSeason($scope.season);
                });
            }
            $scope.season.weeks.forEach(function (week, index) {
            });
        }
        $scope.createGame = function () {
            _seasonModals.createGame($scope.season)
                .then(function () {
                init();
            });
        };
        init();
    }]);
/// <reference path='../season-drilldown.mdl.ts' />
impakt.season.drilldown.week = angular.module('impakt.season.drilldown.week', [])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.season.drilldown.week - config');
        $stateProvider.state('season.drilldown.week', {
            url: '/week',
            templateUrl: 'modules/season/drilldown/week/season-drilldown-week.tpl.html',
            controller: 'season.drilldown.week.ctrl'
        });
    }])
    .run(function () {
    console.debug('impakt.season.drilldown.week - run');
});
/// <reference path='./season-drilldown-week.mdl.ts' />
impakt.season.drilldown.week.controller('season.drilldown.week.ctrl', [
    '$scope',
    '$rootScope',
    '_associations',
    '_season',
    '_seasonModals',
    function ($scope, $rootScope, _associations, _season, _seasonModals) {
        $scope.season = _season.drilldown.season;
        $scope.week = _season.drilldown.week;
        $scope.allGames = impakt.context.Season.games;
        $scope.games = new Season.Models.GameCollection();
        $scope.teams = impakt.context.Team.teams;
        $scope.location = impakt.context.League.locations;
        var deleteGameListener = $rootScope.$on('delete-game', function (e, game) {
            $scope.games.remove(game.guid);
        });
        var associationsUpdatedListener = $rootScope.$on('associations-updated', function (e) {
            init();
        });
        $scope.$on('$destroy', function () {
            associationsUpdatedListener();
            deleteGameListener();
        });
        function init() {
            if (Common.Utilities.isNullOrUndefined($scope.week) ||
                Common.Utilities.isNullOrUndefined($scope.games))
                return;
            $scope.allGames.forEach(function (game, index) {
                if (game.weekGuid == $scope.week.guid) {
                    var gameAssociations = _associations.getAssociated(game);
                    if (Common.Utilities.isNotNullOrUndefined(gameAssociations.locations)) {
                        game.setLocation(gameAssociations.locations.first());
                    }
                    if (Common.Utilities.isNotNullOrUndefined(gameAssociations.teams)) {
                        game.setAway(gameAssociations.teams.get(game.awayGuid));
                        game.setHome(gameAssociations.teams.get(game.homeGuid));
                    }
                    game.setWeek($scope.week);
                    $scope.games.add(game);
                }
            });
        }
        $scope.createGame = function () {
            _seasonModals.createGame($scope.season, $scope.week)
                .then(function () {
                init();
            });
        };
        init();
    }]);
/// <reference path='../season.mdl.ts' />
impakt.season.modals = angular.module('impakt.season.modals', [])
    .config(function () {
    console.debug('impakt.season.modals - config');
})
    .run(function () {
    console.debug('impakt.season.modals - run');
});
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.createGameDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_season',
    'game',
    function ($scope, $uibModalInstance, _season, game) {
        $scope.game = game;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.createGame.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_season',
    '_leagueModals',
    'season',
    'week',
    function ($scope, $uibModalInstance, _associations, _season, _leagueModals, season, week) {
        $scope.seasons = impakt.context.Season.seasons;
        $scope.newGame = new Season.Models.Game();
        $scope.selectedSeason = season || $scope.seasons.first();
        $scope.teams = impakt.context.Team.teams;
        $scope.locations = impakt.context.League.locations;
        // TODO @theBull
        $scope.selectedHomeTeam = new Team.Models.TeamModel();
        $scope.selectedAwayTeam = new Team.Models.TeamModel();
        $scope.selectedWeek = week || new Season.Models.Week();
        // initalize selected location with:
        // - home team's location, if it exists - or - first location in the list
        $scope.selectedLocation = $scope.selectedHomeTeam && $scope.selectedHomeTeam.location ?
            $scope.selectedHomeTeam.location : $scope.locations.first();
        function init() {
            if (Common.Utilities.isNotNullOrUndefined(week)) {
                $scope.newGame.weekGuid = week.guid;
            }
        }
        $scope.teamChange = function () {
            $scope.newGame.setHome($scope.selectedHomeTeam);
            $scope.newGame.setAway($scope.selectedAwayTeam);
        };
        $scope.selectLocation = function () {
            if (Common.Utilities.isNotNullOrUndefined($scope.selectedLocation)) {
                $scope.newGame.setLocation($scope.selectedLocation);
            }
        };
        $scope.selectWeek = function () {
            $scope.newGame.weekGuid = $scope.selectedWeek.guid;
        };
        $scope.createLocation = function () {
            _leagueModals.createLocation().then(function (createdLocation) {
                $scope.locations = impakt.context.League.locations;
                $scope.selectedLocation = createdLocation;
                $scope.selectLocation();
            });
        };
        $scope.updateDatetime = function () {
            // TODO @theBull
        };
        $scope.ok = function () {
            _season.createGame($scope.newGame)
                .then(function (createdGame) {
                var associationsToAdd = [
                    $scope.selectedHomeTeam,
                    $scope.selectedAwayTeam,
                    $scope.selectedSeason,
                    $scope.selectedLocation
                ];
                _associations.createAssociations(createdGame, associationsToAdd);
                $uibModalInstance.close(createdGame);
            }, function (err) {
                $uibModalInstance.close(err);
            });
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            removeGameFromCreationContext();
            $uibModalInstance.dismiss();
        };
        function removeGameFromCreationContext() {
            // Remove the play from the creation context
            // after creating the new play or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.newGame))
                impakt.context.Season.creation.games.remove($scope.newGame.guid);
        }
        init();
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.createSeasonDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_season',
    'season',
    function ($scope, $uibModalInstance, _season, season) {
        $scope.season = season;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.createSeason.ctrl', [
    '$scope',
    '$timeout',
    '$uibModalInstance',
    '_season',
    function ($scope, $timeout, $uibModalInstance, _season) {
        $scope.newSeasonModel = new Season.Models.SeasonModel();
        $scope.numberOfWeeks = 32;
        $scope.maxWeeks = 64;
        $scope.minWeeks = 1;
        $scope.debounce = null;
        var DEBOUNCE_DELAY = 500;
        function init() {
            for (var i = 0; i < $scope.numberOfWeeks; i++) {
                $scope.newSeasonModel.weeks.add(createWeek(i + 1), false);
            }
        }
        function createWeek(weekNumber) {
            var week = new Season.Models.Week();
            week.name = 'Week';
            week.number = weekNumber;
            week.incrementWeek($scope.newSeasonModel.start, $scope.newSeasonModel.weeks.size());
            return week;
        }
        $scope.setWeeks = function () {
            if (Common.Utilities.isNotNullOrUndefined($scope.debounce)) {
                // clear an existing timeout if exists, to debounce
                $timeout.cancel($scope.debounce);
            }
            $scope.debounce = $timeout(function () {
                if (Common.Utilities.isNullOrUndefined($scope.numberOfWeeks) ||
                    $scope.numberOfWeeks == '' ||
                    isNaN($scope.numberOfWeeks) ||
                    $scope.numberOfWeeks == 0)
                    return;
                var sizeDiff = $scope.numberOfWeeks - $scope.newSeasonModel.weeks.size();
                if (sizeDiff == 0) {
                    return;
                }
                else {
                    if ($scope.numberOfWeeks > $scope.maxWeeks)
                        $scope.numberOfWeeks = $scope.maxWeeks;
                    if ($scope.numberOfWeeks < $scope.minWeeks)
                        $scope.numberOfWeeks = $scope.minWeeks;
                    $scope.newSeasonModel.weeks.listen(false);
                    if (sizeDiff < 0) {
                        while ($scope.newSeasonModel.weeks.size() > $scope.numberOfWeeks) {
                            $scope.newSeasonModel.weeks.pop();
                        }
                    }
                    else {
                        while ($scope.newSeasonModel.weeks.size() < $scope.numberOfWeeks) {
                            $scope.newSeasonModel.weeks.add(createWeek($scope.newSeasonModel.weeks.size() + 1));
                        }
                    }
                    $scope.newSeasonModel.weeks.listen(true);
                }
            }, DEBOUNCE_DELAY);
        };
        $scope.weekBlur = function () {
            $scope.numberOfWeeks = $scope.newSeasonModel.weeks.size();
        };
        $scope.updateDatetime = function () {
            var seasonStartDate = $scope.newSeasonModel.start.date;
            $scope.newSeasonModel.weeks.forEach(function (week, index) {
                // update weeks with the start date, +7 days
                week.incrementWeek($scope.newSeasonModel.start, index);
            });
        };
        $scope.ok = function () {
            _season.createSeason($scope.newSeasonModel)
                .then(function (createdSeason) {
                $uibModalInstance.close(createdSeason);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
        init();
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.deleteGame.ctrl', [
    '$scope',
    '$rootScope',
    '$uibModalInstance',
    '_season',
    'game',
    function ($scope, $rootScope, $uibModalInstance, _season, game) {
        $scope.game = game;
        $scope.ok = function () {
            _season.deleteGame($scope.game)
                .then(function (results) {
                $rootScope.$broadcast('delete-game', $scope.game);
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.deleteSeason.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_season',
    'season',
    function ($scope, $uibModalInstance, _season, season) {
        $scope.season = season;
        $scope.ok = function () {
            _season.deleteSeason($scope.season)
                .then(function (results) {
                $uibModalInstance.close(results);
            }, function (err) {
                console.error(err);
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.saveGame.ctrl', ['$scope',
    '$uibModalInstance',
    '_season',
    'game',
    function ($scope, $uibModalInstance, _season, game) {
        $scope.game = game;
        $scope.ok = function () {
            _season.updateGame($scope.game)
                .then(function (savedGame) {
                $uibModalInstance.close(savedGame);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../season-modals.mdl.ts' />
impakt.season.modals.controller('season.modals.saveSeason.ctrl', ['$scope',
    '$uibModalInstance',
    '_season',
    'season',
    function ($scope, $uibModalInstance, _season, season) {
        $scope.season = season;
        $scope.ok = function () {
            _season.updateSeason($scope.season)
                .then(function (savedSeason) {
                $uibModalInstance.close(savedSeason);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='./season-modals.mdl.ts' />
impakt.season.modals.service('_seasonModals', [
    '$q',
    '__modals',
    function ($q, __modals) {
        /**
         *
         * SEASON
         *
         */
        this.createSeason = function () {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/create-season/create-season.tpl.html', 'season.modals.createSeason.ctrl', {});
            modalInstance.result.then(function (createdSeason) {
                console.log(createdSeason);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createSeasonDuplicate = function (seasonModel) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/create-season-duplicate-error/create-season-duplicate-error.tpl.html', 'season.modals.createSeasonDuplicateError.ctrl', {
                season: function () {
                    return seasonModel;
                }
            });
            modalInstance.result.then(function (createdSeason) {
                console.log(createdSeason);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteSeason = function (season) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/delete-season/delete-season.tpl.html', 'season.modals.deleteSeason.ctrl', {
                season: function () {
                    return season;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveSeason = function (season) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/save-season/save-season.tpl.html', 'season.modals.saveSeason.ctrl', {
                season: function () {
                    return season;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * GAME
         *
         */
        this.createGame = function (season, week) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/create-game/create-game.tpl.html', 'season.modals.createGame.ctrl', {
                season: function () {
                    return season;
                },
                week: function () {
                    return week;
                }
            });
            modalInstance.result.then(function (createdGame) {
                console.log(createdGame);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createGameDuplicate = function (game) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/create-game-duplicate-error/create-game-duplicate-error.tpl.html', 'season.modals.createGameDuplicateError.ctrl', {
                game: function () {
                    return game;
                }
            });
            modalInstance.result.then(function (createdGame) {
                console.log(createdGame);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteGame = function (game) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/delete-game/delete-game.tpl.html', 'season.modals.deleteGame.ctrl', {
                game: function () {
                    return game;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveGame = function (game) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/save-game/save-game.tpl.html', 'season.modals.saveGame.ctrl', {
                game: function () {
                    return game;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        /**
         *
         * WEEK
         *
         */
        this.createWeek = function (game) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/create-week/create-week.tpl.html', 'season.modals.createWeek.ctrl', {
                game: function () {
                    return game;
                }
            });
            modalInstance.result.then(function (createdWeek) {
                console.log(createdWeek);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createWeekDuplicate = function (week) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/create-week-duplicate-error/create-week-duplicate-error.tpl.html', 'season.modals.createWeekDuplicateError.ctrl', {
                week: function () {
                    return week;
                }
            });
            modalInstance.result.then(function (createdWeek) {
                console.log(createdWeek);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteWeek = function (week) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/delete-week/delete-week.tpl.html', 'season.modals.deleteWeek.ctrl', {
                week: function () {
                    return week;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.saveWeek = function (week) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/season/modals/save-week/save-week.tpl.html', 'season.modals.saveWeek.ctrl', {
                week: function () {
                    return week;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
    }]);
/// <reference path='./season.mdl.ts' />
/**
 * Season constants defined here
 */
impakt.season.constant('SEASON', {
    ENDPOINT: '/teamInfo',
    // Season
    CREATE_SEASON: '/createSeason',
    GET_SEASONS: '/getSeasons',
    GET_SEASON: '/getSeason',
    DELETE_SEASON: '/deleteSeason',
    UPDATE_SEASON: '/updateSeason',
    // Season Games
    CREATE_GAME: '/createGame',
    GET_GAMES: '/getGames',
    GET_GAME: '/getGame',
    DELETE_GAME: '/deleteGame',
    UPDATE_GAME: '/updateGame'
});
/// <reference path='./season.mdl.ts' />
impakt.season.controller('season.ctrl', ['$scope', '$state', '_season',
    function ($scope, $state, _season) {
        // load up the browser by default
        $state.go('season.browser');
    }]);
/// <reference path='./models/models.ts' />
/// <reference path='./season.ts' />
// Season service
impakt.season.service('_season', [
    'SEASON',
    '$rootScope',
    '$q',
    '$state',
    '__api',
    '__localStorage',
    '__notifications',
    '_seasonModals',
    function (SEASON, $rootScope, $q, $state, __api, __localStorage, __notifications, _seasonModals) {
        var self = this;
        this.drilldown = {
            season: null,
            week: null,
            game: null,
        };
        /**
         * Retrieves all seasons
         */
        this.getSeasons = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting seasons...');
            __api.get(__api.path(SEASON.ENDPOINT, SEASON.GET_SEASONS))
                .then(function (response) {
                var collection = new Season.Models.SeasonModelCollection();
                if (response && response.data && response.data.results) {
                    var seasonResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < seasonResults.length; i++) {
                        var seasonResult = seasonResults[i];
                        if (seasonResult && seasonResult.data && seasonResult.data.model) {
                            var seasonModel = new Season.Models.SeasonModel();
                            seasonResult.data.model.key = seasonResult.key;
                            seasonModel.fromJson(seasonResult.data.model);
                            collection.add(seasonModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Seasons successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Seasons');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single season with the given key
         * @param {number} key The key of the season to retrieve
         */
        this.getSeason = function (key) {
            var d = $q.defer();
            __api.get(__api.path(SEASON.ENDPOINT, SEASON.GET_SEASON, '/' + key))
                .then(function (response) {
                var season = Common.Utilities.parseData(response.data.results);
                d.resolve(season);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a season model to the server for storage
         * @param {Common.Models.SeasonModel} seasonModel The model to be created/saved
         */
        this.createSeason = function (newSeasonModel) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newSeasonModel)) {
                var nameExists = impakt.context.Season.seasons.hasElementWhich(function (seasonModel, index) {
                    return seasonModel.name == newSeasonModel.name;
                });
                if (nameExists) {
                    var notification_6 = __notifications.warning('Failed to create season. Season "', newSeasonModel.name, '" already exists.');
                    _seasonModals.createSeasonDuplicate(newSeasonModel);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newSeasonModel.key = -1;
            var seasonModelJson = newSeasonModel.toJson();
            var notification = __notifications.pending('Creating season "', newSeasonModel.name, '"...');
            __api.post(__api.path(SEASON.ENDPOINT, SEASON.CREATE_SEASON), {
                version: 1,
                name: newSeasonModel.name,
                data: {
                    version: 1,
                    model: seasonModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var seasonModel = new Season.Models.SeasonModel();
                if (results && results.data && results.data.model) {
                    results.data.model.key = results.key;
                    seasonModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.Season.seasons.add(seasonModel);
                }
                else {
                    throw new Error('CreateSeason did not return a valid season model');
                }
                notification.success('Successfully created season "', seasonModel.name, '"');
                $rootScope.$broadcast('create-entity', seasonModel);
                d.resolve(seasonModel);
            }, function (error) {
                notification.error('Failed to create season "', newSeasonModel.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given season for the current user
         * @param {Season.Models.SeasonModel} season The season to be deleted
         */
        this.deleteSeason = function (season) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting season "', season.name, '"...');
            __api.post(__api.path(SEASON.ENDPOINT, SEASON.DELETE_SEASON), { key: season.key }).then(function (response) {
                // update the context
                impakt.context.Season.seasons.remove(season.guid);
                notification.success('Deleted season "', season.name, '"');
                if ($state.is('season.drilldown.season'))
                    self.toBrowser();
                d.resolve(season);
            }, function (error) {
                notification.error('Failed to delete season "', season.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given season for the current user
         * @param {Season.Models.SeasonModel} season The season to update
         */
        this.updateSeason = function (season) {
            var d = $q.defer();
            // update assignment collection to json object
            var seasonJson = season.toJson();
            var notification = __notifications.pending('Updating season "', season.name, '"...');
            __api.post(__api.path(SEASON.ENDPOINT, SEASON.UPDATE_SEASON), {
                version: 1,
                name: seasonJson.name,
                key: seasonJson.key,
                data: {
                    version: 1,
                    key: seasonJson.key,
                    model: seasonJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var seasonModel = new Season.Models.SeasonModel();
                if (results && results.data && results.data.model) {
                    seasonModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.Season.seasons.set(seasonModel.guid, seasonModel);
                }
                notification.success('Successfully updated season "', season.name, '"');
                d.resolve(seasonModel);
            }, function (error) {
                notification.error('Failed to update season "', season.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Retrieves all games
         */
        this.getGames = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting games...');
            __api.get(__api.path(SEASON.ENDPOINT, SEASON.GET_GAMES))
                .then(function (response) {
                var collection = new Season.Models.GameCollection();
                if (response && response.data && response.data.results) {
                    var gameResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < gameResults.length; i++) {
                        var gameResult = gameResults[i];
                        if (gameResult && gameResult.data && gameResult.data.game) {
                            var gameModel = new Season.Models.Game();
                            gameResult.data.game.key = gameResult.key;
                            gameModel.fromJson(gameResult.data.game);
                            collection.add(gameModel);
                        }
                    }
                }
                notification.success([collection.size(), ' Games successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve Games');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single game with the given key
         * @param {number} key The key of the game to retrieve
         */
        this.getGame = function (key) {
            var d = $q.defer();
            __api.get(__api.path(SEASON.ENDPOINT, SEASON.GET_GAME, '/' + key))
                .then(function (response) {
                var game = Common.Utilities.parseData(response.data.results);
                d.resolve(game);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a game model to the server for storage
         * @param {Common.Models.Game} newGame The game to be created/saved
         */
        this.createGame = function (newGame) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newGame)) {
                var nameExists = impakt.context.Season.games.hasElementWhich(function (gameModel, index) {
                    return gameModel.name == newGame.name;
                });
                if (nameExists) {
                    var notification_7 = __notifications.warning('Failed to create game. Game "', newGame.name, '" already exists.');
                    _seasonModals.createGameDuplicate(newGame);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newGame.key = -1;
            var gameModelJson = newGame.toJson();
            var notification = __notifications.pending('Creating game "', newGame.name, '"...');
            __api.post(__api.path(SEASON.ENDPOINT, SEASON.CREATE_GAME), {
                version: 1,
                name: newGame.name,
                data: {
                    version: 1,
                    game: gameModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var gameModel = new Season.Models.Game();
                if (results && results.data && results.data.game) {
                    results.data.game.key = results.key;
                    gameModel.fromJson(results.data.game);
                    // update the context
                    impakt.context.Season.games.add(gameModel);
                }
                else {
                    throw new Error('CreateGame did not return a valid game');
                }
                notification.success('Successfully created game "', gameModel.name, '"');
                $rootScope.$broadcast('create-entity', gameModel);
                d.resolve(gameModel);
            }, function (error) {
                notification.error('Failed to create game "', newGame.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given game for the current user
         * @param {Season.Models.Game} game The game to be deleted
         */
        this.deleteGame = function (game) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting game "', game.name, '"...');
            __api.post(__api.path(SEASON.ENDPOINT, SEASON.DELETE_GAME), { key: game.key }).then(function (response) {
                // update the context
                impakt.context.Season.games.remove(game.guid);
                notification.success('Deleted game "', game.name, '"');
                d.resolve(game);
            }, function (error) {
                notification.error('Failed to delete game "', game.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given game for the current user
         * @param {Season.Models.Game} game The game to update
         */
        this.updateGame = function (game) {
            var d = $q.defer();
            // update assignment collection to json object
            var gameJson = game.toJson();
            var notification = __notifications.pending('Updating game "', game.name, '"...');
            __api.post(__api.path(SEASON.ENDPOINT, SEASON.UPDATE_GAME), {
                version: 1,
                name: gameJson.name,
                key: gameJson.key,
                data: {
                    version: 1,
                    key: gameJson.key,
                    game: gameJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var gameModel = new Season.Models.Game();
                if (results && results.data && results.data.game) {
                    gameModel.fromJson(results.data.game);
                    // update the context
                    impakt.context.Season.games.set(gameModel.guid, gameModel);
                }
                notification.success('Successfully updated game "', game.name, '"');
                d.resolve(gameModel);
            }, function (error) {
                notification.error('Failed to update game "', game.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        this.deleteEntityByType = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity))
                return;
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Season:
                    return _seasonModals.deleteSeason(entity);
                case Common.Enums.ImpaktDataTypes.Game:
                    return _seasonModals.deleteGame(entity);
                default:
                    d.reject(new Error('_season deleteEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise;
        };
        this.updateEntityByType = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity))
                return;
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Season:
                    return _seasonModals.saveSeason(entity);
                case Common.Enums.ImpaktDataTypes.Game:
                    return _seasonModals.saveGame(entity);
                default:
                    d.reject(new Error('_season saveEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise;
        };
        this.toBrowser = function () {
            this.drilldown.season = null;
            this.drilldown.game = null;
            $state.transitionTo('season.browser');
        };
        this.toSeasonDrilldown = function (season) {
            this.drilldown.season = season;
            this.drilldown.week = null;
            this.drilldown.game = null;
            impakt.context.Season.seasons.select(season);
            _deselectEntities(false, true);
            impakt.context.Actionable.selected.only(season);
            $state.transitionTo('season.drilldown.season');
        };
        this.toWeekDrilldown = function (week) {
            this.drilldown.week = week;
            this.drilldown.game = null;
            this.drilldown.season.weeks.select(week);
            _deselectEntities(true, true);
            impakt.context.Actionable.selected.only(week);
            $state.transitionTo('season.drilldown.week');
        };
        this.toGameDrilldown = function (game) {
            this.drilldown.game = game;
            impakt.context.Season.games.select(game);
            _deselectEntities(true, false);
            impakt.context.Actionable.selected.only(game);
            $state.transitionTo('season.drilldown.game');
        };
        function _deselectEntities(deselectSeasons, deselectGames) {
            deselectSeasons && impakt.context.Season.seasons.deselectAll();
            deselectGames && impakt.context.Season.games.deselectAll();
        }
    }]);
/// <reference path='../modules.mdl.ts' />
impakt.sidebar = angular.module('impakt.sidebar', [
    'impakt.playbook.sidebar'
])
    .config([
    '$stateProvider',
    function ($stateProvider) {
        console.debug('impakt.sidebar - config');
    }])
    .run([function () {
        console.debug('impakt.sidebar - run');
    }]);
/// <reference path='./sidebar.mdl.ts' />
impakt.sidebar.controller('sidebar.ctrl', [
    '$scope',
    function ($scope) {
    }]);
/// <references path='./interfaces.ts' />
/// <reference path='../modules.mdl.ts' />
/// <reference path='./team.ts' />
impakt.team = angular.module('impakt.team', [
    'impakt.team.personnel',
    'impakt.team.main',
    'impakt.team.unitTypes',
    'impakt.team.modals'
])
    .config([function () {
        console.debug('impakt.team - config');
    }])
    .run(function () {
    console.debug('impakt.team - run');
});
/// <reference path='../team.mdl.ts' />
impakt.team.main = angular.module('impakt.team.main', [])
    .config([function () {
        console.debug('impakt.team.main - config');
    }])
    .run(function () {
    console.debug('impakt.team.main - run');
});
/// <reference path='./team-main.mdl.ts' />
impakt.team.main.controller('team.main.ctrl', ['$scope', '_team', '_teamModals',
    function ($scope, _team, _teamModals) {
        $scope.createTeam = function () {
            _teamModals.createTeam();
        };
    }]);
/// <reference path='../team.mdl.ts' />
impakt.team.modals = angular.module('impakt.team.modals', [])
    .config(function () {
    console.debug('impakt.team.modals - config');
})
    .run(function () {
    console.debug('impakt.team.modals - run');
});
/// <reference path='../team-modals.mdl.ts' />
impakt.team.modals.controller('team.modals.createTeamDuplicateError.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_team',
    'team',
    function ($scope, $uibModalInstance, _team, team) {
        $scope.team = team;
        $scope.ok = function () {
            $uibModalInstance.close();
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='../team-modals.mdl.ts' />
impakt.team.modals.controller('team.modals.createTeam.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_associations',
    '_team',
    '_leagueModals',
    'division',
    function ($scope, $uibModalInstance, _associations, _team, _leagueModals, division) {
        $scope.newTeamModel = new Team.Models.TeamModel();
        $scope.teamTypes = Common.Utilities.convertEnumToList(Team.Enums.TeamTypes);
        $scope.divisions = impakt.context.League.divisions;
        $scope.locations = impakt.context.League.locations;
        $scope.selectedDivision = division ? division : $scope.divisions.first();
        $scope.selectedLocation = $scope.locations.first();
        function init() {
            $scope.selectDivision();
            $scope.selectLocation();
        }
        $scope.selectDivision = function () {
            if (Common.Utilities.isNotNullOrUndefined($scope.selectedDivision)) {
                $scope.newTeamModel.setDivision($scope.selectedDivision);
            }
        };
        $scope.selectLocation = function () {
            if (Common.Utilities.isNotNullOrUndefined($scope.selectedLocation)) {
                $scope.newTeamModel.setLocation($scope.selectedLocation);
            }
        };
        $scope.createLocation = function () {
            _leagueModals.createLocation().then(function (createdLocation) {
                $scope.locations = impakt.context.League.locations;
                $scope.selectedLocation = createdLocation;
                $scope.setLocation();
            });
        };
        $scope.ok = function () {
            _team.createTeam($scope.newTeamModel)
                .then(function (createdTeam) {
                var associationsToAdd = [
                    $scope.selectedDivision,
                    $scope.selectedLocation
                ];
                if (Common.Utilities.isNotNullOrUndefined($scope.selectedDivision.conference)) {
                    associationsToAdd.push($scope.selectedDivision.conference);
                }
                if (Common.Utilities.isNotNullOrUndefined($scope.selectedDivision.conference.league)) {
                    associationsToAdd.push($scope.selectedDivision.conference.league);
                }
                _associations.createAssociations(createdTeam, associationsToAdd);
                $uibModalInstance.close(createdTeam);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
        function removeTeamFromCreationContext() {
            // Remove the play from the creation context
            // after creating the new play or cancelling
            if (Common.Utilities.isNotNullOrUndefined($scope.newTeamModel))
                impakt.context.Team.creation.teams.remove($scope.newTeam.guid);
        }
        init();
    }]);
/// <reference path='../team-modals.mdl.ts' />
impakt.team.modals.controller('team.modals.deleteTeam.ctrl', [
    '$scope',
    '$rootScope',
    '$uibModalInstance',
    '_team',
    '_league',
    'team',
    function ($scope, $rootScope, $uibModalInstance, _team, _league, team) {
        $scope.team = team;
        $scope.ok = function () {
            _team.deleteTeam($scope.team)
                .then(function (results) {
                $rootScope.$broadcast('delete-team', $scope.team);
                $uibModalInstance.close(results);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='./team-modals.mdl.ts' />
impakt.team.modals.service('_teamModals', [
    '$q',
    '__modals',
    function ($q, __modals) {
        /**
         *
         * Team
         *
         */
        this.createTeam = function (division) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/team/modals/create-team/create-team.tpl.html', 'team.modals.createTeam.ctrl', {
                division: function () {
                    return division;
                }
            });
            modalInstance.result.then(function (createdTeam) {
                console.log(createdTeam);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.createTeamDuplicate = function (teamModel) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/team/modals/create-team-duplicate-error/create-team-duplicate-error.tpl.html', 'team.modals.createTeamDuplicateError.ctrl', {
                team: function () {
                    return teamModel;
                }
            });
            modalInstance.result.then(function (createdTeam) {
                console.log(createdTeam);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
        this.deleteTeam = function (teamModel) {
            var d = $q.defer();
            var modalInstance = __modals.open('', 'modules/team/modals/delete-team/delete-team.tpl.html', 'team.modals.deleteTeam.ctrl', {
                team: function () {
                    return teamModel;
                }
            });
            modalInstance.result.then(function (results) {
                console.log(results);
                d.resolve();
            }, function (results) {
                console.log('dismissed');
                d.reject();
            });
            return d.promise;
        };
    }]);
/// <reference path='../team.mdl.ts' />
impakt.team.personnel = angular.module('impakt.team.personnel', [
    'impakt.team.personnel.create'
])
    .config([function () {
        console.debug('impakt.team.create -- config');
    }])
    .run([function () {
        console.debug('impakt.team.create -- run');
    }]);
/// <reference path='../team-personnel.mdl.ts' />
impakt.team.personnel.create = angular.module('impakt.team.personnel.create', [])
    .config([function () {
        console.debug('impakt.team.create -- config');
    }])
    .run([function () {
        console.debug('impakt.team.create -- run');
    }]);
/// <reference path='./team-personnel-create.mdl.ts' />
impakt.team.personnel.create.controller('impakt.team.personnel.create.ctrl', [
    '$scope',
    '_team',
    function ($scope, _team) {
        console.debug('impakt.team.personnel.create.ctrl');
    }
]);
/// <reference path='./team-personnel.mdl.ts' />
impakt.team.personnel.controller('impakt.team.personnel.ctrl', [
    '$scope',
    '_team',
    function ($scope, _team) {
        console.debug('impakt.team.personnel.ctrl');
        $scope.personnelCollection;
        $scope.personnel;
        $scope.selectedPersonnel;
        $scope.unitTypes = Team.Models.UnitType.getUnitTypes();
        var positionDefault = new Team.Models.PositionDefault();
        $scope.positionOptions;
        $scope.createNew = false;
        $scope.creating = false;
        function init() {
            _team.initialize();
            $scope.personnelCollection = _team.personnel;
            $scope.personnel = _team.personnel.getOne() ||
                new Team.Models.Personnel(Team.Enums.UnitTypes.Other);
            $scope.selectedPersonnel = {
                guid: $scope.personnel.guid,
                unitType: $scope.personnel.unitType.toString()
            };
            $scope.positionOptions = positionDefault.getByUnitType($scope.personnel.unitType);
        }
        $scope.cancelCreate = function () {
            $scope.creating = false;
        };
        $scope.createPersonnel = function () {
            $scope.personnel = new Team.Models.Personnel(Team.Enums.UnitTypes.Other);
            $scope.creating = true;
            $scope.selectedPersonnel.unitType = $scope.personnel.unitType;
            $scope.createNew = true;
        };
        $scope.selectPersonnel = function () {
            $scope.createNew = false;
            console.log($scope.selectedPersonnel.guid);
            if ($scope.selectedPersonnel.guid) {
                $scope.personnel = null;
                $scope.personnel = $scope.personnelCollection.get($scope.selectedPersonnel.guid);
                $scope.selectedPersonnel.unitType = $scope.personnel.unitType.toString();
                $scope.positionOptions = positionDefault.getByUnitType($scope.personnel.unitType);
            }
        };
        $scope.selectUnitType = function () {
            $scope.personnel.setUnitType(parseInt($scope.selectedPersonnel.unitType));
            $scope.positionOptions = positionDefault.getByUnitType($scope.personnel.unitType);
        };
        $scope.update = function (position, index) {
            var updated = impakt.context.Team.positionDefaults.switchPosition(position, position.positionListValue);
            console.log(position, updated);
            $scope.personnel.positions.replace(position.guid, updated);
        };
        $scope.save = function () {
            console.log($scope.personnel);
            _team.savePersonnel($scope.personnel, $scope.createNew).then(function (results) {
                console.log(results);
            }, function (err) {
                console.error(err);
            });
        };
        $scope.deletePersonnel = function (personnelItem) {
            console.log('deleting personnel', personnelItem);
            _team.deletePersonnel(personnelItem).then(function (results) {
                console.log(results);
            }, function (err) {
                console.error(err);
            });
        };
        init();
    }
]);
/// <reference path='./team.mdl.ts' />
/**
 * Team constants defined here
 */
impakt.team.constant('TEAM', {
    ENDPOINT: '/playbook',
    // Personnel
    CREATE_PERSONNEL: '/createPersonnel',
    UPDATE_PERSONNEL: '/updatePlay',
    GET_PERSONNEL: '/getPlay',
    GET_PERSONNELGROUPS: '/getPlays',
    DELETE_PERSONNEL: '/deletePlay',
    // Sets
    CREATE_SET: '/createSet',
    GET_SETS: '/getSets',
    UPDATE_SET: '/updateSet',
    DELETE_SET: '/deleteSet'
});
/// <reference path='./team.mdl.ts' />
impakt.team.controller('team.ctrl', ['$scope', '_team',
    function ($scope, _team) {
        $scope.title = 'Team Management';
        $scope.tabs = {
            personnel: {
                title: 'Personnel groups',
                active: true,
                src: "modules/team/personnel/team-personnel.tpl.html"
            },
            teams: {
                title: 'My teams',
                active: false,
                src: 'modules/team/main/team-main.tpl.html'
            },
            unitTypes: {
                title: 'Unit types',
                active: false,
                src: "modules/team/unit-types/team-unit-types.tpl.html"
            }
        };
        $scope.activate = function (tab) {
            for (var key in $scope.tabs) {
                var obj = $scope.tabs[key];
                if (obj.active)
                    obj.active = false;
            }
            tab.active = true;
        };
    }]);
/// <reference path='./team.mdl.ts' />
// Team service
impakt.team.service('_team', [
    '$rootScope',
    '$q',
    'PLAYBOOK',
    'TEAM',
    'LEAGUE',
    '__api',
    '__notifications',
    '_teamModals',
    function ($rootScope, $q, PLAYBOOK, TEAM, LEAGUE, __api, __notifications, _teamModals) {
        this.personnel = null;
        this.initialize = function () {
            this.personnel = impakt.context.Team.personnel;
        };
        /**
         * Retrieves all teams
         */
        this.getTeams = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Getting all league teams...');
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_TEAMS))
                .then(function (response) {
                var collection = new Team.Models.TeamModelCollection();
                if (response && response.data && response.data.results) {
                    var teamResults = Common.Utilities.parseData(response.data.results);
                    for (var i = 0; i < teamResults.length; i++) {
                        var teamResult = teamResults[i];
                        if (teamResult && teamResult.data && teamResult.data.model) {
                            var teamModel = new Team.Models.TeamModel();
                            teamResult.data.model.key = teamResult.key;
                            teamModel.fromJson(teamResult.data.model);
                            collection.add(teamModel);
                        }
                    }
                }
                notification.success([collection.size(), ' league teams successfully retreived'].join(''));
                d.resolve(collection);
            }, function (error) {
                notification.error('Failed to retieve league teams');
                console.error(error);
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Gets a single team with the given key
         * @param {number} key The key of the team to retrieve
         */
        this.getTeam = function (key) {
            var d = $q.defer();
            __api.get(__api.path(LEAGUE.ENDPOINT, LEAGUE.GET_TEAM, '/' + key))
                .then(function (response) {
                var team = Common.Utilities.parseData(response.data.results);
                d.resolve(team);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Sends a team model to the server for storage
         * @param {Team.Models.TeamModel} teamModel The model to be created/saved
         */
        this.createTeam = function (newTeamModel) {
            var d = $q.defer();
            if (Common.Utilities.isNotNullOrUndefined(newTeamModel)) {
                var nameExists = impakt.context.Team.teams.hasElementWhich(function (teamModel, index) {
                    return teamModel.name == newTeamModel.name;
                });
                if (nameExists) {
                    var notification_8 = __notifications.warning('Failed to create team. Team "', newTeamModel.name, '" already exists.');
                    _teamModals.createTeamDuplicate(newTeamModel);
                    return;
                }
            }
            // set key to -1 to ensure a new object is created server-side
            newTeamModel.key = -1;
            var teamModelJson = newTeamModel.toJson();
            var notification = __notifications.pending('Creating playbook "', newTeamModel.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.CREATE_TEAM), {
                version: 1,
                name: newTeamModel.name,
                data: {
                    version: 1,
                    model: teamModelJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var teamModel = new Team.Models.TeamModel();
                if (results && results.data && results.data.model) {
                    results.data.model.key = results.key;
                    teamModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.Team.teams.add(teamModel);
                }
                else {
                    throw new Error('CreateTeam did not return a valid team model');
                }
                notification.success('Successfully created team "', teamModel.name, '"');
                $rootScope.$broadcast('create-entity', teamModel);
                d.resolve(teamModel);
            }, function (error) {
                notification.error('Failed to create team "', newTeamModel.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Deletes the given team for the current user
         * @param {Team.Models.TeamModel} team The team to be deleted
         */
        this.deleteTeam = function (team) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting team "', team.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.DELETE_TEAM), { key: team.key }).then(function (response) {
                // update the context
                impakt.context.Team.teams.remove(team.guid);
                notification.success('Deleted team "', team.name, '"');
                d.resolve(team);
            }, function (error) {
                notification.error('Failed to delete team "', team.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        /**
         * Updates the given team for the current user
         * @param {Team.Models.TeamModel} team The team to update
         */
        this.updateTeam = function (team) {
            var d = $q.defer();
            // update assignment collection to json object
            var teamJson = team.toJson();
            var notification = __notifications.pending('Updating team "', team.name, '"...');
            __api.post(__api.path(LEAGUE.ENDPOINT, LEAGUE.UPDATE_TEAM), {
                version: 1,
                name: teamJson.name,
                key: teamJson.key,
                data: {
                    version: 1,
                    key: teamJson.key,
                    model: teamJson
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var teamModel = new Team.Models.TeamModel();
                if (results && results.data && results.data.model) {
                    teamModel.fromJson(results.data.model);
                    // update the context
                    impakt.context.Team.teams.set(teamModel.guid, teamModel);
                }
                notification.success('Successfully updated team "', team.name, '"');
                d.resolve(teamModel);
            }, function (error) {
                notification.error('Failed to update team "', team.name, '"');
                d.reject(error);
            });
            return d.promise;
        };
        this.getPersonnel = function () {
            var d = $q.defer();
            var personnelNotification = __notifications.pending('Getting Personnel...');
            __api.get(__api.path(TEAM.ENDPOINT, TEAM.GET_SETS))
                .then(function (response) {
                var personnelResults = Common.Utilities.parseData(response.data.results);
                var personnelCollection = new Team.Models.PersonnelCollection(Team.Enums.UnitTypes.Mixed);
                for (var i = 0; i < personnelResults.length; i++) {
                    var results = personnelResults[i];
                    if (results && results.data && results.data.personnel) {
                        var rawPersonnel = results.data.personnel;
                        rawPersonnel.key = results.key;
                        var personnelModel = new Team.Models.Personnel(Team.Enums.UnitTypes.Other);
                        personnelModel.fromJson(rawPersonnel);
                        personnelCollection.add(personnelModel);
                    }
                }
                personnelNotification.success(personnelCollection.size(), ' Personnel groups successfully retrieved');
                d.resolve(personnelCollection);
            }, function (error) {
                personnelNotification.error('Failed to retrieve Personnel groups');
                d.reject(error);
            });
            return d.promise;
        };
        this.savePersonnel = function (personnelModel, createNew) {
            var d = $q.defer();
            var result;
            var notification = __notifications.pending('Saving personnel "', personnelModel.name, '"...');
            if (createNew) {
                personnelModel.key = 0;
                personnelModel.guid = Common.Utilities.guid();
                result = this.createPersonnel(personnelModel);
            }
            else {
                result = this.updatePersonnel(personnelModel);
            }
            result.then(function (results) {
                notification.success('Successfully saved personnel "', personnelModel.name, '"');
                d.resolve(results);
            }, function (err) {
                notification.error('Failed to save personnel "', personnelModel.name, '"');
                d.reject(err);
            });
            return d.promise;
        };
        this.createPersonnel = function (personnelModel) {
            var d = $q.defer();
            var personnelJson = personnelModel.toJson();
            var notification = __notifications.pending('Creating personnel group "', personnelModel.name, '"...');
            __api.post(__api.path(TEAM.ENDPOINT, TEAM.CREATE_SET), {
                version: 1,
                ownerRK: 1,
                parentRK: 1,
                name: personnelJson.name,
                data: {
                    setType: Common.Enums.SetTypes.Personnel,
                    personnel: personnelJson,
                    name: personnelJson.name,
                    version: 1,
                    ownerRK: 1,
                    parentRK: 1
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var personnelModel = new Team.Models.Personnel(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.personnel) {
                    results.data.personnel.key = results.key;
                    personnelModel.fromJson(results.data.personnel);
                }
                impakt.context.Team.personnel.add(personnelModel);
                notification.success('Personnel group "', personnelModel.name, '" successfully created');
                $rootScope.$broadcast('create-entity', personnelModel);
                d.resolve(personnelModel);
            }, function (error) {
                d.reject(error);
            });
            return d.promise;
        };
        this.updatePersonnel = function (personnelModel) {
            var d = $q.defer();
            var personnelJson = personnelModel.toJson();
            var notification = __notifications.pending('Updating personnel "', personnelModel.name, '"...');
            __api.post(__api.path(TEAM.ENDPOINT, TEAM.UPDATE_SET), {
                version: 1,
                name: personnelJson.name,
                key: personnelJson.key,
                data: {
                    setType: Common.Enums.SetTypes.Personnel,
                    personnel: personnelJson,
                    name: personnelJson.name,
                    key: personnelJson.key,
                    version: 1
                }
            })
                .then(function (response) {
                var results = Common.Utilities.parseData(response.data.results);
                var personnelModel = new Team.Models.Personnel(Team.Enums.UnitTypes.Other);
                if (results && results.data && results.data.personnel) {
                    personnelModel.fromJson(results.data.personnel);
                }
                impakt.context.Team.personnel.set(personnelModel.guid, personnelModel);
                notification.success('Successfully updated personnel "', personnelModel.name, '"...');
                d.resolve(personnelModel);
            }, function (error) {
                notification.error('Failed to update personnel "', personnelModel.name, '"...');
                d.reject(error);
            });
            return d.promise;
        };
        this.deletePersonnel = function (personnelModel) {
            var d = $q.defer();
            var notification = __notifications.pending('Deleting personnel "', personnelModel.name, '"...');
            __api.post(__api.path(TEAM.ENDPOINT, TEAM.DELETE_SET), {
                key: personnelModel.key
            }).then(function (response) {
                impakt.context.Team.personnel.remove(personnelModel.guid);
                notification.success('Successfully saved personnel "', personnelModel.name, '"');
                d.resolve(response);
            }, function (err) {
                notification.error('Failed to save personnel "', personnelModel.name, '"');
                d.reject(err);
            });
            return d.promise;
        };
        this.deleteEntityByType = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity))
                return;
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Team:
                    return _teamModals.deleteTeam(entity);
                case Common.Enums.ImpaktDataTypes.PersonnelGroup:
                    // TODO @theBull implement
                    //return _teamModals.deletePersonnel(entity);
                    d.reject(new Error('_team deleteEntityByType(): _teamModals.deletePersonnel() not implemented'));
                    break;
                default:
                    d.reject(new Error('_team deleteEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise();
        };
        this.updateEntityByType = function (entity) {
            if (Common.Utilities.isNullOrUndefined(entity))
                return;
            var d = $q.defer();
            switch (entity.impaktDataType) {
                case Common.Enums.ImpaktDataTypes.Team:
                    return _teamModals.saveTeam(entity);
                case Common.Enums.ImpaktDataTypes.PersonnelGroup:
                    return _teamModals.savePersonnel(entity);
                default:
                    d.reject(new Error('_team updateEntityByType: impaktDataType not supported'));
                    break;
            }
            return d.promise();
        };
        this.createPrimaryTeam = function (teamModel) {
        };
        this.updatePrimaryTeam = function (teamModel) {
        };
        this.deletePrimaryTeam = function (teamModel) {
        };
        this.savePrimaryTeam = function (teamModel) {
        };
    }]);
/// <reference path='../team.mdl.ts' />
impakt.team.unitTypes = angular.module('impakt.team.unitTypes', [])
    .config([function () {
        console.debug('impakt.team.unitTypes - config');
    }])
    .run([function () {
        console.debug('impakt.team.unitTypes - run');
    }]);
/// <reference path='./team-unit-types.mdl.ts' />
impakt.team.unitTypes.controller('impakt.team.unitTypes.ctrl', [
    '$scope',
    '_team',
    function ($scope, _team) {
        $scope.unitTypes = impakt.context.Team.unitTypes.toArray();
    }
]);
/// <reference path='../modules.mdl.ts' />
impakt.user = angular.module('impakt.user', [
    'impakt.user.login',
    'impakt.user.modals'
])
    .config(function () {
    console.debug('impakt.user -- config');
})
    .run(function () {
    console.debug('impakt.user -- run');
});
/// <reference path='../user.mdl.ts' />
impakt.user.login = angular.module('impakt.user.login', [])
    .config(function () {
    console.debug('impakt.user.login - config');
})
    .run(function () {
    console.debug('impakt.user.login - run');
});
/// <reference path='./user-login.mdl.ts' />
impakt.user.login.controller('user.login.ctrl', ['$scope', function ($scope) {
    }]);
/// <reference path='../user.mdl.ts' />
impakt.user.modals = angular.module('impakt.user.modals', [])
    .config(function () {
    console.debug('impakt.user.modals - config');
})
    .run(function () {
    console.debug('impakt.user.modals - run');
});
/// <reference path='../user-modals.mdl.ts' />
impakt.user.modals.controller('user.modals.selectOrganization.ctrl', [
    '$scope',
    '$uibModalInstance',
    '_user',
    function ($scope, $uibModalInstance, _user) {
        $scope.selectedOrganization = _user.selectedOrganization;
        $scope.organizations = _user.organizations;
        $scope.organizationSelected = function () {
            console.log('selected organization', $scope.selectedOrganization);
        };
        $scope.ok = function () {
            _user.selectOrganization($scope.selectedOrganization)
                .then(function (selectedOrganization) {
                $uibModalInstance.close(selectedOrganization);
            }, function (err) {
                $uibModalInstance.close(err);
            });
        };
        $scope.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }]);
/// <reference path='./user-modals.mdl.ts' />
impakt.user.modals.service('_userModals', [
    '__modals',
    function (__modals) {
        /**
         *
         * PLAYBOOK
         *
         */
        this.selectOrganization = function () {
            var modalInstance = __modals.open('', 'modules/user/modals/select-organization/select-organization.tpl.html', 'user.modals.selectOrganization.ctrl', {});
            modalInstance.result.then(function (selectedOrganization) {
                console.log(selectedOrganization);
            }, function (results) {
                console.log('dismissed');
            });
        };
    }]);
/// <reference path='./models.ts' />
var User;
(function (User) {
    var Models;
    (function (Models) {
        var Account = (function (_super) {
            __extends(Account, _super);
            function Account() {
                _super.call(this);
            }
            Account.prototype.toJson = function () {
                return {
                    Name: this.name,
                    OrganizationKey: this.organizationKey
                };
            };
            Account.prototype.fromJson = function (json) {
                this.name = json.name;
                this.organizationKey = json.organizationKey;
            };
            return Account;
        })(Common.Models.Storable);
        Models.Account = Account;
    })(Models = User.Models || (User.Models = {}));
})(User || (User = {}));
/// <reference path='./models.ts' />
var User;
(function (User) {
    var Models;
    (function (Models) {
        var AccountUser = (function (_super) {
            __extends(AccountUser, _super);
            function AccountUser() {
                _super.call(this);
            }
            AccountUser.prototype.toJson = function () {
                return {};
            };
            AccountUser.prototype.fromJson = function () {
            };
            return AccountUser;
        })(Common.Models.Storable);
        Models.AccountUser = AccountUser;
    })(Models = User.Models || (User.Models = {}));
})(User || (User = {}));
/// <reference path='./models.ts' />
var User;
(function (User) {
    var Models;
    (function (Models) {
        var UserModel = (function (_super) {
            __extends(UserModel, _super);
            function UserModel() {
                _super.call(this);
                this.firstName = null;
                this.lastName = null;
                this.organizationKey = 0;
                this.organizationName = null;
                this.invitationType = 1;
                this.invitationKey = 0;
                this.email = null;
                this.recaptchaChallenge = '';
                this.recaptchaResponse = '';
            }
            UserModel.prototype.toJson = function () {
                return {
                    FirstName: this.firstName,
                    LastName: this.lastName,
                    OrganizationName: this.organizationName,
                    OrganizationKey: this.organizationKey,
                    InvitationType: this.invitationType,
                    InvitationKey: this.invitationKey,
                    Email: this.email,
                    RecaptchaChallenge: this.recaptchaChallenge,
                    RecaptchaResponse: this.recaptchaResponse
                };
            };
            UserModel.prototype.fromJson = function (json) {
                this.firstName = json.FirstName;
                this.lastName = json.LastName;
                this.organizationName = json.OrganizationName;
                this.email = json.Email;
            };
            return UserModel;
        })(Common.Models.Storable);
        Models.UserModel = UserModel;
    })(Models = User.Models || (User.Models = {}));
})(User || (User = {}));
/// <reference path='./user.mdl.ts' />
impakt.user.constant('USER', {
    'ORG_ENDPOINT': '/accounts',
    'GET_ORGANIZATIONS': '/getOrganizations'
});
/// <reference path='./user.mdl.ts' />
impakt.user.controller('impakt.user.ctrl', [
    '$scope',
    '$http',
    '$window',
    '__signin',
    '_user',
    function ($scope, $http, $window, __signin, _user) {
        $scope.userName = _user.userName;
        $scope.organizationKey = _user.organizationKey;
        $scope.isOnline = _user.isOnline;
        $scope.onlineStatus = _user.getOnlineStatusString();
        $scope.organizations = _user.organizations;
        $scope.selectedOrganization = _user.selectedOrganization;
        $scope.$watch('isOnline', function (newVal, oldVal) {
            $scope.onlineStatus = _user.getOnlineStatusString();
        });
        $scope.selectOrganization = function () {
            _user.selectOrganization($scope.selectedOrganization);
        };
        $scope.profileClick = function () {
            // TODO
        };
        $scope.logout = function () {
            confirm('Are you sure you want to logout? You will lose any unsaved data.') && __signin.logout();
        };
    }]);
/// <reference path='./user.mdl.ts' />
impakt.user.service('_user', [
    'USER',
    '$window',
    '$q',
    '__context',
    '__api',
    '__notifications',
    '__localStorage',
    '_userModals',
    function (USER, $window, $q, __context, __api, __notifications, __localStorage, _userModals) {
        this.userName = __localStorage.getUserName();
        this.organizationKey = __localStorage.getOrganizationKey();
        this.organizations = new User.Models.OrganizationCollection();
        this.selectedOrganization = null;
        this.isOnline = navigator ? navigator.onLine : undefined;
        var self = this;
        this.initialize = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Looking for default user organization...');
            var organizationKey = __localStorage.getOrganizationKey();
            self.getOrganizations().then(function (organizations) {
                // select default organization from localStorage
                if (organizations && organizations.hasElements() &&
                    organizationKey && organizationKey > 0) {
                    var selectedOrganization = organizations.filterFirst(function (organization, index) {
                        return organization.organizationKey == organizationKey;
                    });
                    self.selectOrganization(selectedOrganization);
                    notification.success('Default user organization #', organizationKey, ' is set');
                    d.resolve(self.selectedOrganization);
                }
                else {
                    // open select organization dialog
                    notification.warning('Default organization not found. Please select \
					an organization from the Profile area.');
                    _userModals.selectOrganization();
                    d.resolve(null);
                }
            }, function (err) {
                notification.error('Failed to set default organization #', organizationKey);
                d.reject(err);
            });
            return d.promise;
        };
        $window.addEventListener("offline", function (e) {
            console.log('offline');
            self.isOnline = false;
        });
        $window.addEventListener("online", function (e) {
            console.log('online');
            self.isOnline = true;
        });
        this.selectOrganization = function (organization) {
            var d = $q.defer();
            var notification = __notifications.pending('Updating application context data...');
            if (!organization) {
                var errorMessage = 'Something went wrong while attempting to select the organization';
                notification.error(errorMessage);
                d.reject(errorMessage);
            }
            this.selectedOrganization = organization;
            impakt.context.Organization.current = organization;
            __localStorage.setOrganizationKey(organization.organizationKey);
            // make application context requests
            __context.initialize(impakt.context).then(function (results) {
                notification.success('Successfully updated the application context data');
                d.resolve(self.selectedOrganization);
            }, function (err) {
                notification.error('Failed to update the application context data');
                d.reject(err);
            });
            return d.promise;
        };
        this.getOnlineStatusString = function () {
            return this.isOnline === true ? "online" :
                this.isOnline === false ? "offline" : "unknown";
        };
        this.getOrganizations = function () {
            var d = $q.defer();
            var notification = __notifications.pending('Retrieving Organizations...');
            __api.get(__api.path(USER.ORG_ENDPOINT, USER.GET_ORGANIZATIONS)).then(function (response) {
                if (response && response.data && response.data.results) {
                    var results = response.data.results;
                    for (var i = 0; i < results.length; i++) {
                        var result = response.data.results[i];
                        if (result) {
                            var organizationModel = new User.Models.Organization();
                            organizationModel.fromJson(result);
                            self.organizations.add(organizationModel);
                        }
                    }
                }
                notification.success(self.organizations.size(), ' Organizations successfully retrieved');
                d.resolve(self.organizations);
            }, function (err) {
                notification.error('Failed to retrieve Organizations');
                d.reject(err);
            });
            return d.promise;
        };
    }]);
//# sourceMappingURL=impakt.js.map